public static String unescape ( String in ) { StringBuilder out = StringUtil . borrowBuilder ( ) ; char last = 0 ; for ( char c : in . toCharArray ( ) ) { if ( c == ESC ) { if ( last != 0 && last == ESC ) out . append ( c ) ; } else out . append ( c ) ; last = c ; } return StringUtil . releaseBuilder ( out ) ; }
--------------------------------------------------
public Element appendElement ( String tagName ) { Element child = new Element ( Tag . valueOf ( tagName , NodeUtils . parser ( this ) . settings ( ) ) , baseUri ( ) ) ; appendChild ( child ) ; return child ; }
--------------------------------------------------
public static String escape ( String string , Document . OutputSettings out ) { if ( string == null ) return "" ; StringBuilder accum = StringUtil . borrowBuilder ( ) ; try { escape ( accum , string , out , false , false , false ) ; } catch ( IOException e ) { throw new SerializationException ( e ) ; } return StringUtil . releaseBuilder ( accum ) ; }
--------------------------------------------------
private static void appendEncoded ( Appendable accum , EscapeMode escapeMode , int codePoint ) throws IOException { final String name = escapeMode . nameForCodepoint ( codePoint ) ; if ( name != emptyName ) accum . append ( '&' ) . append ( name ) . append ( ';' ) ; else accum . append ( "&#x" ) . append ( Integer . toHexString ( codePoint ) ) . append ( ';' ) ; }
--------------------------------------------------
private static void appendWhitespaceIfBr ( Element element , StringBuilder accum ) { if ( element . tag . getName ( ) . equals ( "br" ) && ! TextNode . lastCharIsWhitespace ( accum ) ) accum . append ( " " ) ; }
--------------------------------------------------
public Elements parents ( ) { HashSet < Element > combo = new LinkedHashSet < > ( ) ; for ( Element e : this ) { combo . addAll ( e . parents ( ) ) ; } return new Elements ( combo ) ; }
--------------------------------------------------
boolean matchesIgnoreCase ( String seq ) { bufferUp ( ) ; int scanLength = seq . length ( ) ; if ( scanLength > bufLength - bufPos ) return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ; if ( upScan != upTarget ) return false ; } return true ; }
--------------------------------------------------
public static void appendNormalisedWhitespace ( StringBuilder accum , String string , boolean stripLeading ) { boolean lastWasWhite = false ; boolean reachedNonWhite = false ; int len = string . length ( ) ; int c ; for ( int i = 0 ; i < len ; i += Character . charCount ( c ) ) { c = string . codePointAt ( i ) ; if ( isActuallyWhitespace ( c ) ) { if ( ( stripLeading && ! reachedNonWhite ) || lastWasWhite ) continue ; accum . append ( ' ' ) ; lastWasWhite = true ; } else if ( ! isInvisibleChar ( c ) ) { accum . appendCodePoint ( c ) ; lastWasWhite = false ; reachedNonWhite = true ; } } }
--------------------------------------------------
private static void appendNormalisedText ( StringBuilder accum , TextNode textNode ) { String text = textNode . getWholeText ( ) ; if ( preserveWhitespace ( textNode . parentNode ) || textNode instanceof CDataNode ) accum . append ( text ) ; else StringUtil . appendNormalisedWhitespace ( accum , text , TextNode . lastCharIsWhitespace ( accum ) ) ; }
--------------------------------------------------
static URL encodeUrl ( URL u ) { try { String urlS = u . toExternalForm ( ) ; urlS = urlS . replaceAll ( " " , "%20" ) ; final URI uri = new URI ( urlS ) ; return new URL ( uri . toASCIIString ( ) ) ; } catch ( Exception e ) { return u ; } }
--------------------------------------------------
