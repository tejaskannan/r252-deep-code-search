public String getIgnoreCase ( String key ) { int i = indexOfKeyIgnoreCase ( key ) ; return i == NotFound ? EmptyString : checkNotNull ( vals [ i ] ) ; }
--------------------------------------------------
protected static boolean shouldCollapseAttribute ( final String key , final String val , final Document . OutputSettings out ) { return ( out . syntax ( ) == Document . OutputSettings . Syntax . html && ( val == null || ( "" . equals ( val ) || val . equalsIgnoreCase ( key ) ) && Attribute . isBooleanAttribute ( key ) ) ) ; }
--------------------------------------------------
Element getFromStack ( String elName ) { for ( int pos = stack . size ( ) - 1 ; pos >= 0 ; pos -- ) { Element next = stack . get ( pos ) ; if ( next . normalName ( ) . equals ( elName ) ) { return next ; } } return null ; }
--------------------------------------------------
public Elements getElementsByAttribute ( String key ) { Validate . notEmpty ( key ) ; key = key . trim ( ) ; return Collector . collect ( new Evaluator . Attribute ( key ) , this ) ; }
--------------------------------------------------
void reconstructFormattingElements ( ) { Element last = lastFormattingElement ( ) ; if ( last == null || onStack ( last ) ) return ; Element entry = last ; int size = formattingElements . size ( ) ; int pos = size - 1 ; boolean skip = false ; while ( true ) { if ( pos == 0 ) { skip = true ; break ; } entry = formattingElements . get ( -- pos ) ; if ( entry == null || onStack ( entry ) ) break ; } while ( true ) { if ( ! skip ) entry = formattingElements . get ( ++ pos ) ; Validate . notNull ( entry ) ; skip = false ; Element newEl = insertStartTag ( entry . normalName ( ) ) ; newEl . attributes ( ) . addAll ( entry . attributes ( ) ) ; formattingElements . set ( pos , newEl ) ; if ( pos == size - 1 ) break ; } }
--------------------------------------------------
public Elements getElementsByAttributeValueMatching ( String key , Pattern pattern ) { return Collector . collect ( new Evaluator . AttributeWithValueMatching ( key , pattern ) , this ) ; }
--------------------------------------------------
private void getWholeDeclaration ( Appendable accum , Document . OutputSettings out ) throws IOException { for ( Attribute attribute : attributes ( ) ) { if ( ! attribute . getKey ( ) . equals ( nodeName ( ) ) ) { accum . append ( ' ' ) ; attribute . html ( accum , out ) ; } } }
--------------------------------------------------
public Elements getElementsByAttributeStarting ( String keyPrefix ) { Validate . notEmpty ( keyPrefix ) ; keyPrefix = keyPrefix . trim ( ) ; return Collector . collect ( new Evaluator . AttributeStarting ( keyPrefix ) , this ) ; }
--------------------------------------------------
private static BomCharset detectCharsetFromBom ( final ByteBuffer byteData ) { final Buffer buffer = byteData ; buffer . mark ( ) ; byte [ ] bom = new byte [ 4 ] ; if ( byteData . remaining ( ) >= bom . length ) { byteData . get ( bom ) ; buffer . rewind ( ) ; } if ( bom [ 0 ] == 00 && bom [ 1 ] == 00 && bom [ 2 ] == ( byte ) fe && bom [ 3 ] == ( byte ) ff || bom [ 0 ] == ( byte ) ff && bom [ 1 ] == ( byte ) fe && bom [ 2 ] == 00 && bom [ 3 ] == 00 ) { return new BomCharset ( "utf-32" , false ) ; } else if ( bom [ 0 ] == ( byte ) fe && bom [ 1 ] == ( byte ) ff || bom [ 0 ] == ( byte ) ff && bom [ 1 ] == ( byte ) fe ) { return new BomCharset ( "utf-16" , false ) ; } else if ( bom [ 0 ] == ( byte ) ef && bom [ 1 ] == ( byte ) bb && bom [ 2 ] == ( byte ) bf ) { return new BomCharset ( "utf-8" , true ) ; } return null ; }
--------------------------------------------------
void generateImpliedEndTags ( String excludeTag ) { while ( ( excludeTag != null && ! currentElement ( ) . normalName ( ) . equals ( excludeTag ) ) && inSorted ( currentElement ( ) . normalName ( ) , TagSearchEndTags ) ) pop ( ) ; }
--------------------------------------------------
