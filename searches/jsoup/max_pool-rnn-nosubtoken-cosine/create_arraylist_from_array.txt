void error ( HtmlTreeBuilderState state ) { if ( parser . getErrors ( ) . canAddError ( ) ) parser . getErrors ( ) . add ( new ParseError ( reader . pos ( ) , "unexpected token [%s] when in state [%s]" , currentToken . tokenType ( ) , state ) ) ; }
--------------------------------------------------
static String mimeBoundary ( ) { final StringBuilder mime = StringUtil . borrowBuilder ( ) ; final Random rand = new Random ( ) ; for ( int i = 0 ; i < boundaryLength ; i ++ ) { mime . append ( mimeBoundaryChars [ rand . nextInt ( mimeBoundaryChars . length ) ] ) ; } return StringUtil . releaseBuilder ( mime ) ; }
--------------------------------------------------
boolean matchesIgnoreCase ( String seq ) { bufferUp ( ) ; int scanLength = seq . length ( ) ; if ( scanLength > bufLength - bufPos ) return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ; if ( upScan != upTarget ) return false ; } return true ; }
--------------------------------------------------
boolean matchesAnySorted ( char [ ] seq ) { bufferUp ( ) ; return ! isEmpty ( ) && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; }
--------------------------------------------------
public String html ( ) { StringBuilder accum = StringUtil . borrowBuilder ( ) ; html ( accum ) ; String html = StringUtil . releaseBuilder ( accum ) ; return NodeUtils . outputSettings ( this ) . prettyPrint ( ) ? html . trim ( ) : html ; }
--------------------------------------------------
public CharacterReader ( Reader input , int sz ) { Validate . notNull ( input ) ; Validate . isTrue ( input . markSupported ( ) ) ; reader = input ; charBuf = new char [ sz > maxBufferLen ? maxBufferLen : sz ] ; bufferUp ( ) ; }
--------------------------------------------------
public UnsupportedMimeTypeException ( String message , String mimeType , String url ) { super ( message ) ; this . mimeType = mimeType ; this . url = url ; }
--------------------------------------------------
@ Override Tag reset ( ) { tagName = null ; normalName = null ; pendingAttributeName = null ; reset ( pendingAttributeValue ) ; pendingAttributeValueS = null ; hasEmptyAttributeValue = false ; hasPendingAttributeValue = false ; selfClosing = false ; attributes = null ; return this ; }
--------------------------------------------------
public Element prependElement ( String tagName ) { Element child = new Element ( Tag . valueOf ( tagName , NodeUtils . parser ( this ) . settings ( ) ) , baseUri ( ) ) ; prependChild ( child ) ; return child ; }
--------------------------------------------------
private static boolean looksLikeUtf8 ( byte [ ] input ) { int i = 0 ; if ( input . length >= 3 && ( input [ 0 ] & ff ) == ef && ( input [ 1 ] & ff ) == bb & ( input [ 2 ] & ff ) == bf ) { i = 3 ; } int end ; for ( int j = input . length ; i < j ; ++ i ) { int o = input [ i ] ; if ( ( o & 80 ) == 0 ) { continue ; } if ( ( o & e0 ) == c0 ) { end = i + 1 ; } else if ( ( o & f0 ) == e0 ) { end = i + 2 ; } else if ( ( o & f8 ) == f0 ) { end = i + 3 ; } else { return false ; } while ( i < end ) { i ++ ; o = input [ i ] ; if ( ( o & c0 ) != 80 ) { return false ; } } } return true ; }
--------------------------------------------------
