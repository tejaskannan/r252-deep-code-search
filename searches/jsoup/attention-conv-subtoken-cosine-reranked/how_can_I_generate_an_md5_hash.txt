public int hashCode ( ) { int result = key != null ? key . hashCode ( ) : 0 ; result = 31 * result + ( val != null ? val . hashCode ( ) : 0 ) ; return result ; }
--------------------------------------------------
public W3CBuilder ( Document doc ) { this . doc = doc ; this . namespacesStack . push ( new HashMap < String , String > ( ) ) ; }
--------------------------------------------------
public static Elements select ( String query , Iterable < Element > roots ) { Validate . notEmpty ( query ) ; Validate . notNull ( roots ) ; Evaluator evaluator = QueryParser . parse ( query ) ; ArrayList < Element > elements = new ArrayList < > ( ) ; IdentityHashMap < Element , Boolean > seenElements = new IdentityHashMap < > ( ) ; for ( Element root : roots ) { final Elements found = select ( evaluator , root ) ; for ( Element el : found ) { if ( ! seenElements . containsKey ( el ) ) { elements . add ( el ) ; seenElements . put ( el , Boolean . TRUE ) ; } } } return new Elements ( elements ) ; }
--------------------------------------------------
public T removeHeader ( String name ) { Validate . notEmpty ( name , "header name must not be empty" ) ; Map . Entry < String , List < String >> entry = scanHeaders ( name ) ; if ( entry != null ) headers . remove ( entry . getKey ( ) ) ; return ( T ) this ; }
--------------------------------------------------
private void combinator ( char combinator ) { tq . consumeWhitespace ( ) ; String subQuery = consumeSubQuery ( ) ; Evaluator rootEval ; Evaluator currentEval ; Evaluator newEval = parse ( subQuery ) ; boolean replaceRightMost = false ; if ( evals . size ( ) == 1 ) { rootEval = currentEval = evals . get ( 0 ) ; if ( rootEval instanceof CombiningEvaluator . Or && combinator != ',' ) { currentEval = ( ( CombiningEvaluator . Or ) currentEval ) . rightMostEvaluator ( ) ; replaceRightMost = true ; } } else { rootEval = currentEval = new CombiningEvaluator . And ( evals ) ; } evals . clear ( ) ; if ( combinator == '>' ) currentEval = new CombiningEvaluator . And ( newEval , new StructuralEvaluator . ImmediateParent ( currentEval ) ) ; else if ( combinator == ' ' ) currentEval = new CombiningEvaluator . And ( newEval , new StructuralEvaluator . Parent ( currentEval ) ) ; else if ( combinator == '+' ) currentEval = new CombiningEvaluator . And ( newEval , new StructuralEvaluator . ImmediatePreviousSibling ( currentEval ) ) ; else if ( combinator == '~' ) currentEval = new CombiningEvaluator . And ( newEval , new StructuralEvaluator . PreviousSibling ( currentEval ) ) ; else if ( combinator == ',' ) { CombiningEvaluator . Or or ; if ( currentEval instanceof CombiningEvaluator . Or ) { or = ( CombiningEvaluator . Or ) currentEval ; or . add ( newEval ) ; } else { or = new CombiningEvaluator . Or ( ) ; or . add ( currentEval ) ; or . add ( newEval ) ; } currentEval = or ; } else throw new Selector . SelectorParseException ( "unknown combinator: " + combinator ) ; if ( replaceRightMost ) ( ( CombiningEvaluator . Or ) rootEval ) . replaceRightMostEvaluator ( currentEval ) ; else rootEval = currentEval ; evals . add ( rootEval ) ; }
--------------------------------------------------
public Element prependElement ( String tagName ) { Element child = new Element ( Tag . valueOf ( tagName , NodeUtils . parser ( this ) . settings ( ) ) , baseUri ( ) ) ; prependChild ( child ) ; return child ; }
--------------------------------------------------
static void crossStreams ( final InputStream in , final OutputStream out ) throws IOException { final byte [ ] buffer = new byte [ bufferSize ] ; int len ; while ( ( len = in . read ( buffer ) ) != - 1 ) { out . write ( buffer , 0 , len ) ; } }
--------------------------------------------------
public Document normalise ( ) { Element htmlEl = findFirstElementByTagName ( "html" , this ) ; if ( htmlEl == null ) htmlEl = appendElement ( "html" ) ; if ( head ( ) == null ) htmlEl . prependElement ( "head" ) ; if ( body ( ) == null ) htmlEl . appendElement ( "body" ) ; normaliseTextNodes ( head ( ) ) ; normaliseTextNodes ( htmlEl ) ; normaliseTextNodes ( this ) ; normaliseStructure ( "head" , htmlEl ) ; normaliseStructure ( "body" , htmlEl ) ; ensureMetaCharsetElement ( ) ; return this ; }
--------------------------------------------------
public Set < Entry < String , String >> entrySet ( ) { return new EntrySet ( ) ; }
--------------------------------------------------
private static String encodeUrl ( String url ) { try { URL u = new URL ( url ) ; return encodeUrl ( u ) . toExternalForm ( ) ; } catch ( Exception e ) { return url ; } }
--------------------------------------------------
