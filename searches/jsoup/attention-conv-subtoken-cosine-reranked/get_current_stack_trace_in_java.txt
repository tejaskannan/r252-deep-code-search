public W3CBuilder ( Document doc ) { this . doc = doc ; this . namespacesStack . push ( new HashMap < String , String > ( ) ) ; }
--------------------------------------------------
public T removeHeader ( String name ) { Validate . notEmpty ( name , "header name must not be empty" ) ; Map . Entry < String , List < String >> entry = scanHeaders ( name ) ; if ( entry != null ) headers . remove ( entry . getKey ( ) ) ; return ( T ) this ; }
--------------------------------------------------
public static int codepointsForName ( final String name , final int [ ] codepoints ) { String val = multipoints . get ( name ) ; if ( val != null ) { codepoints [ 0 ] = val . codePointAt ( 0 ) ; codepoints [ 1 ] = val . codePointAt ( 1 ) ; return 2 ; } int codepoint = extended . codepointForName ( name ) ; if ( codepoint != empty ) { codepoints [ 0 ] = codepoint ; return 1 ; } return 0 ; }
--------------------------------------------------
private void combinator ( char combinator ) { tq . consumeWhitespace ( ) ; String subQuery = consumeSubQuery ( ) ; Evaluator rootEval ; Evaluator currentEval ; Evaluator newEval = parse ( subQuery ) ; boolean replaceRightMost = false ; if ( evals . size ( ) == 1 ) { rootEval = currentEval = evals . get ( 0 ) ; if ( rootEval instanceof CombiningEvaluator . Or && combinator != ',' ) { currentEval = ( ( CombiningEvaluator . Or ) currentEval ) . rightMostEvaluator ( ) ; replaceRightMost = true ; } } else { rootEval = currentEval = new CombiningEvaluator . And ( evals ) ; } evals . clear ( ) ; if ( combinator == '>' ) currentEval = new CombiningEvaluator . And ( newEval , new StructuralEvaluator . ImmediateParent ( currentEval ) ) ; else if ( combinator == ' ' ) currentEval = new CombiningEvaluator . And ( newEval , new StructuralEvaluator . Parent ( currentEval ) ) ; else if ( combinator == '+' ) currentEval = new CombiningEvaluator . And ( newEval , new StructuralEvaluator . ImmediatePreviousSibling ( currentEval ) ) ; else if ( combinator == '~' ) currentEval = new CombiningEvaluator . And ( newEval , new StructuralEvaluator . PreviousSibling ( currentEval ) ) ; else if ( combinator == ',' ) { CombiningEvaluator . Or or ; if ( currentEval instanceof CombiningEvaluator . Or ) { or = ( CombiningEvaluator . Or ) currentEval ; or . add ( newEval ) ; } else { or = new CombiningEvaluator . Or ( ) ; or . add ( currentEval ) ; or . add ( newEval ) ; } currentEval = or ; } else throw new Selector . SelectorParseException ( "unknown combinator: " + combinator ) ; if ( replaceRightMost ) ( ( CombiningEvaluator . Or ) rootEval ) . replaceRightMostEvaluator ( currentEval ) ; else rootEval = currentEval ; evals . add ( rootEval ) ; }
--------------------------------------------------
public boolean hasHeader ( String name ) { Validate . notEmpty ( name , "header name must not be empty" ) ; return getHeadersCaseInsensitive ( name ) . size ( ) != 0 ; }
--------------------------------------------------
static String mimeBoundary ( ) { final StringBuilder mime = StringUtil . borrowBuilder ( ) ; final Random rand = new Random ( ) ; for ( int i = 0 ; i < boundaryLength ; i ++ ) { mime . append ( mimeBoundaryChars [ rand . nextInt ( mimeBoundaryChars . length ) ] ) ; } return StringUtil . releaseBuilder ( mime ) ; }
--------------------------------------------------
public String header ( String name ) { Validate . notNull ( name , "header name must not be null" ) ; List < String > vals = getHeadersCaseInsensitive ( name ) ; if ( vals . size ( ) > 0 ) { return StringUtil . join ( vals , ", " ) ; } return null ; }
--------------------------------------------------
public Element prependElement ( String tagName ) { Element child = new Element ( Tag . valueOf ( tagName , NodeUtils . parser ( this ) . settings ( ) ) , baseUri ( ) ) ; prependChild ( child ) ; return child ; }
--------------------------------------------------
public Node attr ( String attributeKey , String attributeValue ) { attributeKey = NodeUtils . parser ( this ) . settings ( ) . normalizeAttribute ( attributeKey ) ; attributes ( ) . putIgnoreCase ( attributeKey , attributeValue ) ; return this ; }
--------------------------------------------------
public Element empty ( ) { childNodes . clear ( ) ; return this ; }
--------------------------------------------------
