public boolean hasHeader ( String name ) { Validate . notEmpty ( name , "header name must not be empty" ) ; return getHeadersCaseInsensitive ( name ) . size ( ) != 0 ; }
--------------------------------------------------
public boolean hasNext ( ) { return i < size ; }
--------------------------------------------------
void popStackToClose ( String ... elNames ) { for ( int pos = stack . size ( ) - 1 ; pos >= 0 ; pos -- ) { Element next = stack . get ( pos ) ; stack . remove ( pos ) ; if ( inSorted ( next . normalName ( ) , elNames ) ) break ; } }
--------------------------------------------------
Element pop ( ) { int size = stack . size ( ) ; return stack . remove ( size - 1 ) ; }
--------------------------------------------------
static void crossStreams ( final InputStream in , final OutputStream out ) throws IOException { final byte [ ] buffer = new byte [ bufferSize ] ; int len ; while ( ( len = in . read ( buffer ) ) != - 1 ) { out . write ( buffer , 0 , len ) ; } }
--------------------------------------------------
public T removeHeader ( String name ) { Validate . notEmpty ( name , "header name must not be empty" ) ; Map . Entry < String , List < String >> entry = scanHeaders ( name ) ; if ( entry != null ) headers . remove ( entry . getKey ( ) ) ; return ( T ) this ; }
--------------------------------------------------
public static Elements select ( String query , Element root ) { Validate . notEmpty ( query ) ; return select ( QueryParser . parse ( query ) , root ) ; }
--------------------------------------------------
public Elements removeClass ( String className ) { for ( Element element : this ) { element . removeClass ( className ) ; } return this ; }
--------------------------------------------------
public void clear ( ) { onContentsChanged ( ) ; super . clear ( ) ; }
--------------------------------------------------
void popStackToClose ( String elName ) { for ( int pos = stack . size ( ) - 1 ; pos >= 0 ; pos -- ) { Element next = stack . get ( pos ) ; stack . remove ( pos ) ; if ( next . normalName ( ) . equals ( elName ) ) break ; } }
--------------------------------------------------
