public Attributes clone ( ) { Attributes clone ; try { clone = ( Attributes ) super . clone ( ) ; } catch ( CloneNotSupportedException e ) { throw new RuntimeException ( e ) ; } clone . size = size ; keys = copyOf ( keys , size ) ; vals = copyOf ( vals , size ) ; return clone ; }
--------------------------------------------------
public String toString ( ) { return String . format ( "#%s" , id ) ; }
--------------------------------------------------
public boolean hasHeader ( String name ) { Validate . notEmpty ( name , "header name must not be empty" ) ; return getHeadersCaseInsensitive ( name ) . size ( ) != 0 ; }
--------------------------------------------------
public Document clone ( ) { Document clone = ( Document ) super . clone ( ) ; clone . outputSettings = this . outputSettings . clone ( ) ; return clone ; }
--------------------------------------------------
public Parser ( TreeBuilder treeBuilder ) { this . treeBuilder = treeBuilder ; settings = treeBuilder . defaultSettings ( ) ; errors = ParseErrorList . noTracking ( ) ; }
--------------------------------------------------
public String toString ( ) { return super . toString ( ) + ". mimetype=" + mimeType + ", url=" + url ; }
--------------------------------------------------
void unconsume ( ) { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( "no buffer left to unconsume" ) ) ; bufPos -- ; }
--------------------------------------------------
void mark ( ) { bufSplitPoint = 0 ; bufferUp ( ) ; bufMark = bufPos ; }
--------------------------------------------------
public String toString ( ) { return String . format ( ".%s" , className ) ; }
--------------------------------------------------
public Attribute clone ( ) { try { return ( Attribute ) super . clone ( ) ; } catch ( CloneNotSupportedException e ) { throw new RuntimeException ( e ) ; } }
--------------------------------------------------
