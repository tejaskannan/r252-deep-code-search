private static void appendWhitespaceIfBr ( Element element , StringBuilder accum ) { if ( element . tag . getName ( ) . equals ( "br" ) && ! TextNode . lastCharIsWhitespace ( accum ) ) accum . append ( " " ) ; }
--------------------------------------------------
private static String fixHeaderEncoding ( String val ) { try { byte [ ] bytes = val . getBytes ( "iso-8859-1" ) ; if ( ! looksLikeUtf8 ( bytes ) ) return val ; return new String ( bytes , "utf-8" ) ; } catch ( UnsupportedEncodingException e ) { return val ; } }
--------------------------------------------------
public String normalizeAttribute ( String name ) { name = name . trim ( ) ; if ( ! preserveAttributeCase ) name = lowerCase ( name ) ; return name ; }
--------------------------------------------------
private static String validateCharset ( String cs ) { if ( cs == null || cs . length ( ) == 0 ) return null ; cs = cs . trim ( ) . replaceAll ( "["']" , "" ) ; try { if ( Charset . isSupported ( cs ) ) return cs ; cs = cs . toUpperCase ( Locale . ENGLISH ) ; if ( Charset . isSupported ( cs ) ) return cs ; } catch ( IllegalCharsetNameException e ) { } return null ; }
--------------------------------------------------
boolean matchesIgnoreCase ( String seq ) { bufferUp ( ) ; int scanLength = seq . length ( ) ; if ( scanLength > bufLength - bufPos ) return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ; if ( upScan != upTarget ) return false ; } return true ; }
--------------------------------------------------
public static void appendNormalisedWhitespace ( StringBuilder accum , String string , boolean stripLeading ) { boolean lastWasWhite = false ; boolean reachedNonWhite = false ; int len = string . length ( ) ; int c ; for ( int i = 0 ; i < len ; i += Character . charCount ( c ) ) { c = string . codePointAt ( i ) ; if ( isActuallyWhitespace ( c ) ) { if ( ( stripLeading && ! reachedNonWhite ) || lastWasWhite ) continue ; accum . append ( ' ' ) ; lastWasWhite = true ; } else if ( ! isInvisibleChar ( c ) ) { accum . appendCodePoint ( c ) ; lastWasWhite = false ; reachedNonWhite = true ; } } }
--------------------------------------------------
void maybeSetBaseUri ( Element base ) { if ( baseUriSetFromDoc ) return ; String href = base . absUrl ( "href" ) ; if ( href . length ( ) != 0 ) { baseUri = href ; baseUriSetFromDoc = true ; doc . setBaseUri ( href ) ; } }
--------------------------------------------------
Attributes normalizeAttributes ( Attributes attributes ) { if ( ! preserveAttributeCase ) { attributes . normalize ( ) ; } return attributes ; }
--------------------------------------------------
private void ensureAttributes ( ) { if ( ! hasAttributes ( ) ) { Object coreValue = value ; Attributes attributes = new Attributes ( ) ; value = attributes ; if ( coreValue != null ) attributes . put ( nodeName ( ) , ( String ) coreValue ) ; } }
--------------------------------------------------
public boolean matches ( Element root , Element element ) { return ! value . equalsIgnoreCase ( element . attr ( key ) ) ; }
--------------------------------------------------
