boolean matchesIgnoreCase ( String seq ) { bufferUp ( ) ; int scanLength = seq . length ( ) ; if ( scanLength > bufLength - bufPos ) return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ; if ( upScan != upTarget ) return false ; } return true ; }
--------------------------------------------------
private static String cacheString ( final char [ ] charBuf , final String [ ] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; if ( count < 1 ) return "" ; int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ; String cached = stringCache [ index ] ; if ( cached == null ) { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } else { if ( rangeEquals ( charBuf , start , count , cached ) ) { return cached ; } else { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } } return cached ; }
--------------------------------------------------
public String attr ( String attributeKey ) { Validate . notNull ( attributeKey ) ; if ( ! hasAttributes ( ) ) return EmptyString ; String val = attributes ( ) . getIgnoreCase ( attributeKey ) ; if ( val . length ( ) > 0 ) return val ; else if ( attributeKey . startsWith ( "abs:" ) ) return absUrl ( attributeKey . substring ( "abs:" . length ( ) ) ) ; else return "" ; }
--------------------------------------------------
private static String getRequestCookieString ( Connection . Request req ) { StringBuilder sb = StringUtil . borrowBuilder ( ) ; boolean first = true ; for ( Map . Entry < String , String > cookie : req . cookies ( ) . entrySet ( ) ) { if ( ! first ) sb . append ( "; " ) ; else first = false ; sb . append ( cookie . getKey ( ) ) . append ( '=' ) . append ( cookie . getValue ( ) ) ; } return StringUtil . releaseBuilder ( sb ) ; }
--------------------------------------------------
public static String unescape ( String in ) { StringBuilder out = StringUtil . borrowBuilder ( ) ; char last = 0 ; for ( char c : in . toCharArray ( ) ) { if ( c == ESC ) { if ( last != 0 && last == ESC ) out . append ( c ) ; } else out . append ( c ) ; last = c ; } return StringUtil . releaseBuilder ( out ) ; }
--------------------------------------------------
static URL encodeUrl ( URL u ) { try { String urlS = u . toExternalForm ( ) ; urlS = urlS . replaceAll ( " " , "%20" ) ; final URI uri = new URI ( urlS ) ; return new URL ( uri . toASCIIString ( ) ) ; } catch ( Exception e ) { return u ; } }
--------------------------------------------------
public String cssSelector ( ) { if ( id ( ) . length ( ) > 0 ) return "#" + id ( ) ; String tagName = tagName ( ) . replace ( ':' , '|' ) ; StringBuilder selector = new StringBuilder ( tagName ) ; String classes = StringUtil . join ( classNames ( ) , "." ) ; if ( classes . length ( ) > 0 ) selector . append ( '.' ) . append ( classes ) ; if ( parent ( ) == null || parent ( ) instanceof Document ) return selector . toString ( ) ; selector . insert ( 0 , " > " ) ; if ( parent ( ) . select ( selector . toString ( ) ) . size ( ) > 1 ) selector . append ( String . format ( ":nth-child(%d)" , elementSiblingIndex ( ) + 1 ) ) ; return parent ( ) . cssSelector ( ) + selector . toString ( ) ; }
--------------------------------------------------
public String html ( ) { StringBuilder accum = StringUtil . borrowBuilder ( ) ; html ( accum ) ; String html = StringUtil . releaseBuilder ( accum ) ; return NodeUtils . outputSettings ( this ) . prettyPrint ( ) ? html . trim ( ) : html ; }
--------------------------------------------------
public String attr ( String key ) { Validate . notNull ( key ) ; if ( ! hasAttributes ( ) ) { return key . equals ( nodeName ( ) ) ? ( String ) value : EmptyString ; } return super . attr ( key ) ; }
--------------------------------------------------
private static void serialiseRequestUrl ( Connection . Request req ) throws IOException { URL in = req . url ( ) ; StringBuilder url = StringUtil . borrowBuilder ( ) ; boolean first = true ; url . append ( in . getProtocol ( ) ) . append ( "://" ) . append ( in . getAuthority ( ) ) . append ( in . getPath ( ) ) . append ( "?" ) ; if ( in . getQuery ( ) != null ) { url . append ( in . getQuery ( ) ) ; first = false ; } for ( Connection . KeyVal keyVal : req . data ( ) ) { Validate . isFalse ( keyVal . hasInputStream ( ) , "inputstream data not supported in url query string." ) ; if ( ! first ) url . append ( '&' ) ; else first = false ; url . append ( URLEncoder . encode ( keyVal . key ( ) , DataUtil . defaultCharset ) ) . append ( '=' ) . append ( URLEncoder . encode ( keyVal . value ( ) , DataUtil . defaultCharset ) ) ; } req . url ( new URL ( StringUtil . releaseBuilder ( url ) ) ) ; req . data ( ) . clear ( ) ; }
--------------------------------------------------
