private static LinkedHashMap < String , List < String >> createHeaderMap ( HttpURLConnection conn ) { final LinkedHashMap < String , List < String >> headers = new LinkedHashMap < > ( ) ; int i = 0 ; while ( true ) { final String key = conn . getHeaderFieldKey ( i ) ; final String val = conn . getHeaderField ( i ) ; if ( key == null && val == null ) break ; i ++ ; if ( key == null || val == null ) continue ; if ( headers . containsKey ( key ) ) headers . get ( key ) . add ( val ) ; else { final ArrayList < String > vals = new ArrayList < > ( ) ; vals . add ( val ) ; headers . put ( key , vals ) ; } } return headers ; }
--------------------------------------------------
public List < String > eachAttr ( String attributeKey ) { List < String > attrs = new ArrayList < > ( size ( ) ) ; for ( Element element : this ) { if ( element . hasAttr ( attributeKey ) ) attrs . add ( element . attr ( attributeKey ) ) ; } return attrs ; }
--------------------------------------------------
private Map . Entry < String , List < String >> scanHeaders ( String name ) { String lc = lowerCase ( name ) ; for ( Map . Entry < String , List < String >> entry : headers . entrySet ( ) ) { if ( lowerCase ( entry . getKey ( ) ) . equals ( lc ) ) return entry ; } return null ; }
--------------------------------------------------
private void reindexChildren ( int start ) { final List < Node > childNodes = ensureChildNodes ( ) ; for ( int i = start ; i < childNodes . size ( ) ; i ++ ) { childNodes . get ( i ) . setSiblingIndex ( i ) ; } }
--------------------------------------------------
public Element insertChildren ( int index , Collection < ? extends Node > children ) { Validate . notNull ( children , "children collection to be inserted must not be null." ) ; int currentSize = childNodeSize ( ) ; if ( index < 0 ) index += currentSize + 1 ; Validate . isTrue ( index >= 0 && index <= currentSize , "insert position out of bounds." ) ; ArrayList < Node > nodes = new ArrayList < > ( children ) ; Node [ ] nodeArray = nodes . toArray ( new Node [ 0 ] ) ; addChildren ( index , nodeArray ) ; return this ; }
--------------------------------------------------
public List < Node > siblingNodes ( ) { if ( parentNode == null ) return Collections . emptyList ( ) ; List < Node > nodes = parentNode . ensureChildNodes ( ) ; List < Node > siblings = new ArrayList < > ( nodes . size ( ) - 1 ) ; for ( Node node : nodes ) if ( node != this ) siblings . add ( node ) ; return siblings ; }
--------------------------------------------------
public Elements parents ( ) { HashSet < Element > combo = new LinkedHashSet < > ( ) ; for ( Element e : this ) { combo . addAll ( e . parents ( ) ) ; } return new Elements ( combo ) ; }
--------------------------------------------------
public List < DataNode > dataNodes ( ) { List < DataNode > dataNodes = new ArrayList < > ( ) ; for ( Node node : childNodes ) { if ( node instanceof DataNode ) dataNodes . add ( ( DataNode ) node ) ; } return Collections . unmodifiableList ( dataNodes ) ; }
--------------------------------------------------
public Element appendElement ( String tagName ) { Element child = new Element ( Tag . valueOf ( tagName , NodeUtils . parser ( this ) . settings ( ) ) , baseUri ( ) ) ; appendChild ( child ) ; return child ; }
--------------------------------------------------
public static Elements select ( String query , Iterable < Element > roots ) { Validate . notEmpty ( query ) ; Validate . notNull ( roots ) ; Evaluator evaluator = QueryParser . parse ( query ) ; ArrayList < Element > elements = new ArrayList < > ( ) ; IdentityHashMap < Element , Boolean > seenElements = new IdentityHashMap < > ( ) ; for ( Element root : roots ) { final Elements found = select ( evaluator , root ) ; for ( Element el : found ) { if ( ! seenElements . containsKey ( el ) ) { elements . add ( el ) ; seenElements . put ( el , Boolean . TRUE ) ; } } } return new Elements ( elements ) ; }
--------------------------------------------------
