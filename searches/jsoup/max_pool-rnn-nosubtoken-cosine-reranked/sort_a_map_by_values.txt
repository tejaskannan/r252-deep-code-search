private static LinkedHashMap < String , List < String >> createHeaderMap ( HttpURLConnection conn ) { final LinkedHashMap < String , List < String >> headers = new LinkedHashMap < > ( ) ; int i = 0 ; while ( true ) { final String key = conn . getHeaderFieldKey ( i ) ; final String val = conn . getHeaderField ( i ) ; if ( key == null && val == null ) break ; i ++ ; if ( key == null || val == null ) continue ; if ( headers . containsKey ( key ) ) headers . get ( key ) . add ( val ) ; else { final ArrayList < String > vals = new ArrayList < > ( ) ; vals . add ( val ) ; headers . put ( key , vals ) ; } } return headers ; }
--------------------------------------------------
private Map . Entry < String , List < String >> scanHeaders ( String name ) { String lc = lowerCase ( name ) ; for ( Map . Entry < String , List < String >> entry : headers . entrySet ( ) ) { if ( lowerCase ( entry . getKey ( ) ) . equals ( lc ) ) return entry ; } return null ; }
--------------------------------------------------
public static Elements select ( String query , Iterable < Element > roots ) { Validate . notEmpty ( query ) ; Validate . notNull ( roots ) ; Evaluator evaluator = QueryParser . parse ( query ) ; ArrayList < Element > elements = new ArrayList < > ( ) ; IdentityHashMap < Element , Boolean > seenElements = new IdentityHashMap < > ( ) ; for ( Element root : roots ) { final Elements found = select ( evaluator , root ) ; for ( Element el : found ) { if ( ! seenElements . containsKey ( el ) ) { elements . add ( el ) ; seenElements . put ( el , Boolean . TRUE ) ; } } } return new Elements ( elements ) ; }
--------------------------------------------------
boolean matchesIgnoreCase ( String seq ) { bufferUp ( ) ; int scanLength = seq . length ( ) ; if ( scanLength > bufLength - bufPos ) return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ; if ( upScan != upTarget ) return false ; } return true ; }
--------------------------------------------------
public String getIgnoreCase ( String key ) { int i = indexOfKeyIgnoreCase ( key ) ; return i == NotFound ? EmptyString : checkNotNull ( vals [ i ] ) ; }
--------------------------------------------------
boolean matchesAnySorted ( char [ ] seq ) { bufferUp ( ) ; return ! isEmpty ( ) && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; }
--------------------------------------------------
public Document ( String baseUri ) { super ( Tag . valueOf ( "#root" , ParseSettings . htmlDefault ) , baseUri ) ; this . location = baseUri ; }
--------------------------------------------------
public String chompToIgnoreCase ( String seq ) { String data = consumeToIgnoreCase ( seq ) ; matchChomp ( seq ) ; return data ; }
--------------------------------------------------
void putIgnoreCase ( String key , String value ) { int i = indexOfKeyIgnoreCase ( key ) ; if ( i != NotFound ) { vals [ i ] = value ; if ( ! keys [ i ] . equals ( key ) ) keys [ i ] = key ; } else add ( key , value ) ; }
--------------------------------------------------
public static Element selectFirst ( String cssQuery , Element root ) { Validate . notEmpty ( cssQuery ) ; return Collector . findFirst ( QueryParser . parse ( cssQuery ) , root ) ; }
--------------------------------------------------
