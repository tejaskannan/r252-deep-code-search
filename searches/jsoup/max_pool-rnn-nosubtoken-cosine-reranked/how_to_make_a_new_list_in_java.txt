private void reindexChildren ( int start ) { final List < Node > childNodes = ensureChildNodes ( ) ; for ( int i = start ; i < childNodes . size ( ) ; i ++ ) { childNodes . get ( i ) . setSiblingIndex ( i ) ; } }
--------------------------------------------------
private Map . Entry < String , List < String >> scanHeaders ( String name ) { String lc = lowerCase ( name ) ; for ( Map . Entry < String , List < String >> entry : headers . entrySet ( ) ) { if ( lowerCase ( entry . getKey ( ) ) . equals ( lc ) ) return entry ; } return null ; }
--------------------------------------------------
public List < String > eachAttr ( String attributeKey ) { List < String > attrs = new ArrayList < > ( size ( ) ) ; for ( Element element : this ) { if ( element . hasAttr ( attributeKey ) ) attrs . add ( element . attr ( attributeKey ) ) ; } return attrs ; }
--------------------------------------------------
@ Override Tag reset ( ) { tagName = null ; normalName = null ; pendingAttributeName = null ; reset ( pendingAttributeValue ) ; pendingAttributeValueS = null ; hasEmptyAttributeValue = false ; hasPendingAttributeValue = false ; selfClosing = false ; attributes = null ; return this ; }
--------------------------------------------------
public List < DataNode > dataNodes ( ) { List < DataNode > dataNodes = new ArrayList < > ( ) ; for ( Node node : childNodes ) { if ( node instanceof DataNode ) dataNodes . add ( ( DataNode ) node ) ; } return Collections . unmodifiableList ( dataNodes ) ; }
--------------------------------------------------
protected Element doClone ( Node parent ) { Element clone = ( Element ) super . doClone ( parent ) ; clone . attributes = attributes != null ? attributes . clone ( ) : null ; clone . baseUri = baseUri ; clone . childNodes = new NodeList ( clone , childNodes . size ( ) ) ; clone . childNodes . addAll ( childNodes ) ; return clone ; }
--------------------------------------------------
void resetInsertionMode ( ) { boolean last = false ; for ( int pos = stack . size ( ) - 1 ; pos >= 0 ; pos -- ) { Element node = stack . get ( pos ) ; if ( pos == 0 ) { last = true ; node = contextElement ; } String name = node . normalName ( ) ; if ( "select" . equals ( name ) ) { transition ( HtmlTreeBuilderState . InSelect ) ; break ; } else if ( ( "td" . equals ( name ) || "th" . equals ( name ) && ! last ) ) { transition ( HtmlTreeBuilderState . InCell ) ; break ; } else if ( "tr" . equals ( name ) ) { transition ( HtmlTreeBuilderState . InRow ) ; break ; } else if ( "tbody" . equals ( name ) || "thead" . equals ( name ) || "tfoot" . equals ( name ) ) { transition ( HtmlTreeBuilderState . InTableBody ) ; break ; } else if ( "caption" . equals ( name ) ) { transition ( HtmlTreeBuilderState . InCaption ) ; break ; } else if ( "colgroup" . equals ( name ) ) { transition ( HtmlTreeBuilderState . InColumnGroup ) ; break ; } else if ( "table" . equals ( name ) ) { transition ( HtmlTreeBuilderState . InTable ) ; break ; } else if ( "head" . equals ( name ) ) { transition ( HtmlTreeBuilderState . InBody ) ; break ; } else if ( "body" . equals ( name ) ) { transition ( HtmlTreeBuilderState . InBody ) ; break ; } else if ( "frameset" . equals ( name ) ) { transition ( HtmlTreeBuilderState . InFrameset ) ; break ; } else if ( "html" . equals ( name ) ) { transition ( HtmlTreeBuilderState . BeforeHead ) ; break ; } else if ( last ) { transition ( HtmlTreeBuilderState . InBody ) ; break ; } } }
--------------------------------------------------
@ Override Token reset ( ) { reset ( name ) ; pubSysKey = null ; reset ( publicIdentifier ) ; reset ( systemIdentifier ) ; forceQuirks = false ; return this ; }
--------------------------------------------------
public static Elements select ( String query , Iterable < Element > roots ) { Validate . notEmpty ( query ) ; Validate . notNull ( roots ) ; Evaluator evaluator = QueryParser . parse ( query ) ; ArrayList < Element > elements = new ArrayList < > ( ) ; IdentityHashMap < Element , Boolean > seenElements = new IdentityHashMap < > ( ) ; for ( Element root : roots ) { final Elements found = select ( evaluator , root ) ; for ( Element el : found ) { if ( ! seenElements . containsKey ( el ) ) { elements . add ( el ) ; seenElements . put ( el , Boolean . TRUE ) ; } } } return new Elements ( elements ) ; }
--------------------------------------------------
public List < Node > siblingNodes ( ) { if ( parentNode == null ) return Collections . emptyList ( ) ; List < Node > nodes = parentNode . ensureChildNodes ( ) ; List < Node > siblings = new ArrayList < > ( nodes . size ( ) - 1 ) ; for ( Node node : nodes ) if ( node != this ) siblings . add ( node ) ; return siblings ; }
--------------------------------------------------
