public static String unescape ( String in ) { StringBuilder out = StringUtil . borrowBuilder ( ) ; char last = 0 ; for ( char c : in . toCharArray ( ) ) { if ( c == ESC ) { if ( last != 0 && last == ESC ) out . append ( c ) ; } else out . append ( c ) ; last = c ; } return StringUtil . releaseBuilder ( out ) ; }
--------------------------------------------------
public Elements parents ( ) { HashSet < Element > combo = new LinkedHashSet < > ( ) ; for ( Element e : this ) { combo . addAll ( e . parents ( ) ) ; } return new Elements ( combo ) ; }
--------------------------------------------------
static String getCharsetFromContentType ( String contentType ) { if ( contentType == null ) return null ; Matcher m = charsetPattern . matcher ( contentType ) ; if ( m . find ( ) ) { String charset = m . group ( 1 ) . trim ( ) ; charset = charset . replace ( "charset=" , "" ) ; return validateCharset ( charset ) ; } return null ; }
--------------------------------------------------
boolean matchesIgnoreCase ( String seq ) { bufferUp ( ) ; int scanLength = seq . length ( ) ; if ( scanLength > bufLength - bufPos ) return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ; if ( upScan != upTarget ) return false ; } return true ; }
--------------------------------------------------
static URL encodeUrl ( URL u ) { try { String urlS = u . toExternalForm ( ) ; urlS = urlS . replaceAll ( " " , "%20" ) ; final URI uri = new URI ( urlS ) ; return new URL ( uri . toASCIIString ( ) ) ; } catch ( Exception e ) { return u ; } }
--------------------------------------------------
public static void appendNormalisedWhitespace ( StringBuilder accum , String string , boolean stripLeading ) { boolean lastWasWhite = false ; boolean reachedNonWhite = false ; int len = string . length ( ) ; int c ; for ( int i = 0 ; i < len ; i += Character . charCount ( c ) ) { c = string . codePointAt ( i ) ; if ( isActuallyWhitespace ( c ) ) { if ( ( stripLeading && ! reachedNonWhite ) || lastWasWhite ) continue ; accum . append ( ' ' ) ; lastWasWhite = true ; } else if ( ! isInvisibleChar ( c ) ) { accum . appendCodePoint ( c ) ; lastWasWhite = false ; reachedNonWhite = true ; } } }
--------------------------------------------------
public Element appendElement ( String tagName ) { Element child = new Element ( Tag . valueOf ( tagName , NodeUtils . parser ( this ) . settings ( ) ) , baseUri ( ) ) ; appendChild ( child ) ; return child ; }
--------------------------------------------------
public static String escape ( String string , Document . OutputSettings out ) { if ( string == null ) return "" ; StringBuilder accum = StringUtil . borrowBuilder ( ) ; try { escape ( accum , string , out , false , false , false ) ; } catch ( IOException e ) { throw new SerializationException ( e ) ; } return StringUtil . releaseBuilder ( accum ) ; }
--------------------------------------------------
static void escape ( Appendable accum , String string , Document . OutputSettings out , boolean inAttribute , boolean normaliseWhite , boolean stripLeadingWhite ) throws IOException { boolean lastWasWhite = false ; boolean reachedNonWhite = false ; final EscapeMode escapeMode = out . escapeMode ( ) ; final CharsetEncoder encoder = out . encoder ( ) ; final CoreCharset coreCharset = out . coreCharset ; final int length = string . length ( ) ; int codePoint ; for ( int offset = 0 ; offset < length ; offset += Character . charCount ( codePoint ) ) { codePoint = string . codePointAt ( offset ) ; if ( normaliseWhite ) { if ( StringUtil . isWhitespace ( codePoint ) ) { if ( ( stripLeadingWhite && ! reachedNonWhite ) || lastWasWhite ) continue ; accum . append ( ' ' ) ; lastWasWhite = true ; continue ; } else { lastWasWhite = false ; reachedNonWhite = true ; } } if ( codePoint < Character . MIN_SUPPLEMENTARY_CODE_POINT ) { final char c = ( char ) codePoint ; switch ( c ) { case '&' : accum . append ( "&amp;" ) ; break ; case a0 : if ( escapeMode != EscapeMode . xhtml ) accum . append ( "&nbsp;" ) ; else accum . append ( "&#xa0;" ) ; break ; case '<' : if ( ! inAttribute || escapeMode == EscapeMode . xhtml ) accum . append ( "&lt;" ) ; else accum . append ( c ) ; break ; case '>' : if ( ! inAttribute ) accum . append ( "&gt;" ) ; else accum . append ( c ) ; break ; case '"' : if ( inAttribute ) accum . append ( "&quot;" ) ; else accum . append ( c ) ; break ; default : if ( canEncode ( coreCharset , c , encoder ) ) accum . append ( c ) ; else appendEncoded ( accum , escapeMode , codePoint ) ; } } else { final String c = new String ( Character . toChars ( codePoint ) ) ; if ( encoder . canEncode ( c ) ) accum . append ( c ) ; else appendEncoded ( accum , escapeMode , codePoint ) ; } } }
--------------------------------------------------
public String cssSelector ( ) { if ( id ( ) . length ( ) > 0 ) return "#" + id ( ) ; String tagName = tagName ( ) . replace ( ':' , '|' ) ; StringBuilder selector = new StringBuilder ( tagName ) ; String classes = StringUtil . join ( classNames ( ) , "." ) ; if ( classes . length ( ) > 0 ) selector . append ( '.' ) . append ( classes ) ; if ( parent ( ) == null || parent ( ) instanceof Document ) return selector . toString ( ) ; selector . insert ( 0 , " > " ) ; if ( parent ( ) . select ( selector . toString ( ) ) . size ( ) > 1 ) selector . append ( String . format ( ":nth-child(%d)" , elementSiblingIndex ( ) + 1 ) ) ; return parent ( ) . cssSelector ( ) + selector . toString ( ) ; }
--------------------------------------------------
