private Map . Entry < String , List < String >> scanHeaders ( String name ) { String lc = lowerCase ( name ) ; for ( Map . Entry < String , List < String >> entry : headers . entrySet ( ) ) { if ( lowerCase ( entry . getKey ( ) ) . equals ( lc ) ) return entry ; } return null ; }
--------------------------------------------------
public boolean matches ( Element root , Element element ) { return ! value . equalsIgnoreCase ( element . attr ( key ) ) ; }
--------------------------------------------------
public Node clearAttributes ( ) { Iterator < Attribute > it = attributes ( ) . iterator ( ) ; while ( it . hasNext ( ) ) { it . next ( ) ; it . remove ( ) ; } return this ; }
--------------------------------------------------
public OutputSettings clone ( ) { OutputSettings clone ; try { clone = ( OutputSettings ) super . clone ( ) ; } catch ( CloneNotSupportedException e ) { throw new RuntimeException ( e ) ; } clone . charset ( charset . name ( ) ) ; clone . escapeMode = Entities . EscapeMode . valueOf ( escapeMode . name ( ) ) ; return clone ; }
--------------------------------------------------
public boolean equals ( Object o ) { return this == o ; }
--------------------------------------------------
private List < String > getHeadersCaseInsensitive ( String name ) { Validate . notNull ( name ) ; for ( Map . Entry < String , List < String >> entry : headers . entrySet ( ) ) { if ( name . equalsIgnoreCase ( entry . getKey ( ) ) ) return entry . getValue ( ) ; } return Collections . emptyList ( ) ; }
--------------------------------------------------
public Connection timeout ( int millis ) { req . timeout ( millis ) ; return this ; }
--------------------------------------------------
public static String normaliseWhitespace ( String string ) { StringBuilder sb = StringUtil . borrowBuilder ( ) ; appendNormalisedWhitespace ( sb , string , false ) ; return StringUtil . releaseBuilder ( sb ) ; }
--------------------------------------------------
private CleaningVisitor ( Element root , Element destination ) { this . root = root ; this . destination = destination ; }
--------------------------------------------------
public ConstrainableInputStream timeout ( long startTimeNanos , long timeoutMillis ) { this . startTime = startTimeNanos ; this . timeout = timeoutMillis * 1000000 ; return this ; }
--------------------------------------------------
