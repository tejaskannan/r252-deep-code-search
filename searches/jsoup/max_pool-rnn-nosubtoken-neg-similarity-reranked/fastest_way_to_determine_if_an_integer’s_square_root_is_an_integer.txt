public Element append ( String html ) { Validate . notNull ( html ) ; List < Node > nodes = NodeUtils . parser ( this ) . parseFragmentInput ( html , this , baseUri ( ) ) ; addChildren ( nodes . toArray ( new Node [ 0 ] ) ) ; return this ; }
--------------------------------------------------
boolean matchesIgnoreCase ( String seq ) { bufferUp ( ) ; int scanLength = seq . length ( ) ; if ( scanLength > bufLength - bufPos ) return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ; if ( upScan != upTarget ) return false ; } return true ; }
--------------------------------------------------
static boolean rangeEquals ( final char [ ] charBuf , final int start , int count , final String cached ) { if ( count == cached . length ( ) ) { int i = start ; int j = 0 ; while ( count -- != 0 ) { if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) return false ; } return true ; } return false ; }
--------------------------------------------------
public boolean hasSameValue ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; return this . outerHtml ( ) . equals ( ( ( Node ) o ) . outerHtml ( ) ) ; }
--------------------------------------------------
public Connection headers ( Map < String , String > headers ) { Validate . notNull ( headers , "header map must not be null" ) ; for ( Map . Entry < String , String > entry : headers . entrySet ( ) ) { req . header ( entry . getKey ( ) , entry . getValue ( ) ) ; } return this ; }
--------------------------------------------------
public Node attr ( String key , String value ) { if ( ! hasAttributes ( ) && key . equals ( nodeName ( ) ) ) { this . value = value ; } else { ensureAttributes ( ) ; super . attr ( key , value ) ; } return this ; }
--------------------------------------------------
public Iterator < Attribute > iterator ( ) { return new Iterator < Attribute > ( ) { int i = 0 ; @ Override public boolean hasNext ( ) { return i < size ; } @ Override public Attribute next ( ) { final Attribute attr = new Attribute ( keys [ i ] , vals [ i ] , Attributes . this ) ; i ++ ; return attr ; } @ Override public void remove ( ) { Attributes . this . remove ( -- i ) ; } } ; }
--------------------------------------------------
void error ( HtmlTreeBuilderState state ) { if ( parser . getErrors ( ) . canAddError ( ) ) parser . getErrors ( ) . add ( new ParseError ( reader . pos ( ) , "unexpected token [%s] when in state [%s]" , currentToken . tokenType ( ) , state ) ) ; }
--------------------------------------------------
public XmlDeclaration ( String name , boolean isProcessingInstruction ) { Validate . notNull ( name ) ; value = name ; this . isProcessingInstruction = isProcessingInstruction ; }
--------------------------------------------------
public String attr ( String key ) { Validate . notNull ( key ) ; if ( ! hasAttributes ( ) ) { return key . equals ( nodeName ( ) ) ? ( String ) value : EmptyString ; } return super . attr ( key ) ; }
--------------------------------------------------
