public boolean hasSameValue ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; return this . outerHtml ( ) . equals ( ( ( Node ) o ) . outerHtml ( ) ) ; }
--------------------------------------------------
public Element append ( String html ) { Validate . notNull ( html ) ; List < Node > nodes = NodeUtils . parser ( this ) . parseFragmentInput ( html , this , baseUri ( ) ) ; addChildren ( nodes . toArray ( new Node [ 0 ] ) ) ; return this ; }
--------------------------------------------------
public boolean equals ( Object o ) { if ( this == o ) return true ; if ( ! ( o instanceof Tag ) ) return false ; Tag tag = ( Tag ) o ; if ( ! tagName . equals ( tag . tagName ) ) return false ; if ( canContainInline != tag . canContainInline ) return false ; if ( empty != tag . empty ) return false ; if ( formatAsBlock != tag . formatAsBlock ) return false ; if ( isBlock != tag . isBlock ) return false ; if ( preserveWhitespace != tag . preserveWhitespace ) return false ; if ( selfClosing != tag . selfClosing ) return false ; if ( formList != tag . formList ) return false ; return formSubmit == tag . formSubmit ; }
--------------------------------------------------
public Connection headers ( Map < String , String > headers ) { Validate . notNull ( headers , "header map must not be null" ) ; for ( Map . Entry < String , String > entry : headers . entrySet ( ) ) { req . header ( entry . getKey ( ) , entry . getValue ( ) ) ; } return this ; }
--------------------------------------------------
static boolean rangeEquals ( final char [ ] charBuf , final int start , int count , final String cached ) { if ( count == cached . length ( ) ) { int i = start ; int j = 0 ; while ( count -- != 0 ) { if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) return false ; } return true ; } return false ; }
--------------------------------------------------
boolean matchesIgnoreCase ( String seq ) { bufferUp ( ) ; int scanLength = seq . length ( ) ; if ( scanLength > bufLength - bufPos ) return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ; if ( upScan != upTarget ) return false ; } return true ; }
--------------------------------------------------
public Node attr ( String key , String value ) { if ( ! hasAttributes ( ) && key . equals ( nodeName ( ) ) ) { this . value = value ; } else { ensureAttributes ( ) ; super . attr ( key , value ) ; } return this ; }
--------------------------------------------------
public boolean hasCookie ( String name ) { Validate . notEmpty ( name , "cookie name must not be empty" ) ; return cookies . containsKey ( name ) ; }
--------------------------------------------------
public Iterator < Attribute > iterator ( ) { return new Iterator < Attribute > ( ) { int i = 0 ; @ Override public boolean hasNext ( ) { return i < size ; } @ Override public Attribute next ( ) { final Attribute attr = new Attribute ( keys [ i ] , vals [ i ] , Attributes . this ) ; i ++ ; return attr ; } @ Override public void remove ( ) { Attributes . this . remove ( -- i ) ; } } ; }
--------------------------------------------------
public Element before ( Node node ) { return ( Element ) super . before ( node ) ; }
--------------------------------------------------
