public Connection postDataCharset ( String charset ) { req . postDataCharset ( charset ) ; return this ; }
--------------------------------------------------
public Document fromJsoup ( org . jsoup . nodes . Document in ) { Validate . notNull ( in ) ; DocumentBuilder builder ; try { factory . setNamespaceAware ( true ) ; builder = factory . newDocumentBuilder ( ) ; Document out = builder . newDocument ( ) ; convert ( in , out ) ; return out ; } catch ( ParserConfigurationException e ) { throw new IllegalStateException ( e ) ; } }
--------------------------------------------------
public Connection . Request postDataCharset ( String charset ) { Validate . notNull ( charset , "charset must not be null" ) ; if ( ! Charset . isSupported ( charset ) ) throw new IllegalCharsetNameException ( charset ) ; this . postDataCharset = charset ; return this ; }
--------------------------------------------------
public static Tag valueOf ( String tagName , ParseSettings settings ) { Validate . notNull ( tagName ) ; Tag tag = tags . get ( tagName ) ; if ( tag == null ) { tagName = settings . normalizeTag ( tagName ) ; Validate . notEmpty ( tagName ) ; tag = tags . get ( tagName ) ; if ( tag == null ) { tag = new Tag ( tagName ) ; tag . isBlock = false ; } } return tag ; }
--------------------------------------------------
static Document . OutputSettings outputSettings ( Node node ) { Document owner = node . ownerDocument ( ) ; return owner != null ? owner . outputSettings ( ) : ( new Document ( "" ) ) . outputSettings ( ) ; }
--------------------------------------------------
public String data ( ) { StringBuilder sb = StringUtil . borrowBuilder ( ) ; for ( Node childNode : childNodes ) { if ( childNode instanceof DataNode ) { DataNode data = ( DataNode ) childNode ; sb . append ( data . getWholeData ( ) ) ; } else if ( childNode instanceof Comment ) { Comment comment = ( Comment ) childNode ; sb . append ( comment . getData ( ) ) ; } else if ( childNode instanceof Element ) { Element element = ( Element ) childNode ; String elementData = element . data ( ) ; sb . append ( elementData ) ; } else if ( childNode instanceof CDataNode ) { CDataNode cDataNode = ( CDataNode ) childNode ; sb . append ( cDataNode . getWholeText ( ) ) ; } } return StringUtil . releaseBuilder ( sb ) ; }
--------------------------------------------------
private static void accumulateParents ( Element el , Elements parents ) { Element parent = el . parent ( ) ; if ( parent != null && ! parent . tagName ( ) . equals ( "#root" ) ) { parents . add ( parent ) ; accumulateParents ( parent , parents ) ; } }
--------------------------------------------------
protected boolean processStartTag ( String name ) { if ( currentToken == start ) { return process ( new Token . StartTag ( ) . name ( name ) ) ; } return process ( start . reset ( ) . name ( name ) ) ; }
--------------------------------------------------
private QueryParser ( String query ) { this . query = query ; this . tq = new TokenQueue ( query ) ; }
--------------------------------------------------
private void normaliseTextNodes ( Element element ) { List < Node > toMove = new ArrayList < > ( ) ; for ( Node node : element . childNodes ) { if ( node instanceof TextNode ) { TextNode tn = ( TextNode ) node ; if ( ! tn . isBlank ( ) ) toMove . add ( tn ) ; } } for ( int i = toMove . size ( ) - 1 ; i >= 0 ; i -- ) { Node node = toMove . get ( i ) ; element . removeChild ( node ) ; body ( ) . prependChild ( new TextNode ( " " ) ) ; body ( ) . prependChild ( node ) ; } }
--------------------------------------------------
