public static Tag valueOf ( String tagName , ParseSettings settings ) { Validate . notNull ( tagName ) ; Tag tag = tags . get ( tagName ) ; if ( tag == null ) { tagName = settings . normalizeTag ( tagName ) ; Validate . notEmpty ( tagName ) ; tag = tags . get ( tagName ) ; if ( tag == null ) { tag = new Tag ( tagName ) ; tag . isBlock = false ; } } return tag ; }
--------------------------------------------------
public String data ( ) { StringBuilder sb = StringUtil . borrowBuilder ( ) ; for ( Node childNode : childNodes ) { if ( childNode instanceof DataNode ) { DataNode data = ( DataNode ) childNode ; sb . append ( data . getWholeData ( ) ) ; } else if ( childNode instanceof Comment ) { Comment comment = ( Comment ) childNode ; sb . append ( comment . getData ( ) ) ; } else if ( childNode instanceof Element ) { Element element = ( Element ) childNode ; String elementData = element . data ( ) ; sb . append ( elementData ) ; } else if ( childNode instanceof CDataNode ) { CDataNode cDataNode = ( CDataNode ) childNode ; sb . append ( cDataNode . getWholeText ( ) ) ; } } return StringUtil . releaseBuilder ( sb ) ; }
--------------------------------------------------
private static void accumulateParents ( Element el , Elements parents ) { Element parent = el . parent ( ) ; if ( parent != null && ! parent . tagName ( ) . equals ( "#root" ) ) { parents . add ( parent ) ; accumulateParents ( parent , parents ) ; } }
--------------------------------------------------
private QueryParser ( String query ) { this . query = query ; this . tq = new TokenQueue ( query ) ; }
--------------------------------------------------
private void normaliseTextNodes ( Element element ) { List < Node > toMove = new ArrayList < > ( ) ; for ( Node node : element . childNodes ) { if ( node instanceof TextNode ) { TextNode tn = ( TextNode ) node ; if ( ! tn . isBlank ( ) ) toMove . add ( tn ) ; } } for ( int i = toMove . size ( ) - 1 ; i >= 0 ; i -- ) { Node node = toMove . get ( i ) ; element . removeChild ( node ) ; body ( ) . prependChild ( new TextNode ( " " ) ) ; body ( ) . prependChild ( node ) ; } }
--------------------------------------------------
public AttributeKeyPair ( String key , String value ) { Validate . notEmpty ( key ) ; Validate . notEmpty ( value ) ; this . key = normalize ( key ) ; if ( value . startsWith ( """ ) && value . endsWith ( """ ) || value . startsWith ( "'" ) && value . endsWith ( "'" ) ) { value = value . substring ( 1 , value . length ( ) - 1 ) ; } this . value = normalize ( value ) ; }
--------------------------------------------------
Element getFromStack ( String elName ) { for ( int pos = stack . size ( ) - 1 ; pos >= 0 ; pos -- ) { Element next = stack . get ( pos ) ; if ( next . normalName ( ) . equals ( elName ) ) { return next ; } } return null ; }
--------------------------------------------------
public String getWholeDeclaration ( ) { StringBuilder sb = StringUtil . borrowBuilder ( ) ; try { getWholeDeclaration ( sb , new Document . OutputSettings ( ) ) ; } catch ( IOException e ) { throw new SerializationException ( e ) ; } return StringUtil . releaseBuilder ( sb ) . trim ( ) ; }
--------------------------------------------------
public Connection data ( String key , String value ) { req . data ( KeyVal . create ( key , value ) ) ; return this ; }
--------------------------------------------------
public Elements not ( String query ) { Elements out = Selector . select ( query , this ) ; return Selector . filterOut ( this , out ) ; }
--------------------------------------------------
