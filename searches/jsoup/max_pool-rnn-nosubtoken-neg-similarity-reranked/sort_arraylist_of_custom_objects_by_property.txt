public boolean equals ( Object o ) { return this == o ; }
--------------------------------------------------
private Map . Entry < String , List < String >> scanHeaders ( String name ) { String lc = lowerCase ( name ) ; for ( Map . Entry < String , List < String >> entry : headers . entrySet ( ) ) { if ( lowerCase ( entry . getKey ( ) ) . equals ( lc ) ) return entry ; } return null ; }
--------------------------------------------------
public Node clearAttributes ( ) { Iterator < Attribute > it = attributes ( ) . iterator ( ) ; while ( it . hasNext ( ) ) { it . next ( ) ; it . remove ( ) ; } return this ; }
--------------------------------------------------
public Connection timeout ( int millis ) { req . timeout ( millis ) ; return this ; }
--------------------------------------------------
public ConstrainableInputStream timeout ( long startTimeNanos , long timeoutMillis ) { this . startTime = startTimeNanos ; this . timeout = timeoutMillis * 1000000 ; return this ; }
--------------------------------------------------
public static String normaliseWhitespace ( String string ) { StringBuilder sb = StringUtil . borrowBuilder ( ) ; appendNormalisedWhitespace ( sb , string , false ) ; return StringUtil . releaseBuilder ( sb ) ; }
--------------------------------------------------
public UnsupportedMimeTypeException ( String message , String mimeType , String url ) { super ( message ) ; this . mimeType = mimeType ; this . url = url ; }
--------------------------------------------------
public Request timeout ( int millis ) { Validate . isTrue ( millis >= 0 , "timeout milliseconds must be 0 (infinite) or greater" ) ; timeoutMilliseconds = millis ; return this ; }
--------------------------------------------------
public Connection proxy ( Proxy proxy ) { req . proxy ( proxy ) ; return this ; }
--------------------------------------------------
public OutputSettings clone ( ) { OutputSettings clone ; try { clone = ( OutputSettings ) super . clone ( ) ; } catch ( CloneNotSupportedException e ) { throw new RuntimeException ( e ) ; } clone . charset ( charset . name ( ) ) ; clone . escapeMode = Entities . EscapeMode . valueOf ( escapeMode . name ( ) ) ; return clone ; }
--------------------------------------------------
