private Description checkToString ( ExpressionTree tree , VisitorState state ) { Symbol sym = ASTHelpers . getSymbol ( tree ) ; if ( ! ( sym instanceof VarSymbol || sym instanceof MethodSymbol ) ) { return NO_MATCH ; } Type type = ASTHelpers . getType ( tree ) ; if ( type instanceof MethodType ) { type = type . getReturnType ( ) ; } Tree parent = state . getPath ( ) . getParentPath ( ) . getLeaf ( ) ; ToStringKind toStringKind = isToString ( parent , tree , state ) ; if ( toStringKind == ToStringKind . NONE ) { return NO_MATCH ; } if ( ! typePredicate ( ) . apply ( type , state ) ) { return NO_MATCH ; } Optional < Fix > fix ; switch ( toStringKind ) { case IMPLICIT : fix = implicitToStringFix ( tree , state ) ; break ; case EXPLICIT : fix = toStringFix ( parent , tree , state ) ; break ; default : throw new AssertionError ( toStringKind ) ; } return maybeFix ( tree , state , type , fix ) ; }
--------------------------------------------------
private boolean isNumeric ( VisitorState state , Type type ) { Type trueType = unboxedTypeOrType ( state , type ) ; return trueType . isNumeric ( ) ; }
--------------------------------------------------
protected void checkRegistry ( ) { loadRegistriesFromBackwardConfig ( ) ; convertRegistryIdsToRegistries ( ) ; for ( RegistryConfig registryConfig : registries ) { if ( ! registryConfig . isValid ( ) ) { throw new IllegalStateException ( 'no registry config found or it's not a valid config! ' '+' 'the registry config is: ' + registryConfig ) ; } } useRegistryForConfigIfNecessary ( ) ; }
--------------------------------------------------
boolean isAssignableTo ( Parameter target , VisitorState state ) { if ( state . getTypes ( ) . isSameType ( type ( ) , Type . noType ) || state . getTypes ( ) . isSameType ( target . type ( ) , Type . noType ) ) { return false ; } try { return state . getTypes ( ) . isAssignable ( type ( ) , target . type ( ) ) ; } catch ( CompletionFailure e ) { Check . instance ( state . context ) . completionError ( ( DiagnosticPosition ) state . getPath ( ) . getLeaf ( ) , e ) ; return false ; } }
--------------------------------------------------
private ClassSymbol isEnclosedIn ( ClassSymbol startingClass , Symbol member , Types types ) { for ( ClassSymbol scope = startingClass . owner . enclClass ( ) ; scope != null ; scope = scope . owner . enclClass ( ) ) { if ( member . isMemberOf ( scope . type . tsym , types ) ) { return scope ; } } return null ; }
--------------------------------------------------
( Tree parent , ExpressionTree tree , VisitorState state ) { if ( isStringConcat ( parent , state ) ) { return ToStringKind . IMPLICIT ; } if ( parent instanceof ExpressionTree ) { ExpressionTree parentExpression = ( ExpressionTree ) parent ; if ( PRINT_STRING . matches ( parentExpression , state ) ) { return ToStringKind . IMPLICIT ; } if ( VALUE_OF . matches ( parentExpression , state ) ) { return ToStringKind . EXPLICIT ; } } return ToStringKind . NONE ; }
--------------------------------------------------
public static boolean isJavaIdentifier ( String s ) { if ( isEmpty ( s ) || ! Character . isJavaIdentifierStart ( s . charAt ( 0 ) ) ) { return false ; } for ( int i = 1 ; i < s . length ( ) ; i ++ ) { if ( ! Character . isJavaIdentifierPart ( s . charAt ( i ) ) ) { return false ; } } return true ; }
--------------------------------------------------
private Description checkAnnotations ( Tree tree , int treePos , List < ? extends AnnotationTree > annotations , Comment danglingJavadoc , int firstModifierPos , int lastModifierPos , VisitorState state ) { SuggestedFix . Builder builder = SuggestedFix . builder ( ) ; List < AnnotationTree > moveBefore = new ArrayList < > ( ) ; List < AnnotationTree > moveAfter = new ArrayList < > ( ) ; boolean annotationProblem = false ; for ( AnnotationTree annotation : annotations ) { int annotationPos = ( ( JCTree ) annotation ) . getStartPosition ( ) ; if ( annotationPos <= firstModifierPos ) { continue ; } AnnotationType annotationType = ASTHelpers . getAnnotationType ( annotation , getSymbol ( tree ) , state ) ; if ( annotationPos >= lastModifierPos ) { if ( tree instanceof ClassTree || annotationType == AnnotationType . DECLARATION ) { annotationProblem = true ; moveBefore . add ( annotation ) ; } } else { annotationProblem = true ; if ( tree instanceof ClassTree || annotationType == AnnotationType . DECLARATION || annotationType == null ) { moveBefore . add ( annotation ) ; } else { moveAfter . add ( annotation ) ; } } } if ( annotationProblem ) { for ( AnnotationTree annotation : moveBefore ) { builder . delete ( annotation ) ; } for ( AnnotationTree annotation : moveAfter ) { builder . delete ( annotation ) ; } String javadoc = danglingJavadoc == null ? '' : removeJavadoc ( state , treePos , danglingJavadoc , builder ) ; builder . replace ( firstModifierPos , firstModifierPos , String . format ( '%s%s ' , javadoc , joinSource ( state , moveBefore ) ) ) . replace ( lastModifierPos , lastModifierPos , String . format ( '%s ' , joinSource ( state , moveAfter ) ) ) ; ImmutableList < String > names = annotations . stream ( ) . map ( ASTHelpers :: getSymbol ) . filter ( Objects :: nonNull ) . map ( Symbol :: getSimpleName ) . map ( a -> '@' + a ) . collect ( toImmutableList ( ) ) ; String flattened = names . stream ( ) . collect ( joining ( ', ' ) ) ; String isAre = names . size ( ) > 1 ? 'are not type annotations' : 'is not a type annotation' ; String message = String . format ( '%s %s, so should appear before any modifiers and after javadocs.' , flattened , isAre ) ; return buildDescription ( tree ) . setMessage ( message ) . addFix ( builder . build ( ) ) . build ( ) ; } return NO_MATCH ; }
--------------------------------------------------
private Description checkSubtype ( ClassTree tree , VisitorState state ) { ClassSymbol sym = ASTHelpers . getSymbol ( tree ) ; if ( sym == null ) { return NO_MATCH ; } Type superType = immutableSupertype ( sym , state ) ; if ( superType == null ) { return NO_MATCH ; } String message = String . format ( 'class extends @immutable type %s, but is not annotated as immutable' , superType ) ; Fix fix = SuggestedFix . builder ( ) . prefixWith ( tree , '@immutable ' ) . addImport ( Immutable . class . getName ( ) ) . build ( ) ; return buildDescription ( tree ) . setMessage ( message ) . addFix ( fix ) . build ( ) ; }
--------------------------------------------------
public String toString ( ) { if ( importStrings . isEmpty ( ) ) { return '' ; } StringBuilder result = new StringBuilder ( ) ; if ( ! hasExistingImports ) { result . append ( '' ) ; } List < ImportOrganizer . Import > imports = importStrings . stream ( ) . map ( ImportOrganizer . Import :: importOf ) . collect ( Collectors . toList ( ) ) ; ImportOrganizer . OrganizedImports organizedImports = importOrganizer . organizeImports ( imports ) ; int expectedImportCount = imports . size ( ) ; int importCount = organizedImports . getImportCount ( ) ; if ( importCount != expectedImportCount ) { throw new IllegalStateException ( String . format ( 'expected %d import(s) in the organized imports but it contained %d' , expectedImportCount , importCount ) ) ; } result . append ( organizedImports . asImportBlock ( ) ) ; String replacementString = result . toString ( ) ; if ( ! hasExistingImports ) { return replacementString ; } else { return CharMatcher . whitespace ( ) . trimTrailingFrom ( replacementString ) ; } }
--------------------------------------------------
