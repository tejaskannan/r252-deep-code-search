private static String getFromFile ( String file ) { file = file . substring ( 0 , file . length ( ) - 4 ) ; int i = file . lastIndexOf ( '/' ) ; if ( i >= 0 ) { file = file . substring ( i + 1 ) ; } i = file . indexOf ( '-' ) ; if ( i >= 0 ) { file = file . substring ( i + 1 ) ; } while ( file . length ( ) > 0 && ! Character . isDigit ( file . charAt ( 0 ) ) ) { i = file . indexOf ( '-' ) ; if ( i >= 0 ) { file = file . substring ( i + 1 ) ; } else { break ; } } return file ; }
--------------------------------------------------
public static Template < ? > createTemplate ( Context context , MethodTree decl ) { MethodSymbol declSym = ASTHelpers . getSymbol ( decl ) ; ImmutableClassToInstanceMap < Annotation > annotations = UTemplater . annotationMap ( declSym ) ; ImmutableMap < String , VarSymbol > freeExpressionVars = freeExpressionVariables ( decl ) ; Context subContext = new SubContext ( context ) ; final UTemplater templater = new UTemplater ( freeExpressionVars , subContext ) ; ImmutableMap < String , UType > expressionVarTypes = ImmutableMap . copyOf ( Maps . transformValues ( freeExpressionVars , ( VarSymbol sym ) -> templater . template ( sym . type ) ) ) ; UType genericType = templater . template ( declSym . type ) ; List < UTypeVar > typeParameters ; UMethodType methodType ; if ( genericType instanceof UForAll ) { UForAll forAllType = ( UForAll ) genericType ; typeParameters = forAllType . getTypeVars ( ) ; methodType = ( UMethodType ) forAllType . getQuantifiedType ( ) ; } else if ( genericType instanceof UMethodType ) { typeParameters = ImmutableList . of ( ) ; methodType = ( UMethodType ) genericType ; } else { throw new IllegalArgumentException ( 'expected generictype to be either a forall or a umethodtype, but was ' + genericType ) ; } List < ? extends StatementTree > bodyStatements = decl . getBody ( ) . getStatements ( ) ; if ( bodyStatements . size ( ) == 1 && Iterables . getOnlyElement ( bodyStatements ) . getKind ( ) == Kind . RETURN && context . get ( REQUIRE_BLOCK_KEY ) == null ) { ExpressionTree expression = ( ( ReturnTree ) Iterables . getOnlyElement ( bodyStatements ) ) . getExpression ( ) ; return ExpressionTemplate . create ( annotations , typeParameters , expressionVarTypes , templater . template ( expression ) , methodType . getReturnType ( ) ) ; } else { List < UStatement > templateStatements = new ArrayList < > ( ) ; for ( StatementTree statement : bodyStatements ) { templateStatements . add ( templater . template ( statement ) ) ; } return BlockTemplate . create ( annotations , typeParameters , expressionVarTypes , templateStatements ) ; } }
--------------------------------------------------
public static String getFileNameFromUri ( URI uri ) { if ( ! uri . getScheme ( ) . equals ( 'jar' ) ) { return uri . getPath ( ) ; } try { String jarEntryFileName = ( ( JarURLConnection ) uri . toURL ( ) . openConnection ( ) ) . getEntryName ( ) ; jarEntryFileName = BACKSLASH_MATCHER . replaceFrom ( jarEntryFileName , '/' ) ; if ( ! jarEntryFileName . startsWith ( '/' ) ) { jarEntryFileName = '/' + jarEntryFileName ; } return jarEntryFileName ; } catch ( IOException e ) { return null ; } }
--------------------------------------------------
public JavaFileObject forResource ( String fileName ) { Preconditions . checkState ( clazz . isPresent ( ) , 'clazz must be set if you want to add a source from a resource file' ) ; return forResource ( clazz . get ( ) , fileName ) ; }
--------------------------------------------------
static Optional < GuardedByExpression > from ( JCTree . JCExpression guardedMemberExpression , GuardedByExpression guard , VisitorState state ) { if ( isGuardReferenceAbsolute ( guard ) ) { return Optional . of ( guard ) ; } Optional < GuardedByExpression > guardedMember = GuardedByBinder . bindExpression ( guardedMemberExpression , state ) ; if ( ! guardedMember . isPresent ( ) ) { return Optional . empty ( ) ; } GuardedByExpression memberBase = ( ( GuardedByExpression . Select ) guardedMember . get ( ) ) . base ( ) ; return Optional . of ( helper ( guard , memberBase ) ) ; }
--------------------------------------------------
public String getDescription ( ) { return 'the parameters of this method are inconsistent with other overloaded versions.' '+' ' a consistent order would be: ' + getSuggestedSignature ( ) ; }
--------------------------------------------------
public ZookeeperClient connect ( URL url ) { ZookeeperClient zookeeperClient ; List < String > addressList = getURLBackupAddress ( url ) ; if ( ( zookeeperClient = fetchAndUpdateZookeeperClientCache ( addressList ) ) != null && zookeeperClient . isConnected ( ) ) { logger . info ( 'find valid zookeeper client from the cache for address: ' + url ) ; return zookeeperClient ; } synchronized ( zookeeperClientMap ) { if ( ( zookeeperClient = fetchAndUpdateZookeeperClientCache ( addressList ) ) != null && zookeeperClient . isConnected ( ) ) { logger . info ( 'find valid zookeeper client from the cache for address: ' + url ) ; return zookeeperClient ; } zookeeperClient = createZookeeperClient ( toClientURL ( url ) ) ; logger . info ( 'no valid zookeeper client found from cache, therefore create a new client for url. ' + url ) ; writeToClientMap ( addressList , zookeeperClient ) ; } return zookeeperClient ; }
--------------------------------------------------
public static AccessPath fromFieldAccess ( FieldAccessNode fieldAccess ) { ImmutableList . Builder < String > pathBuilder = ImmutableList . builder ( ) ; Tree tree = fieldAccess . getTree ( ) ; boolean isFieldAccess ; while ( ( isFieldAccess = TreeUtils . isFieldAccess ( tree ) ) || isAutoValueAccessor ( tree ) ) { if ( isFieldAccess ) { pathBuilder . add ( TreeUtils . getFieldName ( tree ) ) ; } else { tree = ( ( MethodInvocationTree ) tree ) . getMethodSelect ( ) ; pathBuilder . add ( TreeUtils . getMethodName ( tree ) + '()' ) ; } if ( tree . getKind ( ) == Kind . IDENTIFIER ) { return AccessPath . create ( null , pathBuilder . build ( ) ) ; } tree = ( ( MemberSelectTree ) tree ) . getExpression ( ) ; } if ( tree . getKind ( ) == Kind . IDENTIFIER && ( ( IdentifierTree ) tree ) . getName ( ) . contentEquals ( 'this' ) ) { return AccessPath . create ( null , pathBuilder . build ( ) ) ; } if ( tree . getKind ( ) == Kind . IDENTIFIER ) { return AccessPath . create ( TreeUtils . elementFromTree ( tree ) , pathBuilder . build ( ) ) ; } return null ; }
--------------------------------------------------
protected void doParse ( Element element , ParserContext parserContext , BeanDefinitionBuilder builder ) { String packageToScan = element . getAttribute ( 'package' ) ; String [ ] packagesToScan = trimArrayElements ( commaDelimitedListToStringArray ( packageToScan ) ) ; builder . addConstructorArgValue ( packagesToScan ) ; builder . setRole ( BeanDefinition . ROLE_INFRASTRUCTURE ) ; registerReferenceAnnotationBeanPostProcessor ( parserContext . getRegistry ( ) ) ; }
--------------------------------------------------
public static ApiDiff fromProto ( Diff diff ) { ImmutableSet . Builder < String > unsupportedClasses = ImmutableSet . builder ( ) ; ImmutableSetMultimap . Builder < String , ClassMemberKey > unsupportedMembersByClass = ImmutableSetMultimap . builder ( ) ; for ( ApiDiffProto . ClassDiff c : diff . getClassDiffList ( ) ) { switch ( c . getDiffCase ( ) ) { case EVERYTHING_DIFF : unsupportedClasses . add ( c . getEverythingDiff ( ) . getClassName ( ) ) ; break ; case MEMBER_DIFF : ApiDiffProto . MemberDiff memberDiff = c . getMemberDiff ( ) ; for ( ApiDiffProto . ClassMember member : memberDiff . getMemberList ( ) ) { unsupportedMembersByClass . put ( memberDiff . getClassName ( ) , ClassMemberKey . create ( member . getIdentifier ( ) , member . getMemberDescriptor ( ) ) ) ; } break ; default : throw new AssertionError ( c . getDiffCase ( ) ) ; } } return new AutoValue_ApiDiff ( unsupportedClasses . build ( ) , unsupportedMembersByClass . build ( ) ) ; }
--------------------------------------------------
