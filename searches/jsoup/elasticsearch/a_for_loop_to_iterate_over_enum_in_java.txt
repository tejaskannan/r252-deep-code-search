public static < T extends Tree > Matcher < T > inLoop ( ) { return new Matcher < T > ( ) { @ Override public boolean matches ( Tree tree , VisitorState state ) { TreePath path = state . getPath ( ) . getParentPath ( ) ; Tree node = path . getLeaf ( ) ; while ( path != null ) { switch ( node . getKind ( ) ) { case METHOD : case CLASS : return false ; case WHILE_LOOP : case FOR_LOOP : case ENHANCED_FOR_LOOP : case DO_WHILE_LOOP : return true ; default : path = path . getParentPath ( ) ; node = path . getLeaf ( ) ; break ; } } return false ; } } ; }
--------------------------------------------------
public static Matcher < EnhancedForLoopTree > enhancedForLoop ( final Matcher < VariableTree > variableMatcher , final Matcher < ExpressionTree > expressionMatcher , final Matcher < StatementTree > statementMatcher ) { return new Matcher < EnhancedForLoopTree > ( ) { @ Override public boolean matches ( EnhancedForLoopTree t , VisitorState state ) { return variableMatcher . matches ( t . getVariable ( ) , state ) && expressionMatcher . matches ( t . getExpression ( ) , state ) && statementMatcher . matches ( t . getStatement ( ) , state ) ; } } ; }
--------------------------------------------------
static boolean enclosingLoop ( TreePath path , ExpressionTree collection ) { for ( Tree node : path ) { switch ( node . getKind ( ) ) { case METHOD : case CLASS : case LAMBDA_EXPRESSION : return false ; case ENHANCED_FOR_LOOP : if ( sameVariable ( collection , ( ( EnhancedForLoopTree ) node ) . getExpression ( ) ) ) { return true ; } break ; default : } } return false ; }
--------------------------------------------------
public static < T extends Enum < T >> Optional < T > asEnumValue ( Class < T > clazz , Attribute a ) { class Visitor extends SimpleAnnotationValueVisitor8 < T , Void > { @ Override public T visitEnumConstant ( VariableElement c , Void unused ) { return Enum . valueOf ( clazz , c . getSimpleName ( ) . toString ( ) ) ; } } return Optional . ofNullable ( a . accept ( new Visitor ( ) , null ) ) ; }
--------------------------------------------------
public static LinkedHashSet < String > enumValues ( TypeSymbol enumType ) { if ( enumType . getKind ( ) != ElementKind . ENUM ) { throw new IllegalStateException ( ) ; } Scope scope = enumType . members ( ) ; Deque < String > values = new ArrayDeque < > ( ) ; for ( Symbol sym : scope . getSymbols ( ) ) { if ( sym instanceof VarSymbol ) { VarSymbol var = ( VarSymbol ) sym ; if ( ( var . flags ( ) & Flags . ENUM ) != 0 ) { values . push ( sym . name . toString ( ) ) ; } } } return new LinkedHashSet < > ( values ) ; }
--------------------------------------------------
public Diff toProto ( ) { ApiDiffProto . Diff . Builder builder = ApiDiffProto . Diff . newBuilder ( ) ; for ( String className : unsupportedClasses ( ) ) { builder . addClassDiff ( ApiDiffProto . ClassDiff . newBuilder ( ) . setEverythingDiff ( ApiDiffProto . EverythingDiff . newBuilder ( ) . setClassName ( className ) ) ) ; } for ( String className : unsupportedMembersByClass ( ) . keySet ( ) ) { ApiDiffProto . MemberDiff . Builder memberDiff = ApiDiffProto . MemberDiff . newBuilder ( ) . setClassName ( className ) ; for ( ClassMemberKey member : unsupportedMembersByClass ( ) . get ( className ) ) { memberDiff . addMember ( ApiDiffProto . ClassMember . newBuilder ( ) . setIdentifier ( member . identifier ( ) ) . setMemberDescriptor ( member . descriptor ( ) ) ) ; } builder . addClassDiff ( ApiDiffProto . ClassDiff . newBuilder ( ) . setMemberDiff ( memberDiff ) ) ; } return builder . build ( ) ; }
--------------------------------------------------
public JavaFileObject forResource ( String fileName ) { Preconditions . checkState ( clazz . isPresent ( ) , 'clazz must be set if you want to add a source from a resource file' ) ; return forResource ( clazz . get ( ) , fileName ) ; }
--------------------------------------------------
public String toString ( ) { if ( importStrings . isEmpty ( ) ) { return '' ; } StringBuilder result = new StringBuilder ( ) ; if ( ! hasExistingImports ) { result . append ( '' ) ; } List < ImportOrganizer . Import > imports = importStrings . stream ( ) . map ( ImportOrganizer . Import :: importOf ) . collect ( Collectors . toList ( ) ) ; ImportOrganizer . OrganizedImports organizedImports = importOrganizer . organizeImports ( imports ) ; int expectedImportCount = imports . size ( ) ; int importCount = organizedImports . getImportCount ( ) ; if ( importCount != expectedImportCount ) { throw new IllegalStateException ( String . format ( 'expected %d import(s) in the organized imports but it contained %d' , expectedImportCount , importCount ) ) ; } result . append ( organizedImports . asImportBlock ( ) ) ; String replacementString = result . toString ( ) ; if ( ! hasExistingImports ) { return replacementString ; } else { return CharMatcher . whitespace ( ) . trimTrailingFrom ( replacementString ) ; } }
--------------------------------------------------
private ClassSymbol isEnclosedIn ( ClassSymbol startingClass , Symbol member , Types types ) { for ( ClassSymbol scope = startingClass . owner . enclClass ( ) ; scope != null ; scope = scope . owner . enclClass ( ) ) { if ( member . isMemberOf ( scope . type . tsym , types ) ) { return scope ; } } return null ; }
--------------------------------------------------
private Map < String , Invoker < T >> toInvokers ( List < URL > urls ) { Map < String , Invoker < T >> newUrlInvokerMap = new HashMap < String , Invoker < T >> ( ) ; if ( urls == null || urls . isEmpty ( ) ) { return newUrlInvokerMap ; } Set < String > keys = new HashSet < String > ( ) ; String queryProtocols = this . queryMap . get ( Constants . PROTOCOL_KEY ) ; for ( URL providerUrl : urls ) { if ( queryProtocols != null && queryProtocols . length ( ) > 0 ) { boolean accept = false ; String [ ] acceptProtocols = queryProtocols . split ( ',' ) ; for ( String acceptProtocol : acceptProtocols ) { if ( providerUrl . getProtocol ( ) . equals ( acceptProtocol ) ) { accept = true ; break ; } } if ( ! accept ) { continue ; } } if ( Constants . EMPTY_PROTOCOL . equals ( providerUrl . getProtocol ( ) ) ) { continue ; } if ( ! ExtensionLoader . getExtensionLoader ( Protocol . class ) . hasExtension ( providerUrl . getProtocol ( ) ) ) { logger . error ( new IllegalStateException ( 'unsupported protocol ' + providerUrl . getProtocol ( ) + ' in notified url: ' + providerUrl + ' from registry ' + getUrl ( ) . getAddress ( ) + ' to consumer ' + NetUtils . getLocalHost ( ) + ', supported protocol: ' + ExtensionLoader . getExtensionLoader ( Protocol . class ) . getSupportedExtensions ( ) ) ) ; continue ; } URL url = mergeUrl ( providerUrl ) ; String key = url . toFullString ( ) ; if ( keys . contains ( key ) ) { continue ; } keys . add ( key ) ; Map < String , Invoker < T >> localUrlInvokerMap = this . urlInvokerMap ; Invoker < T > invoker = localUrlInvokerMap == null ? null : localUrlInvokerMap . get ( key ) ; if ( invoker == null ) { try { boolean enabled = true ; if ( url . hasParameter ( Constants . DISABLED_KEY ) ) { enabled = ! url . getParameter ( Constants . DISABLED_KEY , false ) ; } else { enabled = url . getParameter ( Constants . ENABLED_KEY , true ) ; } if ( enabled ) { invoker = new InvokerDelegate < T > ( protocol . refer ( serviceType , url ) , url , providerUrl ) ; } } catch ( Throwable t ) { logger . error ( 'failed to refer invoker for interface:' + serviceType + ',url:(' + url + ')' + t . getMessage ( ) , t ) ; } if ( invoker != null ) { newUrlInvokerMap . put ( key , invoker ) ; } } else { newUrlInvokerMap . put ( key , invoker ) ; } } keys . clear ( ) ; return newUrlInvokerMap ; }
--------------------------------------------------
