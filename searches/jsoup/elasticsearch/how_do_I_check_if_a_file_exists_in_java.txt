private static boolean checkFileNameExist ( String fileName ) { File file = new File ( fileName ) ; return file . exists ( ) ; }
--------------------------------------------------
protected void checkRegistry ( ) { loadRegistriesFromBackwardConfig ( ) ; convertRegistryIdsToRegistries ( ) ; for ( RegistryConfig registryConfig : registries ) { if ( ! registryConfig . isValid ( ) ) { throw new IllegalStateException ( 'no registry config found or it's not a valid config! ' '+' 'the registry config is: ' + registryConfig ) ; } } useRegistryForConfigIfNecessary ( ) ; }
--------------------------------------------------
private static String getFromFile ( String file ) { file = file . substring ( 0 , file . length ( ) - 4 ) ; int i = file . lastIndexOf ( '/' ) ; if ( i >= 0 ) { file = file . substring ( i + 1 ) ; } i = file . indexOf ( '-' ) ; if ( i >= 0 ) { file = file . substring ( i + 1 ) ; } while ( file . length ( ) > 0 && ! Character . isDigit ( file . charAt ( 0 ) ) ) { i = file . indexOf ( '-' ) ; if ( i >= 0 ) { file = file . substring ( i + 1 ) ; } else { break ; } } return file ; }
--------------------------------------------------
public void doDestroy ( ) { if ( ! destroyed . compareAndSet ( false , true ) ) { return ; } AbstractRegistryFactory . destroyAll ( ) ; destroyProtocols ( ) ; }
--------------------------------------------------
void checkMock ( Class < ? > interfaceClass ) { if ( ConfigUtils . isEmpty ( mock ) ) { return ; } String normalizedMock = MockInvoker . normalizeMock ( mock ) ; if ( normalizedMock . startsWith ( Constants . RETURN_PREFIX ) ) { normalizedMock = normalizedMock . substring ( Constants . RETURN_PREFIX . length ( ) ) . trim ( ) ; try { MockInvoker . parseMockValue ( normalizedMock ) ; } catch ( Exception e ) { throw new IllegalStateException ( 'illegal mock return in <dubbo:service/reference ... ' '+' 'mock='' + mock + '' />' ) ; } } else if ( normalizedMock . startsWith ( Constants . THROW_PREFIX ) ) { normalizedMock = normalizedMock . substring ( Constants . THROW_PREFIX . length ( ) ) . trim ( ) ; if ( ConfigUtils . isNotEmpty ( normalizedMock ) ) { try { MockInvoker . getThrowable ( normalizedMock ) ; } catch ( Exception e ) { throw new IllegalStateException ( 'illegal mock throw in <dubbo:service/reference ... ' '+' 'mock='' + mock + '' />' ) ; } } } else { MockInvoker . getMockObject ( normalizedMock , interfaceClass ) ; } }
--------------------------------------------------
private Description checkAnnotations ( Tree tree , int treePos , List < ? extends AnnotationTree > annotations , Comment danglingJavadoc , int firstModifierPos , int lastModifierPos , VisitorState state ) { SuggestedFix . Builder builder = SuggestedFix . builder ( ) ; List < AnnotationTree > moveBefore = new ArrayList < > ( ) ; List < AnnotationTree > moveAfter = new ArrayList < > ( ) ; boolean annotationProblem = false ; for ( AnnotationTree annotation : annotations ) { int annotationPos = ( ( JCTree ) annotation ) . getStartPosition ( ) ; if ( annotationPos <= firstModifierPos ) { continue ; } AnnotationType annotationType = ASTHelpers . getAnnotationType ( annotation , getSymbol ( tree ) , state ) ; if ( annotationPos >= lastModifierPos ) { if ( tree instanceof ClassTree || annotationType == AnnotationType . DECLARATION ) { annotationProblem = true ; moveBefore . add ( annotation ) ; } } else { annotationProblem = true ; if ( tree instanceof ClassTree || annotationType == AnnotationType . DECLARATION || annotationType == null ) { moveBefore . add ( annotation ) ; } else { moveAfter . add ( annotation ) ; } } } if ( annotationProblem ) { for ( AnnotationTree annotation : moveBefore ) { builder . delete ( annotation ) ; } for ( AnnotationTree annotation : moveAfter ) { builder . delete ( annotation ) ; } String javadoc = danglingJavadoc == null ? '' : removeJavadoc ( state , treePos , danglingJavadoc , builder ) ; builder . replace ( firstModifierPos , firstModifierPos , String . format ( '%s%s ' , javadoc , joinSource ( state , moveBefore ) ) ) . replace ( lastModifierPos , lastModifierPos , String . format ( '%s ' , joinSource ( state , moveAfter ) ) ) ; ImmutableList < String > names = annotations . stream ( ) . map ( ASTHelpers :: getSymbol ) . filter ( Objects :: nonNull ) . map ( Symbol :: getSimpleName ) . map ( a -> '@' + a ) . collect ( toImmutableList ( ) ) ; String flattened = names . stream ( ) . collect ( joining ( ', ' ) ) ; String isAre = names . size ( ) > 1 ? 'are not type annotations' : 'is not a type annotation' ; String message = String . format ( '%s %s, so should appear before any modifiers and after javadocs.' , flattened , isAre ) ; return buildDescription ( tree ) . setMessage ( message ) . addFix ( builder . build ( ) ) . build ( ) ; } return NO_MATCH ; }
--------------------------------------------------
public static String [ ] readLines ( File file ) throws IOException { if ( file == null || ! file . exists ( ) || ! file . canRead ( ) ) { return new String [ 0 ] ; } return readLines ( new FileInputStream ( file ) ) ; }
--------------------------------------------------
public static boolean isJavaIdentifier ( String s ) { if ( isEmpty ( s ) || ! Character . isJavaIdentifierStart ( s . charAt ( 0 ) ) ) { return false ; } for ( int i = 1 ; i < s . length ( ) ; i ++ ) { if ( ! Character . isJavaIdentifierPart ( s . charAt ( i ) ) ) { return false ; } } return true ; }
--------------------------------------------------
private Description checkSubtype ( ClassTree tree , VisitorState state ) { ClassSymbol sym = ASTHelpers . getSymbol ( tree ) ; if ( sym == null ) { return NO_MATCH ; } Type superType = immutableSupertype ( sym , state ) ; if ( superType == null ) { return NO_MATCH ; } String message = String . format ( 'class extends @immutable type %s, but is not annotated as immutable' , superType ) ; Fix fix = SuggestedFix . builder ( ) . prefixWith ( tree , '@immutable ' ) . addImport ( Immutable . class . getName ( ) ) . build ( ) ; return buildDescription ( tree ) . setMessage ( message ) . addFix ( fix ) . build ( ) ; }
--------------------------------------------------
private String generateInvocationArgumentNullCheck ( Method method ) { Class < ? > [ ] pts = method . getParameterTypes ( ) ; return IntStream . range ( 0 , pts . length ) . filter ( i -> CLASSNAME_INVOCATION . equals ( pts [ i ] . getName ( ) ) ) . mapToObj ( i -> String . format ( CODE_INVOCATION_ARGUMENT_NULL_CHECK , i , i ) ) . findFirst ( ) . orElse ( '' ) ; }
--------------------------------------------------
