private static String rewriteArrayArgument ( ExpressionTree arg , VisitorState state ) { Types types = state . getTypes ( ) ; Type argType = ASTHelpers . getType ( arg ) ; Preconditions . checkState ( types . isArray ( argType ) , 'arg must be of array type' ) ; if ( types . isArray ( types . elemtype ( argType ) ) ) { return 'arrays.deephashcode(' + state . getSourceForNode ( arg ) + ')' ; } else { return 'arrays.hashcode(' + state . getSourceForNode ( arg ) + ')' ; } }
--------------------------------------------------
public Set < String > threadSafeTypeParametersInScope ( Symbol sym ) { if ( sym == null ) { return ImmutableSet . of ( ) ; } ImmutableSet . Builder < String > result = ImmutableSet . builder ( ) ; OUTER : for ( Symbol s = sym ; s . owner != null ; s = s . owner ) { switch ( s . getKind ( ) ) { case INSTANCE_INIT : continue ; case PACKAGE : break OUTER ; default : break ; } AnnotationInfo annotation = getMarkerOrAcceptedAnnotation ( s , state ) ; if ( annotation == null ) { continue ; } for ( TypeVariableSymbol typaram : s . getTypeParameters ( ) ) { String name = typaram . getSimpleName ( ) . toString ( ) ; if ( annotation . containerOf ( ) . contains ( name ) ) { result . add ( name ) ; } } if ( s . isStatic ( ) ) { break ; } } return result . build ( ) ; }
--------------------------------------------------
public void assertHasDiagnosticOnAllMatchingLines ( JavaFileObject source , LookForCheckNameInDiagnostic lookForCheckNameInDiagnostic ) throws IOException { final List < Diagnostic < ? extends JavaFileObject >> diagnostics = getDiagnostics ( ) ; final LineNumberReader reader = new LineNumberReader ( CharSource . wrap ( source . getCharContent ( false ) ) . openStream ( ) ) ; do { String line = reader . readLine ( ) ; if ( line == null ) { break ; } List < Predicate < ? super String >> predicates = null ; if ( line . contains ( BUG_MARKER_COMMENT_INLINE ) ) { List < String > patterns = extractPatterns ( line , reader , BUG_MARKER_COMMENT_INLINE ) ; predicates = new ArrayList < > ( patterns . size ( ) ) ; for ( String pattern : patterns ) { predicates . add ( new SimpleStringContains ( pattern ) ) ; } } else if ( line . contains ( BUG_MARKER_COMMENT_LOOKUP ) ) { int markerLineNumber = reader . getLineNumber ( ) ; List < String > lookupKeys = extractPatterns ( line , reader , BUG_MARKER_COMMENT_LOOKUP ) ; predicates = new ArrayList < > ( lookupKeys . size ( ) ) ; for ( String lookupKey : lookupKeys ) { assertWithMessage ( 'no expected error message with key [%s] as expected from line [%s] ' '+' 'with diagnostic [%s]' , lookupKey , markerLineNumber , line . trim ( ) ) . that ( expectedErrorMsgs . containsKey ( lookupKey ) ) . isTrue ( ) ; predicates . add ( expectedErrorMsgs . get ( lookupKey ) ) ; usedLookupKeys . add ( lookupKey ) ; } } if ( predicates != null ) { int lineNumber = reader . getLineNumber ( ) ; for ( Predicate < ? super String > predicate : predicates ) { Matcher < ? super Iterable < Diagnostic < ? extends JavaFileObject >>> patternMatcher = hasItem ( diagnosticOnLine ( source . toUri ( ) , lineNumber , predicate ) ) ; assertWithMessage ( 'did not see an error on line %s matching %s. %s' , lineNumber , predicate , allErrors ( diagnostics ) ) . that ( patternMatcher . matches ( diagnostics ) ) . isTrue ( ) ; } if ( checkName != null && lookForCheckNameInDiagnostic == LookForCheckNameInDiagnostic . YES ) { Matcher < ? super Iterable < Diagnostic < ? extends JavaFileObject >>> checkNameMatcher = hasItem ( diagnosticOnLine ( source . toUri ( ) , lineNumber , new SimpleStringContains ( '[' + checkName + ']' ) ) ) ; assertWithMessage ( 'did not see an error on line %s containing [%s]. %s' , lineNumber , checkName , allErrors ( diagnostics ) ) . that ( checkNameMatcher . matches ( diagnostics ) ) . isTrue ( ) ; } } else { int lineNumber = reader . getLineNumber ( ) ; Matcher < ? super Iterable < Diagnostic < ? extends JavaFileObject >>> matcher = hasItem ( diagnosticOnLine ( source . toUri ( ) , lineNumber ) ) ; if ( matcher . matches ( diagnostics ) ) { fail ( 'saw unexpected error on line ' + lineNumber + '. ' + allErrors ( diagnostics ) ) ; } } } while ( true ) ; reader . close ( ) ; }
--------------------------------------------------
private static ImmutableSet < String > immutableTypeParametersInScope ( Symbol sym , VisitorState state , ImmutableAnalysis analysis ) { if ( sym == null ) { return ImmutableSet . of ( ) ; } ImmutableSet . Builder < String > result = ImmutableSet . builder ( ) ; OUTER : for ( Symbol s = sym ; s . owner != null ; s = s . owner ) { switch ( s . getKind ( ) ) { case INSTANCE_INIT : continue ; case PACKAGE : break OUTER ; default : break ; } AnnotationInfo annotation = analysis . getImmutableAnnotation ( s , state ) ; if ( annotation == null ) { continue ; } for ( TypeVariableSymbol typaram : s . getTypeParameters ( ) ) { String name = typaram . getSimpleName ( ) . toString ( ) ; if ( annotation . containerOf ( ) . contains ( name ) ) { result . add ( name ) ; } } if ( s . isStatic ( ) ) { break ; } } return result . build ( ) ; }
--------------------------------------------------
public Description matchMethod ( MethodTree tree , VisitorState state ) { if ( ! HAS_MUST_BE_CLOSED_ANNOTATION . matches ( tree , state ) ) { return NO_MATCH ; } boolean isAConstructor = methodIsConstructor ( ) . matches ( tree , state ) ; if ( isAConstructor && ! AUTO_CLOSEABLE_CONSTRUCTOR_MATCHER . matches ( tree , state ) ) { return buildDescription ( tree ) . setMessage ( 'mustbeclosed should only annotate constructors of autocloseables.' ) . build ( ) ; } if ( ! isAConstructor && ! METHOD_RETURNS_AUTO_CLOSEABLE_MATCHER . matches ( tree , state ) ) { return buildDescription ( tree ) . setMessage ( 'mustbeclosed should only annotate methods that return an autocloseable.' ) . build ( ) ; } return NO_MATCH ; }
--------------------------------------------------
public Result invoke ( Invoker < ? > invoker , Invocation inv ) throws RpcException { try { String accessLogKey = invoker . getUrl ( ) . getParameter ( Constants . ACCESS_LOG_KEY ) ; if ( ConfigUtils . isNotEmpty ( accessLogKey ) ) { AccessLogData logData = buildAccessLogData ( invoker , inv ) ; log ( accessLogKey , logData ) ; } } catch ( Throwable t ) { logger . warn ( 'exception in acesslogfilter of service(' + invoker + ' -> ' + inv + ')' , t ) ; } return invoker . invoke ( inv ) ; }
--------------------------------------------------
private String buildMessage ( GuardedByExpression guard , HeldLockSet locks ) { int heldLocks = locks . allLocks ( ) . size ( ) ; StringBuilder message = new StringBuilder ( ) ; Select enclosing = findOuterInstance ( guard ) ; if ( enclosing != null && ! enclosingInstance ( guard ) ) { if ( guard == enclosing ) { message . append ( String . format ( 'access should be guarded by enclosing instance '%s' of '%s',' '+' ' which is not accessible in this scope' , enclosing . sym ( ) . owner , enclosing . base ( ) ) ) ; } else { message . append ( String . format ( 'access should be guarded by '%s' in enclosing instance '%s' of '%s',' '+' ' which is not accessible in this scope' , guard . sym ( ) , enclosing . sym ( ) . owner , enclosing . base ( ) ) ) ; } if ( heldLocks > 0 ) { message . append ( String . format ( '; instead found: '%s'' , Joiner . on ( '', '' ) . join ( locks . allLocks ( ) ) ) ) ; } return message . toString ( ) ; } message . append ( String . format ( 'this access should be guarded by '%s'' , guard ) ) ; if ( guard . kind ( ) == GuardedByExpression . Kind . ERROR ) { message . append ( ', which could not be resolved' ) ; return message . toString ( ) ; } if ( heldLocks == 0 ) { message . append ( ', which is not currently held' ) ; } else { message . append ( String . format ( '; instead found: '%s'' , Joiner . on ( '', '' ) . join ( locks . allLocks ( ) ) ) ) ; } return message . toString ( ) ; }
--------------------------------------------------
private BeanNameGenerator resolveBeanNameGenerator ( BeanDefinitionRegistry registry ) { BeanNameGenerator beanNameGenerator = null ; if ( registry instanceof SingletonBeanRegistry ) { SingletonBeanRegistry singletonBeanRegistry = SingletonBeanRegistry . class . cast ( registry ) ; beanNameGenerator = ( BeanNameGenerator ) singletonBeanRegistry . getSingleton ( CONFIGURATION_BEAN_NAME_GENERATOR ) ; } if ( beanNameGenerator == null ) { if ( logger . isInfoEnabled ( ) ) { logger . info ( 'beannamegenerator bean can't be found in beanfactory with name [' + CONFIGURATION_BEAN_NAME_GENERATOR + ']' ) ; logger . info ( 'beannamegenerator will be a instance of ' + AnnotationBeanNameGenerator . class . getName ( ) + ' , it maybe a potential problem on bean name generation.' ) ; } beanNameGenerator = new AnnotationBeanNameGenerator ( ) ; } return beanNameGenerator ; }
--------------------------------------------------
private void registerServiceBean ( BeanDefinitionHolder beanDefinitionHolder , BeanDefinitionRegistry registry , DubboClassPathBeanDefinitionScanner scanner ) { Class < ? > beanClass = resolveClass ( beanDefinitionHolder ) ; Service service = findAnnotation ( beanClass , Service . class ) ; Class < ? > interfaceClass = resolveServiceInterfaceClass ( beanClass , service ) ; String annotatedServiceBeanName = beanDefinitionHolder . getBeanName ( ) ; AbstractBeanDefinition serviceBeanDefinition = buildServiceBeanDefinition ( service , interfaceClass , annotatedServiceBeanName ) ; String beanName = generateServiceBeanName ( service , interfaceClass , annotatedServiceBeanName ) ; if ( scanner . checkCandidate ( beanName , serviceBeanDefinition ) ) { registry . registerBeanDefinition ( beanName , serviceBeanDefinition ) ; if ( logger . isInfoEnabled ( ) ) { logger . warn ( 'the beandefinition[' + serviceBeanDefinition + '] of servicebean has been registered with name : ' + beanName ) ; } } else { if ( logger . isWarnEnabled ( ) ) { logger . warn ( 'the duplicated beandefinition[' + serviceBeanDefinition + '] of servicebean[ bean name : ' + beanName + '] was be found , did @compatibledubbocomponentscan scan to same package in many times?' ) ; } } }
--------------------------------------------------
private BeanNameGenerator resolveBeanNameGenerator ( BeanDefinitionRegistry registry ) { BeanNameGenerator beanNameGenerator = null ; if ( registry instanceof SingletonBeanRegistry ) { SingletonBeanRegistry singletonBeanRegistry = SingletonBeanRegistry . class . cast ( registry ) ; beanNameGenerator = ( BeanNameGenerator ) singletonBeanRegistry . getSingleton ( CONFIGURATION_BEAN_NAME_GENERATOR ) ; } if ( beanNameGenerator == null ) { if ( logger . isInfoEnabled ( ) ) { logger . info ( 'beannamegenerator bean can't be found in beanfactory with name [' + CONFIGURATION_BEAN_NAME_GENERATOR + ']' ) ; logger . info ( 'beannamegenerator will be a instance of ' + AnnotationBeanNameGenerator . class . getName ( ) + ' , it maybe a potential problem on bean name generation.' ) ; } beanNameGenerator = new AnnotationBeanNameGenerator ( ) ; } return beanNameGenerator ; }
--------------------------------------------------
