public String generate ( ) { if ( ! hasAdaptiveMethod ( ) ) { throw new IllegalStateException ( 'no adaptive method exist on extension ' + type . getName ( ) + ', refuse to create the adaptive class!' ) ; } StringBuilder code = new StringBuilder ( ) ; code . append ( generatePackageInfo ( ) ) ; code . append ( generateImports ( ) ) ; code . append ( generateClassDeclaration ( ) ) ; Method [ ] methods = type . getMethods ( ) ; for ( Method method : methods ) { code . append ( generateMethod ( method ) ) ; } code . append ( '}' ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( code . toString ( ) ) ; } return code . toString ( ) ; }
--------------------------------------------------
private String generateMethod ( Method method ) { String methodReturnType = method . getReturnType ( ) . getCanonicalName ( ) ; String methodName = method . getName ( ) ; String methodContent = generateMethodContent ( method ) ; String methodArgs = generateMethodArguments ( method ) ; String methodThrows = generateMethodThrows ( method ) ; return String . format ( CODE_METHOD_DECLARATION , methodReturnType , methodName , methodArgs , methodThrows , methodContent ) ; }
--------------------------------------------------
public String chompTo ( String seq ) { String data = consumeTo ( seq ) ; matchChomp ( seq ) ; return data ; }
--------------------------------------------------
public String toString ( ) { if ( importStrings . isEmpty ( ) ) { return '' ; } StringBuilder result = new StringBuilder ( ) ; if ( ! hasExistingImports ) { result . append ( '' ) ; } List < ImportOrganizer . Import > imports = importStrings . stream ( ) . map ( ImportOrganizer . Import :: importOf ) . collect ( Collectors . toList ( ) ) ; ImportOrganizer . OrganizedImports organizedImports = importOrganizer . organizeImports ( imports ) ; int expectedImportCount = imports . size ( ) ; int importCount = organizedImports . getImportCount ( ) ; if ( importCount != expectedImportCount ) { throw new IllegalStateException ( String . format ( 'expected %d import(s) in the organized imports but it contained %d' , expectedImportCount , importCount ) ) ; } result . append ( organizedImports . asImportBlock ( ) ) ; String replacementString = result . toString ( ) ; if ( ! hasExistingImports ) { return replacementString ; } else { return CharMatcher . whitespace ( ) . trimTrailingFrom ( replacementString ) ; } }
--------------------------------------------------
public String toString ( ) { return getFirst ( getAllChecks ( ) . keySet ( ) , '' ) ; }
--------------------------------------------------
public static String toString ( Throwable e ) { UnsafeStringWriter w = new UnsafeStringWriter ( ) ; PrintWriter p = new PrintWriter ( w ) ; p . print ( e . getClass ( ) . getName ( ) ) ; if ( e . getMessage ( ) != null ) { p . print ( ': ' + e . getMessage ( ) ) ; } p . println ( ) ; try { e . printStackTrace ( p ) ; return w . toString ( ) ; } finally { p . close ( ) ; } }
--------------------------------------------------
public Diff toProto ( ) { ApiDiffProto . Diff . Builder builder = ApiDiffProto . Diff . newBuilder ( ) ; for ( String className : unsupportedClasses ( ) ) { builder . addClassDiff ( ApiDiffProto . ClassDiff . newBuilder ( ) . setEverythingDiff ( ApiDiffProto . EverythingDiff . newBuilder ( ) . setClassName ( className ) ) ) ; } for ( String className : unsupportedMembersByClass ( ) . keySet ( ) ) { ApiDiffProto . MemberDiff . Builder memberDiff = ApiDiffProto . MemberDiff . newBuilder ( ) . setClassName ( className ) ; for ( ClassMemberKey member : unsupportedMembersByClass ( ) . get ( className ) ) { memberDiff . addMember ( ApiDiffProto . ClassMember . newBuilder ( ) . setIdentifier ( member . identifier ( ) ) . setMemberDescriptor ( member . descriptor ( ) ) ) ; } builder . addClassDiff ( ApiDiffProto . ClassDiff . newBuilder ( ) . setMemberDiff ( memberDiff ) ) ; } return builder . build ( ) ; }
--------------------------------------------------
private String generateMethodThrows ( Method method ) { Class < ? > [ ] ets = method . getExceptionTypes ( ) ; if ( ets . length > 0 ) { String list = Arrays . stream ( ets ) . map ( Class :: getCanonicalName ) . collect ( Collectors . joining ( ', ' ) ) ; return String . format ( CODE_METHOD_THROWS , list ) ; } else { return '' ; } }
--------------------------------------------------
private Object toFile ( VisitorState state , Tree fileArg , SuggestedFix . Builder fix ) { Type type = ASTHelpers . getType ( fileArg ) ; if ( ASTHelpers . isSubtype ( type , state . getSymtab ( ) . stringType , state ) ) { fix . addImport ( 'java.io.file' ) ; return String . format ( 'new file(%s)' , state . getSourceForNode ( fileArg ) ) ; } else if ( ASTHelpers . isSubtype ( type , state . getTypeFromString ( 'java.io.file' ) , state ) ) { return state . getSourceForNode ( fileArg ) ; } else { throw new AssertionError ( 'unexpected type: ' + type ) ; } }
--------------------------------------------------
private static String exceptionToString ( TryTree tree , VisitorState state ) { if ( tree . getCatches ( ) . size ( ) != 1 ) { return 'exception' ; } Tree exceptionType = tree . getCatches ( ) . iterator ( ) . next ( ) . getParameter ( ) . getType ( ) ; Type type = ASTHelpers . getType ( exceptionType ) ; if ( type != null && type . isUnion ( ) ) { return 'exception' ; } return state . getSourceForNode ( exceptionType ) ; }
--------------------------------------------------
