public static ImmutableSet < String > getGeneratedBy ( ClassSymbol symbol , VisitorState state ) { checkNotNull ( symbol ) ; Optional < Compound > c = Stream . of ( 'javax.annotation.generated' , 'javax.annotation.processing.generated' ) . map ( state :: getSymbolFromString ) . filter ( a -> a != null ) . map ( symbol :: attribute ) . filter ( a -> a != null ) . findFirst ( ) ; if ( ! c . isPresent ( ) ) { return ImmutableSet . of ( ) ; } Optional < Attribute > values = c . get ( ) . getElementValues ( ) . entrySet ( ) . stream ( ) . filter ( e -> e . getKey ( ) . getSimpleName ( ) . contentEquals ( 'value' ) ) . map ( e -> e . getValue ( ) ) . findAny ( ) ; if ( ! values . isPresent ( ) ) { return ImmutableSet . of ( ) ; } ImmutableSet . Builder < String > suppressions = ImmutableSet . builder ( ) ; values . get ( ) . accept ( new SimpleAnnotationValueVisitor8 < Void , Void > ( ) { @ Override public Void visitString ( String s , Void aVoid ) { suppressions . add ( s ) ; return super . visitString ( s , aVoid ) ; } @ Override public Void visitArray ( List < ? extends AnnotationValue > vals , Void aVoid ) { vals . stream ( ) . forEachOrdered ( v -> v . accept ( this , null ) ) ; return super . visitArray ( vals , aVoid ) ; } } , null ) ; return suppressions . build ( ) ; }
--------------------------------------------------
protected Map < InjectionMetadata . InjectedElement , Object > getInjectedMethodObjectsMap ( ) { Map < InjectionMetadata . InjectedElement , Object > injectedElementBeanMap = new LinkedHashMap < InjectionMetadata . InjectedElement , Object > ( ) ; for ( AnnotationInjectedBeanPostProcessor . AnnotatedInjectionMetadata metadata : injectionMetadataCache . values ( ) ) { Collection < AnnotationInjectedBeanPostProcessor . AnnotatedMethodElement > methodElements = metadata . getMethodElements ( ) ; for ( AnnotationInjectedBeanPostProcessor . AnnotatedMethodElement methodElement : methodElements ) { injectedElementBeanMap . put ( methodElement , methodElement . object ) ; } } return Collections . unmodifiableMap ( injectedElementBeanMap ) ; }
--------------------------------------------------
protected Map < InjectionMetadata . InjectedElement , Object > getInjectedFieldObjectsMap ( ) { Map < InjectionMetadata . InjectedElement , Object > injectedElementBeanMap = new LinkedHashMap < InjectionMetadata . InjectedElement , Object > ( ) ; for ( AnnotationInjectedBeanPostProcessor . AnnotatedInjectionMetadata metadata : injectionMetadataCache . values ( ) ) { Collection < AnnotationInjectedBeanPostProcessor . AnnotatedFieldElement > fieldElements = metadata . getFieldElements ( ) ; for ( AnnotationInjectedBeanPostProcessor . AnnotatedFieldElement fieldElement : fieldElements ) { injectedElementBeanMap . put ( fieldElement , fieldElement . bean ) ; } } return Collections . unmodifiableMap ( injectedElementBeanMap ) ; }
--------------------------------------------------
public Map < InjectionMetadata . InjectedElement , ReferenceBean < ? >> getInjectedMethodReferenceBeanMap ( ) { Map < InjectionMetadata . InjectedElement , ReferenceBean < ? >> injectedElementReferenceBeanMap = new LinkedHashMap < InjectionMetadata . InjectedElement , ReferenceBean < ? >> ( ) ; for ( ReferenceInjectionMetadata metadata : injectionMetadataCache . values ( ) ) { Collection < ReferenceMethodElement > methodElements = metadata . getMethodElements ( ) ; for ( ReferenceMethodElement methodElement : methodElements ) { injectedElementReferenceBeanMap . put ( methodElement , methodElement . referenceBean ) ; } } return injectedElementReferenceBeanMap ; }
--------------------------------------------------
public static ImmutableList < Fix > fixesByReplacingExpressionWithLocallyDeclaredField ( ExpressionTree input , Predicate < JCVariableDecl > validFieldPredicate , VisitorState state ) { Preconditions . checkState ( input . getKind ( ) == IDENTIFIER || input . getKind ( ) == MEMBER_SELECT ) ; ImmutableMultimap < Integer , JCVariableDecl > potentialReplacements = ASTHelpers . findEnclosingNode ( state . getPath ( ) , JCClassDecl . class ) . getMembers ( ) . stream ( ) . filter ( JCVariableDecl . class :: isInstance ) . map ( JCVariableDecl . class :: cast ) . filter ( validFieldPredicate ) . collect ( collectByEditDistanceTo ( simpleNameOfIdentifierOrMemberAccess ( input ) ) ) ; return buildValidReplacements ( potentialReplacements , var -> SuggestedFix . replace ( input , 'this.' + var . sym ) ) ; }
--------------------------------------------------
< ParameterPair > viablePairs ( ) { return formals . stream ( ) . flatMap ( f -> actuals . stream ( ) . map ( a -> ParameterPair . create ( f , a ) ) ) . filter ( p -> costMatrix [ p . formal ( ) . index ( ) ] [ p . actual ( ) . index ( ) ] != Double . POSITIVE_INFINITY ) ; }
--------------------------------------------------
public static Map < String , Object > getAttributes ( Annotation annotation , PropertyResolver propertyResolver , boolean ignoreDefaultValue , String ... ignoreAttributeNames ) { Set < String > ignoreAttributeNamesSet = new HashSet < String > ( arrayToList ( ignoreAttributeNames ) ) ; Map < String , Object > attributes = getAnnotationAttributes ( annotation ) ; Map < String , Object > actualAttributes = new LinkedHashMap < String , Object > ( ) ; for ( Map . Entry < String , Object > entry : attributes . entrySet ( ) ) { String attributeName = entry . getKey ( ) ; Object attributeValue = entry . getValue ( ) ; if ( ignoreDefaultValue && nullSafeEquals ( attributeValue , getDefaultValue ( annotation , attributeName ) ) ) { continue ; } if ( ignoreAttributeNamesSet . contains ( attributeName ) ) { continue ; } if ( attributeValue instanceof String ) { attributeValue = resolvePlaceholders ( valueOf ( attributeValue ) , propertyResolver ) ; } else if ( attributeValue instanceof String [ ] ) { String [ ] values = ( String [ ] ) attributeValue ; for ( int i = 0 ; i < values . length ; i ++ ) { values [ i ] = resolvePlaceholders ( values [ i ] , propertyResolver ) ; } attributeValue = values ; } actualAttributes . put ( attributeName , attributeValue ) ; } return actualAttributes ; }
--------------------------------------------------
public Map < InjectionMetadata . InjectedElement , ReferenceBean < ? >> getInjectedFieldReferenceBeanMap ( ) { Map < InjectionMetadata . InjectedElement , ReferenceBean < ? >> injectedElementReferenceBeanMap = new LinkedHashMap < InjectionMetadata . InjectedElement , ReferenceBean < ? >> ( ) ; for ( ReferenceInjectionMetadata metadata : injectionMetadataCache . values ( ) ) { Collection < ReferenceFieldElement > fieldElements = metadata . getFieldElements ( ) ; for ( ReferenceFieldElement fieldElement : fieldElements ) { injectedElementReferenceBeanMap . put ( fieldElement , fieldElement . referenceBean ) ; } } return injectedElementReferenceBeanMap ; }
--------------------------------------------------
public static < A extends Annotation > Map < ElementType , List < A >> findAnnotations ( Method method , Class < A > annotationClass ) { Retention retention = annotationClass . getAnnotation ( Retention . class ) ; RetentionPolicy retentionPolicy = retention . value ( ) ; if ( ! RetentionPolicy . RUNTIME . equals ( retentionPolicy ) ) { return Collections . emptyMap ( ) ; } Map < ElementType , List < A >> annotationsMap = new LinkedHashMap < ElementType , List < A >> ( ) ; Target target = annotationClass . getAnnotation ( Target . class ) ; ElementType [ ] elementTypes = target . value ( ) ; for ( ElementType elementType : elementTypes ) { List < A > annotationsList = new LinkedList < A > ( ) ; switch ( elementType ) { case PARAMETER : Annotation [ ] [ ] parameterAnnotations = method . getParameterAnnotations ( ) ; for ( Annotation [ ] annotations : parameterAnnotations ) { for ( Annotation annotation : annotations ) { if ( annotationClass . equals ( annotation . annotationType ( ) ) ) { annotationsList . add ( ( A ) annotation ) ; } } } break ; case METHOD : A annotation = findAnnotation ( method , annotationClass ) ; if ( annotation != null ) { annotationsList . add ( annotation ) ; } break ; case TYPE : Class < ? > beanType = method . getDeclaringClass ( ) ; A annotation2 = findAnnotation ( beanType , annotationClass ) ; if ( annotation2 != null ) { annotationsList . add ( annotation2 ) ; } break ; } if ( ! annotationsList . isEmpty ( ) ) { annotationsMap . put ( elementType , annotationsList ) ; } } return Collections . unmodifiableMap ( annotationsMap ) ; }
--------------------------------------------------
public static < A extends Annotation > boolean isPresent ( Method method , Class < A > annotationClass ) { Map < ElementType , List < A >> annotationsMap = findAnnotations ( method , annotationClass ) ; return ! annotationsMap . isEmpty ( ) ; }
--------------------------------------------------
