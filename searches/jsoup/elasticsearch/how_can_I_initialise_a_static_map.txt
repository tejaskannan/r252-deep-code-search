public static boolean canCompleteNormally ( CaseTree caseTree ) { List < ? extends StatementTree > statements = caseTree . getStatements ( ) ; if ( statements . isEmpty ( ) ) { return true ; } return canCompleteNormally ( getLast ( statements ) ) ; }
--------------------------------------------------
public static boolean methodCanBeOverridden ( MethodSymbol methodSymbol ) { if ( methodSymbol . getModifiers ( ) . contains ( Modifier . ABSTRACT ) ) { return true ; } if ( methodSymbol . isStatic ( ) || methodSymbol . isPrivate ( ) || isFinal ( methodSymbol ) || methodSymbol . isConstructor ( ) ) { return false ; } ClassSymbol classSymbol = ( ClassSymbol ) methodSymbol . owner ; return ! isFinal ( classSymbol ) && ! classSymbol . isAnonymous ( ) ; }
--------------------------------------------------
private static char [ ] zzUnpackCMap ( String packed ) { char [ ] map = new char [ 10000 ] ; int i = 0 ; int j = 0 ; while ( i < 122 ) { int count = packed . charAt ( i ++ ) ; char value = packed . charAt ( i ++ ) ; do { map [ j ++ ] = value ; } while ( -- count > 0 ) ; } return map ; }
--------------------------------------------------
private static Map < String , String > parseKeyValuePair ( String str , String itemSeparator ) { String [ ] tmp = str . split ( itemSeparator ) ; Map < String , String > map = new HashMap < String , String > ( tmp . length ) ; for ( int i = 0 ; i < tmp . length ; i ++ ) { Matcher matcher = KVP_PATTERN . matcher ( tmp [ i ] ) ; if ( ! matcher . matches ( ) ) { continue ; } map . put ( matcher . group ( 1 ) , matcher . group ( 2 ) ) ; } return map ; }
--------------------------------------------------
public static Optional < Integer > asIntegerValue ( Attribute a ) { class Visitor extends SimpleAnnotationValueVisitor8 < Integer , Void > { @ Override public Integer visitInt ( int i , Void unused ) { return i ; } } return Optional . ofNullable ( a . accept ( new Visitor ( ) , null ) ) ; }
--------------------------------------------------
public static < A extends Annotation > boolean isPresent ( Method method , Class < A > annotationClass ) { Map < ElementType , List < A >> annotationsMap = findAnnotations ( method , annotationClass ) ; return ! annotationsMap . isEmpty ( ) ; }
--------------------------------------------------
public static < A extends Annotation > Map < ElementType , List < A >> findAnnotations ( Method method , Class < A > annotationClass ) { Retention retention = annotationClass . getAnnotation ( Retention . class ) ; RetentionPolicy retentionPolicy = retention . value ( ) ; if ( ! RetentionPolicy . RUNTIME . equals ( retentionPolicy ) ) { return Collections . emptyMap ( ) ; } Map < ElementType , List < A >> annotationsMap = new LinkedHashMap < ElementType , List < A >> ( ) ; Target target = annotationClass . getAnnotation ( Target . class ) ; ElementType [ ] elementTypes = target . value ( ) ; for ( ElementType elementType : elementTypes ) { List < A > annotationsList = new LinkedList < A > ( ) ; switch ( elementType ) { case PARAMETER : Annotation [ ] [ ] parameterAnnotations = method . getParameterAnnotations ( ) ; for ( Annotation [ ] annotations : parameterAnnotations ) { for ( Annotation annotation : annotations ) { if ( annotationClass . equals ( annotation . annotationType ( ) ) ) { annotationsList . add ( ( A ) annotation ) ; } } } break ; case METHOD : A annotation = findAnnotation ( method , annotationClass ) ; if ( annotation != null ) { annotationsList . add ( annotation ) ; } break ; case TYPE : Class < ? > beanType = method . getDeclaringClass ( ) ; A annotation2 = findAnnotation ( beanType , annotationClass ) ; if ( annotation2 != null ) { annotationsList . add ( annotation2 ) ; } break ; } if ( ! annotationsList . isEmpty ( ) ) { annotationsMap . put ( elementType , annotationsList ) ; } } return Collections . unmodifiableMap ( annotationsMap ) ; }
--------------------------------------------------
< ParameterPair > viablePairs ( ) { return formals . stream ( ) . flatMap ( f -> actuals . stream ( ) . map ( a -> ParameterPair . create ( f , a ) ) ) . filter ( p -> costMatrix [ p . formal ( ) . index ( ) ] [ p . actual ( ) . index ( ) ] != Double . POSITIVE_INFINITY ) ; }
--------------------------------------------------
public static Map < String , Object > getAttributes ( Annotation annotation , PropertyResolver propertyResolver , boolean ignoreDefaultValue , String ... ignoreAttributeNames ) { Set < String > ignoreAttributeNamesSet = new HashSet < String > ( arrayToList ( ignoreAttributeNames ) ) ; Map < String , Object > attributes = getAnnotationAttributes ( annotation ) ; Map < String , Object > actualAttributes = new LinkedHashMap < String , Object > ( ) ; for ( Map . Entry < String , Object > entry : attributes . entrySet ( ) ) { String attributeName = entry . getKey ( ) ; Object attributeValue = entry . getValue ( ) ; if ( ignoreDefaultValue && nullSafeEquals ( attributeValue , getDefaultValue ( annotation , attributeName ) ) ) { continue ; } if ( ignoreAttributeNamesSet . contains ( attributeName ) ) { continue ; } if ( attributeValue instanceof String ) { attributeValue = resolvePlaceholders ( valueOf ( attributeValue ) , propertyResolver ) ; } else if ( attributeValue instanceof String [ ] ) { String [ ] values = ( String [ ] ) attributeValue ; for ( int i = 0 ; i < values . length ; i ++ ) { values [ i ] = resolvePlaceholders ( values [ i ] , propertyResolver ) ; } attributeValue = values ; } actualAttributes . put ( attributeName , attributeValue ) ; } return actualAttributes ; }
--------------------------------------------------
public static ImmutableSet < String > getGeneratedBy ( ClassSymbol symbol , VisitorState state ) { checkNotNull ( symbol ) ; Optional < Compound > c = Stream . of ( 'javax.annotation.generated' , 'javax.annotation.processing.generated' ) . map ( state :: getSymbolFromString ) . filter ( a -> a != null ) . map ( symbol :: attribute ) . filter ( a -> a != null ) . findFirst ( ) ; if ( ! c . isPresent ( ) ) { return ImmutableSet . of ( ) ; } Optional < Attribute > values = c . get ( ) . getElementValues ( ) . entrySet ( ) . stream ( ) . filter ( e -> e . getKey ( ) . getSimpleName ( ) . contentEquals ( 'value' ) ) . map ( e -> e . getValue ( ) ) . findAny ( ) ; if ( ! values . isPresent ( ) ) { return ImmutableSet . of ( ) ; } ImmutableSet . Builder < String > suppressions = ImmutableSet . builder ( ) ; values . get ( ) . accept ( new SimpleAnnotationValueVisitor8 < Void , Void > ( ) { @ Override public Void visitString ( String s , Void aVoid ) { suppressions . add ( s ) ; return super . visitString ( s , aVoid ) ; } @ Override public Void visitArray ( List < ? extends AnnotationValue > vals , Void aVoid ) { vals . stream ( ) . forEachOrdered ( v -> v . accept ( this , null ) ) ; return super . visitArray ( vals , aVoid ) ; } } , null ) ; return suppressions . build ( ) ; }
--------------------------------------------------
