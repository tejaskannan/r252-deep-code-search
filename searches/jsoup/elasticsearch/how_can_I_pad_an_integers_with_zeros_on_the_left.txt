public static boolean compilesWithFix ( Fix fix , VisitorState state ) { if ( fix . isEmpty ( ) ) { return true ; } JCCompilationUnit compilationUnit = ( JCCompilationUnit ) state . getPath ( ) . getCompilationUnit ( ) ; JavaFileObject modifiedFile = compilationUnit . getSourceFile ( ) ; BasicJavacTask javacTask = ( BasicJavacTask ) state . context . get ( JavacTask . class ) ; if ( javacTask == null ) { throw new IllegalArgumentException ( 'no javactask in context.' ) ; } Arguments arguments = Arguments . instance ( javacTask . getContext ( ) ) ; List < JavaFileObject > fileObjects = new ArrayList < > ( arguments . getFileObjects ( ) ) ; for ( int i = 0 ; i < fileObjects . size ( ) ; i ++ ) { final JavaFileObject oldFile = fileObjects . get ( i ) ; if ( modifiedFile . toUri ( ) . equals ( oldFile . toUri ( ) ) ) { DescriptionBasedDiff diff = DescriptionBasedDiff . create ( compilationUnit , ImportOrganizer . STATIC_FIRST_ORGANIZER ) ; diff . handleFix ( fix ) ; SourceFile fixSource ; try { fixSource = new SourceFile ( modifiedFile . getName ( ) , modifiedFile . getCharContent ( false ) ) ; } catch ( IOException e ) { return false ; } diff . applyDifferences ( fixSource ) ; fileObjects . set ( i , new SimpleJavaFileObject ( sourceURI ( modifiedFile . toUri ( ) ) , Kind . SOURCE ) { @ Override public CharSequence getCharContent ( boolean ignoreEncodingErrors ) throws IOException { return fixSource . getAsSequence ( ) ; } } ) ; break ; } } DiagnosticCollector < JavaFileObject > diagnosticListener = new DiagnosticCollector < > ( ) ; Context context = new Context ( ) ; Options options = Options . instance ( context ) ; Options originalOptions = Options . instance ( javacTask . getContext ( ) ) ; for ( String key : originalOptions . keySet ( ) ) { String value = originalOptions . get ( key ) ; if ( key . equals ( '-xplugin:' ) && value . startsWith ( 'errorprone' ) ) { continue ; } options . put ( key , value ) ; } JavacTask newTask = JavacTool . create ( ) . getTask ( CharStreams . nullWriter ( ) , state . context . get ( JavaFileManager . class ) , diagnosticListener , ImmutableList . of ( ) , arguments . getClassNames ( ) , fileObjects , context ) ; try { newTask . analyze ( ) ; } catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } return countErrors ( diagnosticListener ) == 0 ; }
--------------------------------------------------
public void assertHasDiagnosticOnAllMatchingLines ( JavaFileObject source , LookForCheckNameInDiagnostic lookForCheckNameInDiagnostic ) throws IOException { final List < Diagnostic < ? extends JavaFileObject >> diagnostics = getDiagnostics ( ) ; final LineNumberReader reader = new LineNumberReader ( CharSource . wrap ( source . getCharContent ( false ) ) . openStream ( ) ) ; do { String line = reader . readLine ( ) ; if ( line == null ) { break ; } List < Predicate < ? super String >> predicates = null ; if ( line . contains ( BUG_MARKER_COMMENT_INLINE ) ) { List < String > patterns = extractPatterns ( line , reader , BUG_MARKER_COMMENT_INLINE ) ; predicates = new ArrayList < > ( patterns . size ( ) ) ; for ( String pattern : patterns ) { predicates . add ( new SimpleStringContains ( pattern ) ) ; } } else if ( line . contains ( BUG_MARKER_COMMENT_LOOKUP ) ) { int markerLineNumber = reader . getLineNumber ( ) ; List < String > lookupKeys = extractPatterns ( line , reader , BUG_MARKER_COMMENT_LOOKUP ) ; predicates = new ArrayList < > ( lookupKeys . size ( ) ) ; for ( String lookupKey : lookupKeys ) { assertWithMessage ( 'no expected error message with key [%s] as expected from line [%s] ' '+' 'with diagnostic [%s]' , lookupKey , markerLineNumber , line . trim ( ) ) . that ( expectedErrorMsgs . containsKey ( lookupKey ) ) . isTrue ( ) ; predicates . add ( expectedErrorMsgs . get ( lookupKey ) ) ; usedLookupKeys . add ( lookupKey ) ; } } if ( predicates != null ) { int lineNumber = reader . getLineNumber ( ) ; for ( Predicate < ? super String > predicate : predicates ) { Matcher < ? super Iterable < Diagnostic < ? extends JavaFileObject >>> patternMatcher = hasItem ( diagnosticOnLine ( source . toUri ( ) , lineNumber , predicate ) ) ; assertWithMessage ( 'did not see an error on line %s matching %s. %s' , lineNumber , predicate , allErrors ( diagnostics ) ) . that ( patternMatcher . matches ( diagnostics ) ) . isTrue ( ) ; } if ( checkName != null && lookForCheckNameInDiagnostic == LookForCheckNameInDiagnostic . YES ) { Matcher < ? super Iterable < Diagnostic < ? extends JavaFileObject >>> checkNameMatcher = hasItem ( diagnosticOnLine ( source . toUri ( ) , lineNumber , new SimpleStringContains ( '[' + checkName + ']' ) ) ) ; assertWithMessage ( 'did not see an error on line %s containing [%s]. %s' , lineNumber , checkName , allErrors ( diagnostics ) ) . that ( checkNameMatcher . matches ( diagnostics ) ) . isTrue ( ) ; } } else { int lineNumber = reader . getLineNumber ( ) ; Matcher < ? super Iterable < Diagnostic < ? extends JavaFileObject >>> matcher = hasItem ( diagnosticOnLine ( source . toUri ( ) , lineNumber ) ) ; if ( matcher . matches ( diagnostics ) ) { fail ( 'saw unexpected error on line ' + lineNumber + '. ' + allErrors ( diagnostics ) ) ; } } } while ( true ) ; reader . close ( ) ; }
--------------------------------------------------
public String getDescription ( ) { return 'the parameters of this method are inconsistent with other overloaded versions.' '+' ' a consistent order would be: ' + getSuggestedSignature ( ) ; }
--------------------------------------------------
public Violation threadSafeInstantiation ( Set < String > containerTypeParameters , AnnotationInfo annotation , Type type ) { if ( ! annotation . containerOf ( ) . isEmpty ( ) && type . tsym . getTypeParameters ( ) . size ( ) != type . getTypeArguments ( ) . size ( ) ) { return Violation . of ( String . format ( ''%s' required instantiation of '%s' with type parameters, but was raw' , getPrettyName ( type . tsym ) , Joiner . on ( ', ' ) . join ( annotation . containerOf ( ) ) ) ) ; } for ( int i = 0 ; i < type . tsym . getTypeParameters ( ) . size ( ) ; i ++ ) { TypeVariableSymbol typaram = type . tsym . getTypeParameters ( ) . get ( i ) ; boolean immutableTypeParameter = hasThreadSafeTypeParameterAnnotation ( typaram ) ; if ( annotation . containerOf ( ) . contains ( typaram . getSimpleName ( ) . toString ( ) ) || immutableTypeParameter ) { Type tyarg = type . getTypeArguments ( ) . get ( i ) ; if ( suppressAnnotation != null && tyarg . getAnnotationMirrors ( ) . stream ( ) . anyMatch ( a -> ( ( ClassSymbol ) a . getAnnotationType ( ) . asElement ( ) ) . flatName ( ) . contentEquals ( suppressAnnotation . getName ( ) ) ) ) { continue ; } Violation info = isThreadSafeType ( ! immutableTypeParameter , containerTypeParameters , tyarg ) ; if ( info . isPresent ( ) ) { return info . plus ( String . format ( ''%s' was instantiated with %s type for '%s'' , getPrettyName ( type . tsym ) , purpose . mutableOrNonThreadSafe ( ) , typaram . getSimpleName ( ) ) ) ; } } } return Violation . absent ( ) ; }
--------------------------------------------------
public static String bytes2base64 ( final byte [ ] bs , final int off , final int len , final char [ ] code ) { if ( off < 0 ) { throw new IndexOutOfBoundsException ( 'bytes2base64: offset < 0, offset is ' + off ) ; } if ( len < 0 ) { throw new IndexOutOfBoundsException ( 'bytes2base64: length < 0, length is ' + len ) ; } if ( off + len > bs . length ) { throw new IndexOutOfBoundsException ( 'bytes2base64: offset + length > array length.' ) ; } if ( code . length < 64 ) { throw new IllegalArgumentException ( 'base64 code length < 64.' ) ; } boolean pad = code . length > 64 ; int num = len / 3 , rem = len % 3 , r = off , w = 0 ; char [ ] cs = new char [ num * 4 + ( rem == 0 ? 0 : pad ? 4 : rem + 1 ) ] ; for ( int i = 0 ; i < num ; i ++ ) { int b1 = bs [ r ++ ] & MASK8 , b2 = bs [ r ++ ] & MASK8 , b3 = bs [ r ++ ] & MASK8 ; cs [ w ++ ] = code [ b1 >> 2 ] ; cs [ w ++ ] = code [ ( b1 << 4 ) & MASK6 | ( b2 >> 4 ) ] ; cs [ w ++ ] = code [ ( b2 << 2 ) & MASK6 | ( b3 >> 6 ) ] ; cs [ w ++ ] = code [ b3 & MASK6 ] ; } if ( rem == 1 ) { int b1 = bs [ r ++ ] & MASK8 ; cs [ w ++ ] = code [ b1 >> 2 ] ; cs [ w ++ ] = code [ ( b1 << 4 ) & MASK6 ] ; if ( pad ) { cs [ w ++ ] = code [ 64 ] ; cs [ w ++ ] = code [ 64 ] ; } } else if ( rem == 2 ) { int b1 = bs [ r ++ ] & MASK8 , b2 = bs [ r ++ ] & MASK8 ; cs [ w ++ ] = code [ b1 >> 2 ] ; cs [ w ++ ] = code [ ( b1 << 4 ) & MASK6 | ( b2 >> 4 ) ] ; cs [ w ++ ] = code [ ( b2 << 2 ) & MASK6 ] ; if ( pad ) { cs [ w ++ ] = code [ 64 ] ; } } return new String ( cs ) ; }
--------------------------------------------------
private BeanNameGenerator resolveBeanNameGenerator ( BeanDefinitionRegistry registry ) { BeanNameGenerator beanNameGenerator = null ; if ( registry instanceof SingletonBeanRegistry ) { SingletonBeanRegistry singletonBeanRegistry = SingletonBeanRegistry . class . cast ( registry ) ; beanNameGenerator = ( BeanNameGenerator ) singletonBeanRegistry . getSingleton ( CONFIGURATION_BEAN_NAME_GENERATOR ) ; } if ( beanNameGenerator == null ) { if ( logger . isInfoEnabled ( ) ) { logger . info ( 'beannamegenerator bean can't be found in beanfactory with name [' + CONFIGURATION_BEAN_NAME_GENERATOR + ']' ) ; logger . info ( 'beannamegenerator will be a instance of ' + AnnotationBeanNameGenerator . class . getName ( ) + ' , it maybe a potential problem on bean name generation.' ) ; } beanNameGenerator = new AnnotationBeanNameGenerator ( ) ; } return beanNameGenerator ; }
--------------------------------------------------
private void registerServiceBean ( BeanDefinitionHolder beanDefinitionHolder , BeanDefinitionRegistry registry , DubboClassPathBeanDefinitionScanner scanner ) { Class < ? > beanClass = resolveClass ( beanDefinitionHolder ) ; Service service = findAnnotation ( beanClass , Service . class ) ; Class < ? > interfaceClass = resolveServiceInterfaceClass ( beanClass , service ) ; String annotatedServiceBeanName = beanDefinitionHolder . getBeanName ( ) ; AbstractBeanDefinition serviceBeanDefinition = buildServiceBeanDefinition ( service , interfaceClass , annotatedServiceBeanName ) ; String beanName = generateServiceBeanName ( service , interfaceClass , annotatedServiceBeanName ) ; if ( scanner . checkCandidate ( beanName , serviceBeanDefinition ) ) { registry . registerBeanDefinition ( beanName , serviceBeanDefinition ) ; if ( logger . isInfoEnabled ( ) ) { logger . info ( 'the beandefinition[' + serviceBeanDefinition + '] of servicebean has been registered with name : ' + beanName ) ; } } else { if ( logger . isWarnEnabled ( ) ) { logger . warn ( 'the duplicated beandefinition[' + serviceBeanDefinition + '] of servicebean[ bean name : ' + beanName + '] was be found , did @dubbocomponentscan scan to same package in many times?' ) ; } } }
--------------------------------------------------
public String generate ( ) { if ( ! hasAdaptiveMethod ( ) ) { throw new IllegalStateException ( 'no adaptive method exist on extension ' + type . getName ( ) + ', refuse to create the adaptive class!' ) ; } StringBuilder code = new StringBuilder ( ) ; code . append ( generatePackageInfo ( ) ) ; code . append ( generateImports ( ) ) ; code . append ( generateClassDeclaration ( ) ) ; Method [ ] methods = type . getMethods ( ) ; for ( Method method : methods ) { code . append ( generateMethod ( method ) ) ; } code . append ( '}' ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( code . toString ( ) ) ; } return code . toString ( ) ; }
--------------------------------------------------
private BeanNameGenerator resolveBeanNameGenerator ( BeanDefinitionRegistry registry ) { BeanNameGenerator beanNameGenerator = null ; if ( registry instanceof SingletonBeanRegistry ) { SingletonBeanRegistry singletonBeanRegistry = SingletonBeanRegistry . class . cast ( registry ) ; beanNameGenerator = ( BeanNameGenerator ) singletonBeanRegistry . getSingleton ( CONFIGURATION_BEAN_NAME_GENERATOR ) ; } if ( beanNameGenerator == null ) { if ( logger . isInfoEnabled ( ) ) { logger . info ( 'beannamegenerator bean can't be found in beanfactory with name [' + CONFIGURATION_BEAN_NAME_GENERATOR + ']' ) ; logger . info ( 'beannamegenerator will be a instance of ' + AnnotationBeanNameGenerator . class . getName ( ) + ' , it maybe a potential problem on bean name generation.' ) ; } beanNameGenerator = new AnnotationBeanNameGenerator ( ) ; } return beanNameGenerator ; }
--------------------------------------------------
private void registerServiceBean ( BeanDefinitionHolder beanDefinitionHolder , BeanDefinitionRegistry registry , DubboClassPathBeanDefinitionScanner scanner ) { Class < ? > beanClass = resolveClass ( beanDefinitionHolder ) ; Service service = findAnnotation ( beanClass , Service . class ) ; Class < ? > interfaceClass = resolveServiceInterfaceClass ( beanClass , service ) ; String annotatedServiceBeanName = beanDefinitionHolder . getBeanName ( ) ; AbstractBeanDefinition serviceBeanDefinition = buildServiceBeanDefinition ( service , interfaceClass , annotatedServiceBeanName ) ; String beanName = generateServiceBeanName ( service , interfaceClass , annotatedServiceBeanName ) ; if ( scanner . checkCandidate ( beanName , serviceBeanDefinition ) ) { registry . registerBeanDefinition ( beanName , serviceBeanDefinition ) ; if ( logger . isInfoEnabled ( ) ) { logger . warn ( 'the beandefinition[' + serviceBeanDefinition + '] of servicebean has been registered with name : ' + beanName ) ; } } else { if ( logger . isWarnEnabled ( ) ) { logger . warn ( 'the duplicated beandefinition[' + serviceBeanDefinition + '] of servicebean[ bean name : ' + beanName + '] was be found , did @compatibledubbocomponentscan scan to same package in many times?' ) ; } } }
--------------------------------------------------
