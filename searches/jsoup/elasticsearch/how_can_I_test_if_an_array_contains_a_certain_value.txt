public static boolean containsTestMethod ( Tree tree ) { return firstNonNull ( tree . accept ( new TreeScanner < Boolean , Void > ( ) { @ Override public Boolean visitMethodInvocation ( MethodInvocationTree node , Void unused ) { String name = getSymbol ( node ) . getSimpleName ( ) . toString ( ) ; return name . contains ( 'assert' ) || name . contains ( 'verify' ) || name . contains ( 'check' ) || name . contains ( 'fail' ) || name . contains ( 'expect' ) || firstNonNull ( super . visitMethodInvocation ( node , null ) , false ) ; } @ Override public Boolean reduce ( Boolean a , Boolean b ) { return firstNonNull ( a , false ) || firstNonNull ( b , false ) ; } } , null ) , false ) ; }
--------------------------------------------------
static FormattingTuple arrayFormat ( final String messagePattern , final Object [ ] argArray ) { Throwable throwableCandidate = getThrowableCandidate ( argArray ) ; if ( messagePattern == null ) { return new FormattingTuple ( null , argArray , throwableCandidate ) ; } if ( argArray == null ) { return new FormattingTuple ( messagePattern ) ; } int i = 0 ; int j ; StringBuffer sbuf = new StringBuffer ( messagePattern . length ( ) + 50 ) ; int l ; for ( l = 0 ; l < argArray . length ; l ++ ) { j = messagePattern . indexOf ( DELIM_STR , i ) ; if ( j == - 1 ) { if ( i == 0 ) { return new FormattingTuple ( messagePattern , argArray , throwableCandidate ) ; } else { sbuf . append ( messagePattern . substring ( i , messagePattern . length ( ) ) ) ; return new FormattingTuple ( sbuf . toString ( ) , argArray , throwableCandidate ) ; } } else { if ( isEscapedDelimeter ( messagePattern , j ) ) { if ( ! isDoubleEscaped ( messagePattern , j ) ) { l -- ; sbuf . append ( messagePattern . substring ( i , j - 1 ) ) ; sbuf . append ( DELIM_START ) ; i = j + 1 ; } else { sbuf . append ( messagePattern . substring ( i , j - 1 ) ) ; deeplyAppendParameter ( sbuf , argArray [ l ] , new HashMap < Object [ ] , Void > ( ) ) ; i = j + 2 ; } } else { sbuf . append ( messagePattern . substring ( i , j ) ) ; deeplyAppendParameter ( sbuf , argArray [ l ] , new HashMap < Object [ ] , Void > ( ) ) ; i = j + 2 ; } } } sbuf . append ( messagePattern . substring ( i , messagePattern . length ( ) ) ) ; if ( l < argArray . length - 1 ) { return new FormattingTuple ( sbuf . toString ( ) , argArray , throwableCandidate ) ; } else { return new FormattingTuple ( sbuf . toString ( ) , argArray , null ) ; } }
--------------------------------------------------
public static Optional < Integer > asIntegerValue ( Attribute a ) { class Visitor extends SimpleAnnotationValueVisitor8 < Integer , Void > { @ Override public Integer visitInt ( int i , Void unused ) { return i ; } } return Optional . ofNullable ( a . accept ( new Visitor ( ) , null ) ) ; }
--------------------------------------------------
public static boolean methodCanBeOverridden ( MethodSymbol methodSymbol ) { if ( methodSymbol . getModifiers ( ) . contains ( Modifier . ABSTRACT ) ) { return true ; } if ( methodSymbol . isStatic ( ) || methodSymbol . isPrivate ( ) || isFinal ( methodSymbol ) || methodSymbol . isConstructor ( ) ) { return false ; } ClassSymbol classSymbol = ( ClassSymbol ) methodSymbol . owner ; return ! isFinal ( classSymbol ) && ! classSymbol . isAnonymous ( ) ; }
--------------------------------------------------
static boolean expectedExceptionTest ( Tree tree , VisitorState state ) { if ( mockitoInvocation ( tree , state ) ) { return true ; } StatementTree statement = ASTHelpers . findEnclosingNode ( state . getPath ( ) , StatementTree . class ) ; if ( statement != null && EXPECTED_EXCEPTION_MATCHER . matches ( statement , state ) ) { return true ; } return false ; }
--------------------------------------------------
public static boolean isContains ( String [ ] values , String value ) { if ( isNotEmpty ( value ) && ArrayUtils . isNotEmpty ( values ) ) { for ( String v : values ) { if ( value . equals ( v ) ) { return true ; } } } return false ; }
--------------------------------------------------
public static boolean canCompleteNormally ( CaseTree caseTree ) { List < ? extends StatementTree > statements = caseTree . getStatements ( ) ; if ( statements . isEmpty ( ) ) { return true ; } return canCompleteNormally ( getLast ( statements ) ) ; }
--------------------------------------------------
private static Class < ? > [ ] desc2classArray ( ClassLoader cl , String desc ) throws ClassNotFoundException { if ( desc . length ( ) == 0 ) { return EMPTY_CLASS_ARRAY ; } List < Class < ? >> cs = new ArrayList < Class < ? >> ( ) ; Matcher m = DESC_PATTERN . matcher ( desc ) ; while ( m . find ( ) ) { cs . add ( desc2class ( cl , m . group ( ) ) ) ; } return cs . toArray ( EMPTY_CLASS_ARRAY ) ; }
--------------------------------------------------
private static boolean isExpectedExceptionTest ( MethodSymbol sym , VisitorState state ) { Compound attribute = sym . attribute ( state . getSymbolFromString ( JUnitMatchers . JUNIT4_TEST_ANNOTATION ) ) ; if ( attribute == null ) { return false ; } return attribute . member ( state . getName ( 'expected' ) ) != null ; }
--------------------------------------------------
private static Map < String , String > parseKeyValuePair ( String str , String itemSeparator ) { String [ ] tmp = str . split ( itemSeparator ) ; Map < String , String > map = new HashMap < String , String > ( tmp . length ) ; for ( int i = 0 ; i < tmp . length ; i ++ ) { Matcher matcher = KVP_PATTERN . matcher ( tmp [ i ] ) ; if ( ! matcher . matches ( ) ) { continue ; } map . put ( matcher . group ( 1 ) , matcher . group ( 2 ) ) ; } return map ; }
--------------------------------------------------
