public String consumeToAny ( final char ... chars ) { bufferUp ( ) ; int pos = bufPos ; final int start = pos ; final int remaining = bufLength ; final char [ ] val = charBuf ; final int charLen = chars . length ; int i ; OUTER : while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) break OUTER ; } pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : '' ; }
--------------------------------------------------
public static String [ ] split ( String str , char ch ) { List < String > list = null ; char c ; int ix = 0 , len = str . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { c = str . charAt ( i ) ; if ( c == ch ) { if ( list == null ) { list = new ArrayList < String > ( ) ; } list . add ( str . substring ( ix , i ) ) ; ix = i + 1 ; } } if ( ix > 0 ) { list . add ( str . substring ( ix ) ) ; } return list == null ? EMPTY_STRING_ARRAY : ( String [ ] ) list . toArray ( EMPTY_STRING_ARRAY ) ; }
--------------------------------------------------
public static Optional < Integer > asIntegerValue ( Attribute a ) { class Visitor extends SimpleAnnotationValueVisitor8 < Integer , Void > { @ Override public Integer visitInt ( int i , Void unused ) { return i ; } } return Optional . ofNullable ( a . accept ( new Visitor ( ) , null ) ) ; }
--------------------------------------------------
public static Stream < String > asStrings ( Attribute v ) { return MoreObjects . firstNonNull ( v . accept ( new SimpleAnnotationValueVisitor8 < Stream < String > , Void > ( ) { @ Override public Stream < String > visitString ( String s , Void unused ) { return Stream . of ( s ) ; } @ Override public Stream < String > visitArray ( List < ? extends AnnotationValue > list , Void unused ) { return list . stream ( ) . flatMap ( a -> a . accept ( this , null ) ) . filter ( x -> x != null ) ; } } , null ) , Stream . empty ( ) ) ; }
--------------------------------------------------
public static Optional < String > asStringValue ( Attribute a ) { class Visitor extends SimpleAnnotationValueVisitor8 < String , Void > { @ Override public String visitString ( String s , Void unused ) { return s ; } } return Optional . ofNullable ( a . accept ( new Visitor ( ) , null ) ) ; }
--------------------------------------------------
public boolean matchesAny ( String ... seq ) { for ( String s : seq ) { if ( matches ( s ) ) return true ; } return false ; }
--------------------------------------------------
public static < T extends Enum < T >> Optional < T > asEnumValue ( Class < T > clazz , Attribute a ) { class Visitor extends SimpleAnnotationValueVisitor8 < T , Void > { @ Override public T visitEnumConstant ( VariableElement c , Void unused ) { return Enum . valueOf ( clazz , c . getSimpleName ( ) . toString ( ) ) ; } } return Optional . ofNullable ( a . accept ( new Visitor ( ) , null ) ) ; }
--------------------------------------------------
public void replaceChars ( int startPosition , int endPosition , String replacement ) { try { sourceBuilder . replace ( startPosition , endPosition , replacement ) ; } catch ( StringIndexOutOfBoundsException e ) { throw new IndexOutOfBoundsException ( String . format ( 'replacement cannot be made. source file %s has length %d, requested start ' '+' 'position %d, requested end position %d, replacement %s' , path , sourceBuilder . length ( ) , startPosition , endPosition , replacement ) ) ; } }
--------------------------------------------------
protected void doParse ( Element element , ParserContext parserContext , BeanDefinitionBuilder builder ) { String packageToScan = element . getAttribute ( 'package' ) ; String [ ] packagesToScan = trimArrayElements ( commaDelimitedListToStringArray ( packageToScan ) ) ; builder . addConstructorArgValue ( packagesToScan ) ; builder . setRole ( BeanDefinition . ROLE_INFRASTRUCTURE ) ; registerReferenceAnnotationBeanPostProcessor ( parserContext . getRegistry ( ) ) ; }
--------------------------------------------------
public static boolean compilesWithFix ( Fix fix , VisitorState state ) { if ( fix . isEmpty ( ) ) { return true ; } JCCompilationUnit compilationUnit = ( JCCompilationUnit ) state . getPath ( ) . getCompilationUnit ( ) ; JavaFileObject modifiedFile = compilationUnit . getSourceFile ( ) ; BasicJavacTask javacTask = ( BasicJavacTask ) state . context . get ( JavacTask . class ) ; if ( javacTask == null ) { throw new IllegalArgumentException ( 'no javactask in context.' ) ; } Arguments arguments = Arguments . instance ( javacTask . getContext ( ) ) ; List < JavaFileObject > fileObjects = new ArrayList < > ( arguments . getFileObjects ( ) ) ; for ( int i = 0 ; i < fileObjects . size ( ) ; i ++ ) { final JavaFileObject oldFile = fileObjects . get ( i ) ; if ( modifiedFile . toUri ( ) . equals ( oldFile . toUri ( ) ) ) { DescriptionBasedDiff diff = DescriptionBasedDiff . create ( compilationUnit , ImportOrganizer . STATIC_FIRST_ORGANIZER ) ; diff . handleFix ( fix ) ; SourceFile fixSource ; try { fixSource = new SourceFile ( modifiedFile . getName ( ) , modifiedFile . getCharContent ( false ) ) ; } catch ( IOException e ) { return false ; } diff . applyDifferences ( fixSource ) ; fileObjects . set ( i , new SimpleJavaFileObject ( sourceURI ( modifiedFile . toUri ( ) ) , Kind . SOURCE ) { @ Override public CharSequence getCharContent ( boolean ignoreEncodingErrors ) throws IOException { return fixSource . getAsSequence ( ) ; } } ) ; break ; } } DiagnosticCollector < JavaFileObject > diagnosticListener = new DiagnosticCollector < > ( ) ; Context context = new Context ( ) ; Options options = Options . instance ( context ) ; Options originalOptions = Options . instance ( javacTask . getContext ( ) ) ; for ( String key : originalOptions . keySet ( ) ) { String value = originalOptions . get ( key ) ; if ( key . equals ( '-xplugin:' ) && value . startsWith ( 'errorprone' ) ) { continue ; } options . put ( key , value ) ; } JavacTask newTask = JavacTool . create ( ) . getTask ( CharStreams . nullWriter ( ) , state . context . get ( JavaFileManager . class ) , diagnosticListener , ImmutableList . of ( ) , arguments . getClassNames ( ) , fileObjects , context ) ; try { newTask . analyze ( ) ; } catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } return countErrors ( diagnosticListener ) == 0 ; }
--------------------------------------------------
