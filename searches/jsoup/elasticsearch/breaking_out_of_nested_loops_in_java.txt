public static String unescape ( String in ) { StringBuilder out = StringUtil . borrowBuilder ( ) ; char last = 0 ; for ( char c : in . toCharArray ( ) ) { if ( c == ESC ) { if ( last != 0 && last == ESC ) out . append ( c ) ; } else out . append ( c ) ; last = c ; } return StringUtil . releaseBuilder ( out ) ; }
--------------------------------------------------
public Set < String > threadSafeTypeParametersInScope ( Symbol sym ) { if ( sym == null ) { return ImmutableSet . of ( ) ; } ImmutableSet . Builder < String > result = ImmutableSet . builder ( ) ; OUTER : for ( Symbol s = sym ; s . owner != null ; s = s . owner ) { switch ( s . getKind ( ) ) { case INSTANCE_INIT : continue ; case PACKAGE : break OUTER ; default : break ; } AnnotationInfo annotation = getMarkerOrAcceptedAnnotation ( s , state ) ; if ( annotation == null ) { continue ; } for ( TypeVariableSymbol typaram : s . getTypeParameters ( ) ) { String name = typaram . getSimpleName ( ) . toString ( ) ; if ( annotation . containerOf ( ) . contains ( name ) ) { result . add ( name ) ; } } if ( s . isStatic ( ) ) { break ; } } return result . build ( ) ; }
--------------------------------------------------
private static ImmutableSet < String > immutableTypeParametersInScope ( Symbol sym , VisitorState state , ImmutableAnalysis analysis ) { if ( sym == null ) { return ImmutableSet . of ( ) ; } ImmutableSet . Builder < String > result = ImmutableSet . builder ( ) ; OUTER : for ( Symbol s = sym ; s . owner != null ; s = s . owner ) { switch ( s . getKind ( ) ) { case INSTANCE_INIT : continue ; case PACKAGE : break OUTER ; default : break ; } AnnotationInfo annotation = analysis . getImmutableAnnotation ( s , state ) ; if ( annotation == null ) { continue ; } for ( TypeVariableSymbol typaram : s . getTypeParameters ( ) ) { String name = typaram . getSimpleName ( ) . toString ( ) ; if ( annotation . containerOf ( ) . contains ( name ) ) { result . add ( name ) ; } } if ( s . isStatic ( ) ) { break ; } } return result . build ( ) ; }
--------------------------------------------------
public Result invoke ( Invoker < ? > invoker , Invocation inv ) throws RpcException { try { String accessLogKey = invoker . getUrl ( ) . getParameter ( Constants . ACCESS_LOG_KEY ) ; if ( ConfigUtils . isNotEmpty ( accessLogKey ) ) { AccessLogData logData = buildAccessLogData ( invoker , inv ) ; log ( accessLogKey , logData ) ; } } catch ( Throwable t ) { logger . warn ( 'exception in acesslogfilter of service(' + invoker + ' -> ' + inv + ')' , t ) ; } return invoker . invoke ( inv ) ; }
--------------------------------------------------
private String buildMessage ( GuardedByExpression guard , HeldLockSet locks ) { int heldLocks = locks . allLocks ( ) . size ( ) ; StringBuilder message = new StringBuilder ( ) ; Select enclosing = findOuterInstance ( guard ) ; if ( enclosing != null && ! enclosingInstance ( guard ) ) { if ( guard == enclosing ) { message . append ( String . format ( 'access should be guarded by enclosing instance '%s' of '%s',' '+' ' which is not accessible in this scope' , enclosing . sym ( ) . owner , enclosing . base ( ) ) ) ; } else { message . append ( String . format ( 'access should be guarded by '%s' in enclosing instance '%s' of '%s',' '+' ' which is not accessible in this scope' , guard . sym ( ) , enclosing . sym ( ) . owner , enclosing . base ( ) ) ) ; } if ( heldLocks > 0 ) { message . append ( String . format ( '; instead found: '%s'' , Joiner . on ( '', '' ) . join ( locks . allLocks ( ) ) ) ) ; } return message . toString ( ) ; } message . append ( String . format ( 'this access should be guarded by '%s'' , guard ) ) ; if ( guard . kind ( ) == GuardedByExpression . Kind . ERROR ) { message . append ( ', which could not be resolved' ) ; return message . toString ( ) ; } if ( heldLocks == 0 ) { message . append ( ', which is not currently held' ) ; } else { message . append ( String . format ( '; instead found: '%s'' , Joiner . on ( '', '' ) . join ( locks . allLocks ( ) ) ) ) ; } return message . toString ( ) ; }
--------------------------------------------------
private BeanNameGenerator resolveBeanNameGenerator ( BeanDefinitionRegistry registry ) { BeanNameGenerator beanNameGenerator = null ; if ( registry instanceof SingletonBeanRegistry ) { SingletonBeanRegistry singletonBeanRegistry = SingletonBeanRegistry . class . cast ( registry ) ; beanNameGenerator = ( BeanNameGenerator ) singletonBeanRegistry . getSingleton ( CONFIGURATION_BEAN_NAME_GENERATOR ) ; } if ( beanNameGenerator == null ) { if ( logger . isInfoEnabled ( ) ) { logger . info ( 'beannamegenerator bean can't be found in beanfactory with name [' + CONFIGURATION_BEAN_NAME_GENERATOR + ']' ) ; logger . info ( 'beannamegenerator will be a instance of ' + AnnotationBeanNameGenerator . class . getName ( ) + ' , it maybe a potential problem on bean name generation.' ) ; } beanNameGenerator = new AnnotationBeanNameGenerator ( ) ; } return beanNameGenerator ; }
--------------------------------------------------
private void registerServiceBean ( BeanDefinitionHolder beanDefinitionHolder , BeanDefinitionRegistry registry , DubboClassPathBeanDefinitionScanner scanner ) { Class < ? > beanClass = resolveClass ( beanDefinitionHolder ) ; Service service = findAnnotation ( beanClass , Service . class ) ; Class < ? > interfaceClass = resolveServiceInterfaceClass ( beanClass , service ) ; String annotatedServiceBeanName = beanDefinitionHolder . getBeanName ( ) ; AbstractBeanDefinition serviceBeanDefinition = buildServiceBeanDefinition ( service , interfaceClass , annotatedServiceBeanName ) ; String beanName = generateServiceBeanName ( service , interfaceClass , annotatedServiceBeanName ) ; if ( scanner . checkCandidate ( beanName , serviceBeanDefinition ) ) { registry . registerBeanDefinition ( beanName , serviceBeanDefinition ) ; if ( logger . isInfoEnabled ( ) ) { logger . warn ( 'the beandefinition[' + serviceBeanDefinition + '] of servicebean has been registered with name : ' + beanName ) ; } } else { if ( logger . isWarnEnabled ( ) ) { logger . warn ( 'the duplicated beandefinition[' + serviceBeanDefinition + '] of servicebean[ bean name : ' + beanName + '] was be found , did @compatibledubbocomponentscan scan to same package in many times?' ) ; } } }
--------------------------------------------------
private BeanNameGenerator resolveBeanNameGenerator ( BeanDefinitionRegistry registry ) { BeanNameGenerator beanNameGenerator = null ; if ( registry instanceof SingletonBeanRegistry ) { SingletonBeanRegistry singletonBeanRegistry = SingletonBeanRegistry . class . cast ( registry ) ; beanNameGenerator = ( BeanNameGenerator ) singletonBeanRegistry . getSingleton ( CONFIGURATION_BEAN_NAME_GENERATOR ) ; } if ( beanNameGenerator == null ) { if ( logger . isInfoEnabled ( ) ) { logger . info ( 'beannamegenerator bean can't be found in beanfactory with name [' + CONFIGURATION_BEAN_NAME_GENERATOR + ']' ) ; logger . info ( 'beannamegenerator will be a instance of ' + AnnotationBeanNameGenerator . class . getName ( ) + ' , it maybe a potential problem on bean name generation.' ) ; } beanNameGenerator = new AnnotationBeanNameGenerator ( ) ; } return beanNameGenerator ; }
--------------------------------------------------
private void registerServiceBean ( BeanDefinitionHolder beanDefinitionHolder , BeanDefinitionRegistry registry , DubboClassPathBeanDefinitionScanner scanner ) { Class < ? > beanClass = resolveClass ( beanDefinitionHolder ) ; Service service = findAnnotation ( beanClass , Service . class ) ; Class < ? > interfaceClass = resolveServiceInterfaceClass ( beanClass , service ) ; String annotatedServiceBeanName = beanDefinitionHolder . getBeanName ( ) ; AbstractBeanDefinition serviceBeanDefinition = buildServiceBeanDefinition ( service , interfaceClass , annotatedServiceBeanName ) ; String beanName = generateServiceBeanName ( service , interfaceClass , annotatedServiceBeanName ) ; if ( scanner . checkCandidate ( beanName , serviceBeanDefinition ) ) { registry . registerBeanDefinition ( beanName , serviceBeanDefinition ) ; if ( logger . isInfoEnabled ( ) ) { logger . info ( 'the beandefinition[' + serviceBeanDefinition + '] of servicebean has been registered with name : ' + beanName ) ; } } else { if ( logger . isWarnEnabled ( ) ) { logger . warn ( 'the duplicated beandefinition[' + serviceBeanDefinition + '] of servicebean[ bean name : ' + beanName + '] was be found , did @dubbocomponentscan scan to same package in many times?' ) ; } } }
--------------------------------------------------
private String generateUrlAssignmentIndirectly ( Method method ) { Class < ? > [ ] pts = method . getParameterTypes ( ) ; for ( int i = 0 ; i < pts . length ; ++ i ) { for ( Method m : pts [ i ] . getMethods ( ) ) { String name = m . getName ( ) ; if ( ( name . startsWith ( 'get' ) || name . length ( ) > 3 ) && Modifier . isPublic ( m . getModifiers ( ) ) && ! Modifier . isStatic ( m . getModifiers ( ) ) && m . getParameterTypes ( ) . length == 0 && m . getReturnType ( ) == URL . class ) { return generateGetUrlNullCheck ( i , pts [ i ] , name ) ; } } } throw new IllegalStateException ( 'failed to create adaptive class for interface ' + type . getName ( ) + ': not found url parameter or url attribute in parameters of method ' + method . getName ( ) ) ; }
--------------------------------------------------
