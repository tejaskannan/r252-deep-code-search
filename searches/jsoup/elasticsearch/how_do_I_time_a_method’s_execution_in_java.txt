private static < A extends AbstractValue < A > , S extends Store < S > , T extends TransferFunction < A , S >> Result < A , S , T > methodDataflow ( TreePath methodPath , Context context , T transfer ) { final ProcessingEnvironment env = JavacProcessingEnvironment . instance ( context ) ; final ControlFlowGraph cfg ; try { cfg = cfgCache . getUnchecked ( CfgParams . create ( methodPath , env ) ) ; } catch ( UncheckedExecutionException e ) { throw e . getCause ( ) instanceof CompletionFailure ? ( CompletionFailure ) e . getCause ( ) : e ; } final AnalysisParams aparams = AnalysisParams . create ( transfer , cfg , env ) ; @ SuppressWarnings ( 'unchecked' ) final Analysis < A , S , T > analysis = ( Analysis < A , S , T > ) analysisCache . getUnchecked ( aparams ) ; return new Result < A , S , T > ( ) { @ Override public Analysis < A , S , T > getAnalysis ( ) { return analysis ; } @ Override public ControlFlowGraph getControlFlowGraph ( ) { return cfg ; } } ; }
--------------------------------------------------
public static boolean isJavaIdentifier ( String s ) { if ( isEmpty ( s ) || ! Character . isJavaIdentifierStart ( s . charAt ( 0 ) ) ) { return false ; } for ( int i = 1 ; i < s . length ( ) ; i ++ ) { if ( ! Character . isJavaIdentifierPart ( s . charAt ( i ) ) ) { return false ; } } return true ; }
--------------------------------------------------
public static Method findMethodByMethodSignature ( Class < ? > clazz , String methodName , String [ ] parameterTypes ) throws NoSuchMethodException , ClassNotFoundException { String signature = clazz . getName ( ) + '.' + methodName ; if ( parameterTypes != null && parameterTypes . length > 0 ) { signature += StringUtils . join ( parameterTypes ) ; } Method method = Signature_METHODS_CACHE . get ( signature ) ; if ( method != null ) { return method ; } if ( parameterTypes == null ) { List < Method > finded = new ArrayList < Method > ( ) ; for ( Method m : clazz . getMethods ( ) ) { if ( m . getName ( ) . equals ( methodName ) ) { finded . add ( m ) ; } } if ( finded . isEmpty ( ) ) { throw new NoSuchMethodException ( 'no such method ' + methodName + ' in class ' + clazz ) ; } if ( finded . size ( ) > 1 ) { String msg = String . format ( 'not unique method for method name(%s) in class(%s), find %d methods.' , methodName , clazz . getName ( ) , finded . size ( ) ) ; throw new IllegalStateException ( msg ) ; } method = finded . get ( 0 ) ; } else { Class < ? > [ ] types = new Class < ? > [ parameterTypes . length ] ; for ( int i = 0 ; i < parameterTypes . length ; i ++ ) { types [ i ] = ReflectUtils . name2class ( parameterTypes [ i ] ) ; } method = clazz . getMethod ( methodName , types ) ; } Signature_METHODS_CACHE . put ( signature , method ) ; return method ; }
--------------------------------------------------
public static < T extends Tree > Matcher < T > inLoop ( ) { return new Matcher < T > ( ) { @ Override public boolean matches ( Tree tree , VisitorState state ) { TreePath path = state . getPath ( ) . getParentPath ( ) ; Tree node = path . getLeaf ( ) ; while ( path != null ) { switch ( node . getKind ( ) ) { case METHOD : case CLASS : return false ; case WHILE_LOOP : case FOR_LOOP : case ENHANCED_FOR_LOOP : case DO_WHILE_LOOP : return true ; default : path = path . getParentPath ( ) ; node = path . getLeaf ( ) ; break ; } } return false ; } } ; }
--------------------------------------------------
public Set < String > threadSafeTypeParametersInScope ( Symbol sym ) { if ( sym == null ) { return ImmutableSet . of ( ) ; } ImmutableSet . Builder < String > result = ImmutableSet . builder ( ) ; OUTER : for ( Symbol s = sym ; s . owner != null ; s = s . owner ) { switch ( s . getKind ( ) ) { case INSTANCE_INIT : continue ; case PACKAGE : break OUTER ; default : break ; } AnnotationInfo annotation = getMarkerOrAcceptedAnnotation ( s , state ) ; if ( annotation == null ) { continue ; } for ( TypeVariableSymbol typaram : s . getTypeParameters ( ) ) { String name = typaram . getSimpleName ( ) . toString ( ) ; if ( annotation . containerOf ( ) . contains ( name ) ) { result . add ( name ) ; } } if ( s . isStatic ( ) ) { break ; } } return result . build ( ) ; }
--------------------------------------------------
private static ImmutableSet < String > immutableTypeParametersInScope ( Symbol sym , VisitorState state , ImmutableAnalysis analysis ) { if ( sym == null ) { return ImmutableSet . of ( ) ; } ImmutableSet . Builder < String > result = ImmutableSet . builder ( ) ; OUTER : for ( Symbol s = sym ; s . owner != null ; s = s . owner ) { switch ( s . getKind ( ) ) { case INSTANCE_INIT : continue ; case PACKAGE : break OUTER ; default : break ; } AnnotationInfo annotation = analysis . getImmutableAnnotation ( s , state ) ; if ( annotation == null ) { continue ; } for ( TypeVariableSymbol typaram : s . getTypeParameters ( ) ) { String name = typaram . getSimpleName ( ) . toString ( ) ; if ( annotation . containerOf ( ) . contains ( name ) ) { result . add ( name ) ; } } if ( s . isStatic ( ) ) { break ; } } return result . build ( ) ; }
--------------------------------------------------
private String generateMethodArguments ( Method method ) { Class < ? > [ ] pts = method . getParameterTypes ( ) ; return IntStream . range ( 0 , pts . length ) . mapToObj ( i -> String . format ( CODE_METHOD_ARGUMENT , pts [ i ] . getCanonicalName ( ) , i ) ) . collect ( Collectors . joining ( ', ' ) ) ; }
--------------------------------------------------
public static boolean containsTestMethod ( Tree tree ) { return firstNonNull ( tree . accept ( new TreeScanner < Boolean , Void > ( ) { @ Override public Boolean visitMethodInvocation ( MethodInvocationTree node , Void unused ) { String name = getSymbol ( node ) . getSimpleName ( ) . toString ( ) ; return name . contains ( 'assert' ) || name . contains ( 'verify' ) || name . contains ( 'check' ) || name . contains ( 'fail' ) || name . contains ( 'expect' ) || firstNonNull ( super . visitMethodInvocation ( node , null ) , false ) ; } @ Override public Boolean reduce ( Boolean a , Boolean b ) { return firstNonNull ( a , false ) || firstNonNull ( b , false ) ; } } , null ) , false ) ; }
--------------------------------------------------
public static < A extends AbstractValue < A > , S extends Store < S > , T extends TransferFunction < A , S >> A expressionDataflow ( TreePath exprPath , Context context , T transfer ) { final Tree leaf = exprPath . getLeaf ( ) ; Preconditions . checkArgument ( leaf instanceof ExpressionTree , 'leaf of exprpath must be of type expressiontree, but was %s' , leaf . getClass ( ) . getName ( ) ) ; final ExpressionTree expr = ( ExpressionTree ) leaf ; final TreePath enclosingMethodPath = findEnclosingMethodOrLambdaOrInitializer ( exprPath ) ; if ( enclosingMethodPath == null ) { return null ; } final Tree method = enclosingMethodPath . getLeaf ( ) ; if ( method instanceof MethodTree && ( ( MethodTree ) method ) . getBody ( ) == null ) { return null ; } return methodDataflow ( enclosingMethodPath , context , transfer ) . getAnalysis ( ) . getValue ( expr ) ; }
--------------------------------------------------
private String generateUrlAssignmentIndirectly ( Method method ) { Class < ? > [ ] pts = method . getParameterTypes ( ) ; for ( int i = 0 ; i < pts . length ; ++ i ) { for ( Method m : pts [ i ] . getMethods ( ) ) { String name = m . getName ( ) ; if ( ( name . startsWith ( 'get' ) || name . length ( ) > 3 ) && Modifier . isPublic ( m . getModifiers ( ) ) && ! Modifier . isStatic ( m . getModifiers ( ) ) && m . getParameterTypes ( ) . length == 0 && m . getReturnType ( ) == URL . class ) { return generateGetUrlNullCheck ( i , pts [ i ] , name ) ; } } } throw new IllegalStateException ( 'failed to create adaptive class for interface ' + type . getName ( ) + ': not found url parameter or url attribute in parameters of method ' + method . getName ( ) ) ; }
--------------------------------------------------
