private Description makeDescription ( String rejectedJUnit4 , Tree tree ) { Description . Builder builder = buildDescription ( tree ) . setMessage ( String . format ( '%s cannot be used inside a junit3 class. convert your class to junit4 style.' , rejectedJUnit4 ) ) ; return builder . build ( ) ; }
--------------------------------------------------
public String toString ( ) { if ( importStrings . isEmpty ( ) ) { return '' ; } StringBuilder result = new StringBuilder ( ) ; if ( ! hasExistingImports ) { result . append ( '' ) ; } List < ImportOrganizer . Import > imports = importStrings . stream ( ) . map ( ImportOrganizer . Import :: importOf ) . collect ( Collectors . toList ( ) ) ; ImportOrganizer . OrganizedImports organizedImports = importOrganizer . organizeImports ( imports ) ; int expectedImportCount = imports . size ( ) ; int importCount = organizedImports . getImportCount ( ) ; if ( importCount != expectedImportCount ) { throw new IllegalStateException ( String . format ( 'expected %d import(s) in the organized imports but it contained %d' , expectedImportCount , importCount ) ) ; } result . append ( organizedImports . asImportBlock ( ) ) ; String replacementString = result . toString ( ) ; if ( ! hasExistingImports ) { return replacementString ; } else { return CharMatcher . whitespace ( ) . trimTrailingFrom ( replacementString ) ; } }
--------------------------------------------------
static Optional < List < Configurator >> toConfigurators ( List < URL > urls ) { if ( CollectionUtils . isEmpty ( urls ) ) { return Optional . empty ( ) ; } ConfiguratorFactory configuratorFactory = ExtensionLoader . getExtensionLoader ( ConfiguratorFactory . class ) . getAdaptiveExtension ( ) ; List < Configurator > configurators = new ArrayList < > ( urls . size ( ) ) ; for ( URL url : urls ) { if ( Constants . EMPTY_PROTOCOL . equals ( url . getProtocol ( ) ) ) { configurators . clear ( ) ; break ; } Map < String , String > override = new HashMap < > ( url . getParameters ( ) ) ; override . remove ( Constants . ANYHOST_KEY ) ; if ( override . size ( ) == 0 ) { configurators . clear ( ) ; continue ; } configurators . add ( configuratorFactory . getConfigurator ( url ) ) ; } Collections . sort ( configurators ) ; return Optional . of ( configurators ) ; }
--------------------------------------------------
public static < T extends Tree > Matcher < T > inLoop ( ) { return new Matcher < T > ( ) { @ Override public boolean matches ( Tree tree , VisitorState state ) { TreePath path = state . getPath ( ) . getParentPath ( ) ; Tree node = path . getLeaf ( ) ; while ( path != null ) { switch ( node . getKind ( ) ) { case METHOD : case CLASS : return false ; case WHILE_LOOP : case FOR_LOOP : case ENHANCED_FOR_LOOP : case DO_WHILE_LOOP : return true ; default : path = path . getParentPath ( ) ; node = path . getLeaf ( ) ; break ; } } return false ; } } ; }
--------------------------------------------------
private Object toFile ( VisitorState state , Tree fileArg , SuggestedFix . Builder fix ) { Type type = ASTHelpers . getType ( fileArg ) ; if ( ASTHelpers . isSubtype ( type , state . getSymtab ( ) . stringType , state ) ) { fix . addImport ( 'java.io.file' ) ; return String . format ( 'new file(%s)' , state . getSourceForNode ( fileArg ) ) ; } else if ( ASTHelpers . isSubtype ( type , state . getTypeFromString ( 'java.io.file' ) , state ) ) { return state . getSourceForNode ( fileArg ) ; } else { throw new AssertionError ( 'unexpected type: ' + type ) ; } }
--------------------------------------------------
private Map < String , Invoker < T >> toInvokers ( List < URL > urls ) { Map < String , Invoker < T >> newUrlInvokerMap = new HashMap < String , Invoker < T >> ( ) ; if ( urls == null || urls . isEmpty ( ) ) { return newUrlInvokerMap ; } Set < String > keys = new HashSet < String > ( ) ; String queryProtocols = this . queryMap . get ( Constants . PROTOCOL_KEY ) ; for ( URL providerUrl : urls ) { if ( queryProtocols != null && queryProtocols . length ( ) > 0 ) { boolean accept = false ; String [ ] acceptProtocols = queryProtocols . split ( ',' ) ; for ( String acceptProtocol : acceptProtocols ) { if ( providerUrl . getProtocol ( ) . equals ( acceptProtocol ) ) { accept = true ; break ; } } if ( ! accept ) { continue ; } } if ( Constants . EMPTY_PROTOCOL . equals ( providerUrl . getProtocol ( ) ) ) { continue ; } if ( ! ExtensionLoader . getExtensionLoader ( Protocol . class ) . hasExtension ( providerUrl . getProtocol ( ) ) ) { logger . error ( new IllegalStateException ( 'unsupported protocol ' + providerUrl . getProtocol ( ) + ' in notified url: ' + providerUrl + ' from registry ' + getUrl ( ) . getAddress ( ) + ' to consumer ' + NetUtils . getLocalHost ( ) + ', supported protocol: ' + ExtensionLoader . getExtensionLoader ( Protocol . class ) . getSupportedExtensions ( ) ) ) ; continue ; } URL url = mergeUrl ( providerUrl ) ; String key = url . toFullString ( ) ; if ( keys . contains ( key ) ) { continue ; } keys . add ( key ) ; Map < String , Invoker < T >> localUrlInvokerMap = this . urlInvokerMap ; Invoker < T > invoker = localUrlInvokerMap == null ? null : localUrlInvokerMap . get ( key ) ; if ( invoker == null ) { try { boolean enabled = true ; if ( url . hasParameter ( Constants . DISABLED_KEY ) ) { enabled = ! url . getParameter ( Constants . DISABLED_KEY , false ) ; } else { enabled = url . getParameter ( Constants . ENABLED_KEY , true ) ; } if ( enabled ) { invoker = new InvokerDelegate < T > ( protocol . refer ( serviceType , url ) , url , providerUrl ) ; } } catch ( Throwable t ) { logger . error ( 'failed to refer invoker for interface:' + serviceType + ',url:(' + url + ')' + t . getMessage ( ) , t ) ; } if ( invoker != null ) { newUrlInvokerMap . put ( key , invoker ) ; } } else { newUrlInvokerMap . put ( key , invoker ) ; } } keys . clear ( ) ; return newUrlInvokerMap ; }
--------------------------------------------------
private Optional < List < Router >> toRouters ( List < URL > urls ) { if ( urls == null || urls . isEmpty ( ) ) { return Optional . empty ( ) ; } List < Router > routers = new ArrayList < > ( ) ; for ( URL url : urls ) { if ( Constants . EMPTY_PROTOCOL . equals ( url . getProtocol ( ) ) ) { continue ; } String routerType = url . getParameter ( Constants . ROUTER_KEY ) ; if ( routerType != null && routerType . length ( ) > 0 ) { url = url . setProtocol ( routerType ) ; } try { Router router = routerFactory . getRouter ( url ) ; if ( ! routers . contains ( router ) ) { routers . add ( router ) ; } } catch ( Throwable t ) { logger . error ( 'convert router url to router error, url: ' + url , t ) ; } } return Optional . of ( routers ) ; }
--------------------------------------------------
public static String toString ( Throwable e ) { UnsafeStringWriter w = new UnsafeStringWriter ( ) ; PrintWriter p = new PrintWriter ( w ) ; p . print ( e . getClass ( ) . getName ( ) ) ; if ( e . getMessage ( ) != null ) { p . print ( ': ' + e . getMessage ( ) ) ; } p . println ( ) ; try { e . printStackTrace ( p ) ; return w . toString ( ) ; } finally { p . close ( ) ; } }
--------------------------------------------------
public static Properties loadProperties ( String fileName , boolean allowMultiFile , boolean optional ) { Properties properties = new Properties ( ) ; if ( checkFileNameExist ( fileName ) ) { try { FileInputStream input = new FileInputStream ( fileName ) ; try { properties . load ( input ) ; } finally { input . close ( ) ; } } catch ( Throwable e ) { logger . warn ( 'failed to load ' + fileName + ' file from ' + fileName + '(ignore this file): ' + e . getMessage ( ) , e ) ; } return properties ; } List < java . net . URL > list = new ArrayList < java . net . URL > ( ) ; try { Enumeration < java . net . URL > urls = ClassHelper . getClassLoader ( ) . getResources ( fileName ) ; list = new ArrayList < java . net . URL > ( ) ; while ( urls . hasMoreElements ( ) ) { list . add ( urls . nextElement ( ) ) ; } } catch ( Throwable t ) { logger . warn ( 'fail to load ' + fileName + ' file: ' + t . getMessage ( ) , t ) ; } if ( list . isEmpty ( ) ) { if ( ! optional ) { logger . warn ( 'no ' + fileName + ' found on the class path.' ) ; } return properties ; } if ( ! allowMultiFile ) { if ( list . size ( ) > 1 ) { String errMsg = String . format ( 'only 1 %s file is expected, but %d dubbo.properties files found on class path: %s' , fileName , list . size ( ) , list . toString ( ) ) ; logger . warn ( errMsg ) ; } try { properties . load ( ClassHelper . getClassLoader ( ) . getResourceAsStream ( fileName ) ) ; } catch ( Throwable e ) { logger . warn ( 'failed to load ' + fileName + ' file from ' + fileName + '(ignore this file): ' + e . getMessage ( ) , e ) ; } return properties ; } logger . info ( 'load ' + fileName + ' properties file from ' + list ) ; for ( java . net . URL url : list ) { try { Properties p = new Properties ( ) ; InputStream input = url . openStream ( ) ; if ( input != null ) { try { p . load ( input ) ; properties . putAll ( p ) ; } finally { try { input . close ( ) ; } catch ( Throwable t ) { } } } } catch ( Throwable e ) { logger . warn ( 'fail to load ' + fileName + ' file from ' + url + '(ignore this file): ' + e . getMessage ( ) , e ) ; } } return properties ; }
--------------------------------------------------
public static String toString ( String msg , Throwable e ) { UnsafeStringWriter w = new UnsafeStringWriter ( ) ; w . write ( msg + '' ) ; PrintWriter p = new PrintWriter ( w ) ; try { e . printStackTrace ( p ) ; return w . toString ( ) ; } finally { p . close ( ) ; } }
--------------------------------------------------
