public static Properties loadProperties ( String fileName , boolean allowMultiFile , boolean optional ) { Properties properties = new Properties ( ) ; if ( checkFileNameExist ( fileName ) ) { try { FileInputStream input = new FileInputStream ( fileName ) ; try { properties . load ( input ) ; } finally { input . close ( ) ; } } catch ( Throwable e ) { logger . warn ( 'failed to load ' + fileName + ' file from ' + fileName + '(ignore this file): ' + e . getMessage ( ) , e ) ; } return properties ; } List < java . net . URL > list = new ArrayList < java . net . URL > ( ) ; try { Enumeration < java . net . URL > urls = ClassHelper . getClassLoader ( ) . getResources ( fileName ) ; list = new ArrayList < java . net . URL > ( ) ; while ( urls . hasMoreElements ( ) ) { list . add ( urls . nextElement ( ) ) ; } } catch ( Throwable t ) { logger . warn ( 'fail to load ' + fileName + ' file: ' + t . getMessage ( ) , t ) ; } if ( list . isEmpty ( ) ) { if ( ! optional ) { logger . warn ( 'no ' + fileName + ' found on the class path.' ) ; } return properties ; } if ( ! allowMultiFile ) { if ( list . size ( ) > 1 ) { String errMsg = String . format ( 'only 1 %s file is expected, but %d dubbo.properties files found on class path: %s' , fileName , list . size ( ) , list . toString ( ) ) ; logger . warn ( errMsg ) ; } try { properties . load ( ClassHelper . getClassLoader ( ) . getResourceAsStream ( fileName ) ) ; } catch ( Throwable e ) { logger . warn ( 'failed to load ' + fileName + ' file from ' + fileName + '(ignore this file): ' + e . getMessage ( ) , e ) ; } return properties ; } logger . info ( 'load ' + fileName + ' properties file from ' + list ) ; for ( java . net . URL url : list ) { try { Properties p = new Properties ( ) ; InputStream input = url . openStream ( ) ; if ( input != null ) { try { p . load ( input ) ; properties . putAll ( p ) ; } finally { try { input . close ( ) ; } catch ( Throwable t ) { } } } } catch ( Throwable e ) { logger . warn ( 'fail to load ' + fileName + ' file from ' + url + '(ignore this file): ' + e . getMessage ( ) , e ) ; } } return properties ; }
--------------------------------------------------
public String toString ( ) { if ( importStrings . isEmpty ( ) ) { return '' ; } StringBuilder result = new StringBuilder ( ) ; if ( ! hasExistingImports ) { result . append ( '' ) ; } List < ImportOrganizer . Import > imports = importStrings . stream ( ) . map ( ImportOrganizer . Import :: importOf ) . collect ( Collectors . toList ( ) ) ; ImportOrganizer . OrganizedImports organizedImports = importOrganizer . organizeImports ( imports ) ; int expectedImportCount = imports . size ( ) ; int importCount = organizedImports . getImportCount ( ) ; if ( importCount != expectedImportCount ) { throw new IllegalStateException ( String . format ( 'expected %d import(s) in the organized imports but it contained %d' , expectedImportCount , importCount ) ) ; } result . append ( organizedImports . asImportBlock ( ) ) ; String replacementString = result . toString ( ) ; if ( ! hasExistingImports ) { return replacementString ; } else { return CharMatcher . whitespace ( ) . trimTrailingFrom ( replacementString ) ; } }
--------------------------------------------------
public static Fix deleteExceptions ( MethodTree tree , final VisitorState state , List < ExpressionTree > toDelete ) { List < ? extends ExpressionTree > trees = tree . getThrows ( ) ; if ( toDelete . size ( ) == trees . size ( ) ) { return SuggestedFix . replace ( getThrowsPosition ( tree , state ) - 1 , state . getEndPosition ( getLast ( trees ) ) , '' ) ; } String replacement = FluentIterable . from ( tree . getThrows ( ) ) . filter ( Predicates . not ( Predicates . in ( toDelete ) ) ) . transform ( new Function < ExpressionTree , String > ( ) { @ Override @ Nullable public String apply ( ExpressionTree input ) { return state . getSourceForNode ( input ) ; } } ) . join ( Joiner . on ( ', ' ) ) ; return SuggestedFix . replace ( ( ( JCTree ) tree . getThrows ( ) . get ( 0 ) ) . getStartPosition ( ) , state . getEndPosition ( getLast ( tree . getThrows ( ) ) ) , replacement ) ; }
--------------------------------------------------
protected List < Type > actualTypes ( Inliner inliner ) { ArrayList < Type > result = new ArrayList < > ( ) ; ImmutableList < String > argNames = expressionArgumentTypes ( ) . keySet ( ) . asList ( ) ; for ( int i = 0 ; i < expressionArgumentTypes ( ) . size ( ) ; i ++ ) { String argName = argNames . get ( i ) ; Optional < JCExpression > singleBinding = inliner . getOptionalBinding ( new UFreeIdent . Key ( argName ) ) ; if ( singleBinding . isPresent ( ) ) { result . add ( singleBinding . get ( ) . type ) ; } else { Optional < java . util . List < JCExpression >> exprs = inliner . getOptionalBinding ( new URepeated . Key ( argName ) ) ; if ( exprs . isPresent ( ) && ! exprs . get ( ) . isEmpty ( ) ) { Type [ ] exprTys = new Type [ exprs . get ( ) . size ( ) ] ; for ( int j = 0 ; j < exprs . get ( ) . size ( ) ; j ++ ) { exprTys [ j ] = exprs . get ( ) . get ( j ) . type ; } result . add ( inliner . types ( ) . lub ( List . from ( exprTys ) ) ) ; } } } for ( PlaceholderExpressionKey key : Ordering . natural ( ) . immutableSortedCopy ( Iterables . filter ( inliner . bindings . keySet ( ) , PlaceholderExpressionKey . class ) ) ) { result . add ( inliner . getBinding ( key ) . type ) ; } return List . from ( result ) ; }
--------------------------------------------------
protected List < Type > expectedTypes ( Inliner inliner ) throws CouldNotResolveImportException { ArrayList < Type > result = new ArrayList < > ( ) ; ImmutableList < UType > types = expressionArgumentTypes ( ) . values ( ) . asList ( ) ; ImmutableList < String > argNames = expressionArgumentTypes ( ) . keySet ( ) . asList ( ) ; for ( int i = 0 ; i < argNames . size ( ) ; i ++ ) { String argName = argNames . get ( i ) ; Optional < JCExpression > singleBinding = inliner . getOptionalBinding ( new UFreeIdent . Key ( argName ) ) ; if ( ! singleBinding . isPresent ( ) ) { Optional < java . util . List < JCExpression >> exprs = inliner . getOptionalBinding ( new URepeated . Key ( argName ) ) ; if ( ! exprs . isPresent ( ) || exprs . get ( ) . isEmpty ( ) ) { continue ; } } result . add ( types . get ( i ) . inline ( inliner ) ) ; } for ( PlaceholderExpressionKey key : Ordering . natural ( ) . immutableSortedCopy ( Iterables . filter ( inliner . bindings . keySet ( ) , PlaceholderExpressionKey . class ) ) ) { result . add ( key . method . returnType ( ) . inline ( inliner ) ) ; } return List . from ( result ) ; }
--------------------------------------------------
public static ErrorProneOptions processArgs ( Iterable < String > args ) { Preconditions . checkNotNull ( args ) ; ImmutableList . Builder < String > remainingArgs = ImmutableList . builder ( ) ; Builder builder = new Builder ( ) ; for ( String arg : args ) { switch ( arg ) { case IGNORE_SUPPRESSION_ANNOTATIONS : builder . setIgnoreSuppressionAnnotations ( true ) ; break ; case IGNORE_UNKNOWN_CHECKS_FLAG : builder . setIgnoreUnknownChecks ( true ) ; break ; case DISABLE_WARNINGS_IN_GENERATED_CODE_FLAG : builder . setDisableWarningsInGeneratedCode ( true ) ; break ; case ERRORS_AS_WARNINGS_FLAG : builder . setDropErrorsToWarnings ( true ) ; break ; case ENABLE_ALL_CHECKS : builder . setEnableAllChecksAsWarnings ( true ) ; break ; case DISABLE_ALL_CHECKS : builder . setDisableAllChecks ( true ) ; break ; case COMPILING_TEST_ONLY_CODE : builder . setTestOnlyTarget ( true ) ; break ; default : if ( arg . startsWith ( SEVERITY_PREFIX ) ) { builder . parseSeverity ( arg ) ; } else if ( arg . startsWith ( ErrorProneFlags . PREFIX ) ) { builder . parseFlag ( arg ) ; } else if ( arg . startsWith ( PATCH_OUTPUT_LOCATION ) ) { String remaining = arg . substring ( PATCH_OUTPUT_LOCATION . length ( ) ) ; if ( remaining . equals ( 'in_place' ) ) { builder . patchingOptionsBuilder ( ) . inPlace ( true ) ; } else { if ( remaining . isEmpty ( ) ) { throw new InvalidCommandLineOptionException ( 'invalid flag: ' + arg ) ; } builder . patchingOptionsBuilder ( ) . baseDirectory ( remaining ) ; } } else if ( arg . startsWith ( PATCH_CHECKS_PREFIX ) ) { String remaining = arg . substring ( PATCH_CHECKS_PREFIX . length ( ) ) ; if ( remaining . startsWith ( 'refaster:' ) ) { builder . patchingOptionsBuilder ( ) . customRefactorer ( ( ) -> { String path = remaining . substring ( 'refaster:' . length ( ) ) ; try ( InputStream in = Files . newInputStream ( FileSystems . getDefault ( ) . getPath ( path ) ) ; ObjectInputStream ois = new ObjectInputStream ( in ) ) { return ( CodeTransformer ) ois . readObject ( ) ; } catch ( IOException | ClassNotFoundException e ) { throw new RuntimeException ( 'can't load refaster rule from ' + path , e ) ; } } ) ; } else { Iterable < String > checks = Splitter . on ( ',' ) . trimResults ( ) . split ( remaining ) ; builder . patchingOptionsBuilder ( ) . namedCheckers ( ImmutableSet . copyOf ( checks ) ) ; } } else if ( arg . startsWith ( PATCH_IMPORT_ORDER_PREFIX ) ) { String remaining = arg . substring ( PATCH_IMPORT_ORDER_PREFIX . length ( ) ) ; ImportOrganizer importOrganizer = ImportOrderParser . getImportOrganizer ( remaining ) ; builder . patchingOptionsBuilder ( ) . importOrganizer ( importOrganizer ) ; } else if ( arg . startsWith ( EXCLUDED_PATHS_PREFIX ) ) { String pathRegex = arg . substring ( EXCLUDED_PATHS_PREFIX . length ( ) ) ; builder . setExcludedPattern ( Pattern . compile ( pathRegex ) ) ; } else { remainingArgs . add ( arg ) ; } } } return builder . build ( remainingArgs . build ( ) ) ; }
--------------------------------------------------
private Map < String , Invoker < T >> toInvokers ( List < URL > urls ) { Map < String , Invoker < T >> newUrlInvokerMap = new HashMap < String , Invoker < T >> ( ) ; if ( urls == null || urls . isEmpty ( ) ) { return newUrlInvokerMap ; } Set < String > keys = new HashSet < String > ( ) ; String queryProtocols = this . queryMap . get ( Constants . PROTOCOL_KEY ) ; for ( URL providerUrl : urls ) { if ( queryProtocols != null && queryProtocols . length ( ) > 0 ) { boolean accept = false ; String [ ] acceptProtocols = queryProtocols . split ( ',' ) ; for ( String acceptProtocol : acceptProtocols ) { if ( providerUrl . getProtocol ( ) . equals ( acceptProtocol ) ) { accept = true ; break ; } } if ( ! accept ) { continue ; } } if ( Constants . EMPTY_PROTOCOL . equals ( providerUrl . getProtocol ( ) ) ) { continue ; } if ( ! ExtensionLoader . getExtensionLoader ( Protocol . class ) . hasExtension ( providerUrl . getProtocol ( ) ) ) { logger . error ( new IllegalStateException ( 'unsupported protocol ' + providerUrl . getProtocol ( ) + ' in notified url: ' + providerUrl + ' from registry ' + getUrl ( ) . getAddress ( ) + ' to consumer ' + NetUtils . getLocalHost ( ) + ', supported protocol: ' + ExtensionLoader . getExtensionLoader ( Protocol . class ) . getSupportedExtensions ( ) ) ) ; continue ; } URL url = mergeUrl ( providerUrl ) ; String key = url . toFullString ( ) ; if ( keys . contains ( key ) ) { continue ; } keys . add ( key ) ; Map < String , Invoker < T >> localUrlInvokerMap = this . urlInvokerMap ; Invoker < T > invoker = localUrlInvokerMap == null ? null : localUrlInvokerMap . get ( key ) ; if ( invoker == null ) { try { boolean enabled = true ; if ( url . hasParameter ( Constants . DISABLED_KEY ) ) { enabled = ! url . getParameter ( Constants . DISABLED_KEY , false ) ; } else { enabled = url . getParameter ( Constants . ENABLED_KEY , true ) ; } if ( enabled ) { invoker = new InvokerDelegate < T > ( protocol . refer ( serviceType , url ) , url , providerUrl ) ; } } catch ( Throwable t ) { logger . error ( 'failed to refer invoker for interface:' + serviceType + ',url:(' + url + ')' + t . getMessage ( ) , t ) ; } if ( invoker != null ) { newUrlInvokerMap . put ( key , invoker ) ; } } else { newUrlInvokerMap . put ( key , invoker ) ; } } keys . clear ( ) ; return newUrlInvokerMap ; }
--------------------------------------------------
