public static < T extends Tree > Matcher < T > isArrayType ( ) { return new Matcher < T > ( ) { @ Override public boolean matches ( Tree t , VisitorState state ) { Type type = getType ( t ) ; return type != null && state . getTypes ( ) . isArray ( type ) ; } } ; }
--------------------------------------------------
public static < T extends Tree > Matcher < T > isPrimitiveArrayType ( ) { return new Matcher < T > ( ) { @ Override public boolean matches ( Tree t , VisitorState state ) { Type type = getType ( t ) ; return type != null && state . getTypes ( ) . isArray ( type ) && state . getTypes ( ) . elemtype ( type ) . isPrimitive ( ) ; } } ; }
--------------------------------------------------
public static String toString ( Throwable e ) { UnsafeStringWriter w = new UnsafeStringWriter ( ) ; PrintWriter p = new PrintWriter ( w ) ; p . print ( e . getClass ( ) . getName ( ) ) ; if ( e . getMessage ( ) != null ) { p . print ( ': ' + e . getMessage ( ) ) ; } p . println ( ) ; try { e . printStackTrace ( p ) ; return w . toString ( ) ; } finally { p . close ( ) ; } }
--------------------------------------------------
public static boolean isJavaIdentifier ( String s ) { if ( isEmpty ( s ) || ! Character . isJavaIdentifierStart ( s . charAt ( 0 ) ) ) { return false ; } for ( int i = 1 ; i < s . length ( ) ; i ++ ) { if ( ! Character . isJavaIdentifierPart ( s . charAt ( i ) ) ) { return false ; } } return true ; }
--------------------------------------------------
( Tree parent , ExpressionTree tree , VisitorState state ) { if ( isStringConcat ( parent , state ) ) { return ToStringKind . IMPLICIT ; } if ( parent instanceof ExpressionTree ) { ExpressionTree parentExpression = ( ExpressionTree ) parent ; if ( PRINT_STRING . matches ( parentExpression , state ) ) { return ToStringKind . IMPLICIT ; } if ( VALUE_OF . matches ( parentExpression , state ) ) { return ToStringKind . EXPLICIT ; } } return ToStringKind . NONE ; }
--------------------------------------------------
boolean isAssignableTo ( Parameter target , VisitorState state ) { if ( state . getTypes ( ) . isSameType ( type ( ) , Type . noType ) || state . getTypes ( ) . isSameType ( target . type ( ) , Type . noType ) ) { return false ; } try { return state . getTypes ( ) . isAssignable ( type ( ) , target . type ( ) ) ; } catch ( CompletionFailure e ) { Check . instance ( state . context ) . completionError ( ( DiagnosticPosition ) state . getPath ( ) . getLeaf ( ) , e ) ; return false ; } }
--------------------------------------------------
public String toString ( ) { if ( importStrings . isEmpty ( ) ) { return '' ; } StringBuilder result = new StringBuilder ( ) ; if ( ! hasExistingImports ) { result . append ( '' ) ; } List < ImportOrganizer . Import > imports = importStrings . stream ( ) . map ( ImportOrganizer . Import :: importOf ) . collect ( Collectors . toList ( ) ) ; ImportOrganizer . OrganizedImports organizedImports = importOrganizer . organizeImports ( imports ) ; int expectedImportCount = imports . size ( ) ; int importCount = organizedImports . getImportCount ( ) ; if ( importCount != expectedImportCount ) { throw new IllegalStateException ( String . format ( 'expected %d import(s) in the organized imports but it contained %d' , expectedImportCount , importCount ) ) ; } result . append ( organizedImports . asImportBlock ( ) ) ; String replacementString = result . toString ( ) ; if ( ! hasExistingImports ) { return replacementString ; } else { return CharMatcher . whitespace ( ) . trimTrailingFrom ( replacementString ) ; } }
--------------------------------------------------
public static < A extends Annotation > boolean isPresent ( Method method , Class < A > annotationClass ) { Map < ElementType , List < A >> annotationsMap = findAnnotations ( method , annotationClass ) ; return ! annotationsMap . isEmpty ( ) ; }
--------------------------------------------------
public static < T extends Tree > Matcher < T > isInstance ( final java . lang . Class < ? > klass ) { return new Matcher < T > ( ) { @ Override public boolean matches ( T t , VisitorState state ) { return klass . isInstance ( t ) ; } } ; }
--------------------------------------------------
private boolean isParameterSubjectToAnalysis ( Symbol sym ) { checkArgument ( sym . getKind ( ) == ElementKind . PARAMETER ) ; Symbol enclosingMethod = sym . owner ; for ( String annotationName : methodAnnotationsExemptingParameters ) { if ( ASTHelpers . hasAnnotation ( enclosingMethod , annotationName , state ) ) { return false ; } } return enclosingMethod . getModifiers ( ) . contains ( Modifier . PRIVATE ) ; }
--------------------------------------------------
