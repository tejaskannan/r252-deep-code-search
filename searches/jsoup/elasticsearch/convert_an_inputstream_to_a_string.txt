public static Object compatibleTypeConvert ( Object value , Class < ? > type ) { if ( value == null || type == null || type . isAssignableFrom ( value . getClass ( ) ) ) { return value ; } if ( value instanceof String ) { String string = ( String ) value ; if ( char . class . equals ( type ) || Character . class . equals ( type ) ) { if ( string . length ( ) != 1 ) { throw new IllegalArgumentException ( String . format ( 'can not convert string(%s) to char!' '+' ' when convert string to char, the string must only 1 char.' , string ) ) ; } return string . charAt ( 0 ) ; } else if ( type . isEnum ( ) ) { return Enum . valueOf ( ( Class < Enum > ) type , string ) ; } else if ( type == BigInteger . class ) { return new BigInteger ( string ) ; } else if ( type == BigDecimal . class ) { return new BigDecimal ( string ) ; } else if ( type == Short . class || type == short . class ) { return new Short ( string ) ; } else if ( type == Integer . class || type == int . class ) { return new Integer ( string ) ; } else if ( type == Long . class || type == long . class ) { return new Long ( string ) ; } else if ( type == Double . class || type == double . class ) { return new Double ( string ) ; } else if ( type == Float . class || type == float . class ) { return new Float ( string ) ; } else if ( type == Byte . class || type == byte . class ) { return new Byte ( string ) ; } else if ( type == Boolean . class || type == boolean . class ) { return new Boolean ( string ) ; } else if ( type == Date . class || type == java . sql . Date . class || type == java . sql . Timestamp . class || type == java . sql . Time . class ) { try { Date date = new SimpleDateFormat ( DATE_FORMAT ) . parse ( ( String ) value ) ; if ( type == java . sql . Date . class ) { return new java . sql . Date ( date . getTime ( ) ) ; } else if ( type == java . sql . Timestamp . class ) { return new java . sql . Timestamp ( date . getTime ( ) ) ; } else if ( type == java . sql . Time . class ) { return new java . sql . Time ( date . getTime ( ) ) ; } else { return date ; } } catch ( ParseException e ) { throw new IllegalStateException ( 'failed to parse date ' + value + ' by format ' + DATE_FORMAT + ', cause: ' + e . getMessage ( ) , e ) ; } } else if ( type == Class . class ) { try { return ReflectUtils . name2class ( ( String ) value ) ; } catch ( ClassNotFoundException e ) { throw new RuntimeException ( e . getMessage ( ) , e ) ; } } else if ( char [ ] . class . equals ( type ) ) { int len = string . length ( ) ; char [ ] chars = new char [ len ] ; string . getChars ( 0 , len , chars , 0 ) ; return chars ; } } else if ( value instanceof Number ) { Number number = ( Number ) value ; if ( type == byte . class || type == Byte . class ) { return number . byteValue ( ) ; } else if ( type == short . class || type == Short . class ) { return number . shortValue ( ) ; } else if ( type == int . class || type == Integer . class ) { return number . intValue ( ) ; } else if ( type == long . class || type == Long . class ) { return number . longValue ( ) ; } else if ( type == float . class || type == Float . class ) { return number . floatValue ( ) ; } else if ( type == double . class || type == Double . class ) { return number . doubleValue ( ) ; } else if ( type == BigInteger . class ) { return BigInteger . valueOf ( number . longValue ( ) ) ; } else if ( type == BigDecimal . class ) { return BigDecimal . valueOf ( number . doubleValue ( ) ) ; } else if ( type == Date . class ) { return new Date ( number . longValue ( ) ) ; } } else if ( value instanceof Collection ) { Collection collection = ( Collection ) value ; if ( type . isArray ( ) ) { int length = collection . size ( ) ; Object array = Array . newInstance ( type . getComponentType ( ) , length ) ; int i = 0 ; for ( Object item : collection ) { Array . set ( array , i ++ , item ) ; } return array ; } else if ( ! type . isInterface ( ) ) { try { Collection result = ( Collection ) type . newInstance ( ) ; result . addAll ( collection ) ; return result ; } catch ( Throwable e ) { } } else if ( type == List . class ) { return new ArrayList < Object > ( collection ) ; } else if ( type == Set . class ) { return new HashSet < Object > ( collection ) ; } } else if ( value . getClass ( ) . isArray ( ) && Collection . class . isAssignableFrom ( type ) ) { Collection collection ; if ( ! type . isInterface ( ) ) { try { collection = ( Collection ) type . newInstance ( ) ; } catch ( Throwable e ) { collection = new ArrayList < Object > ( ) ; } } else if ( type == Set . class ) { collection = new HashSet < Object > ( ) ; } else { collection = new ArrayList < Object > ( ) ; } int length = Array . getLength ( value ) ; for ( int i = 0 ; i < length ; i ++ ) { collection . add ( Array . get ( value , i ) ) ; } return collection ; } return value ; }
--------------------------------------------------
private Description makeDescription ( String rejectedJUnit4 , Tree tree ) { Description . Builder builder = buildDescription ( tree ) . setMessage ( String . format ( '%s cannot be used inside a junit3 class. convert your class to junit4 style.' , rejectedJUnit4 ) ) ; return builder . build ( ) ; }
--------------------------------------------------
public String chompTo ( String seq ) { String data = consumeTo ( seq ) ; matchChomp ( seq ) ; return data ; }
--------------------------------------------------
public String toString ( ) { if ( importStrings . isEmpty ( ) ) { return '' ; } StringBuilder result = new StringBuilder ( ) ; if ( ! hasExistingImports ) { result . append ( '' ) ; } List < ImportOrganizer . Import > imports = importStrings . stream ( ) . map ( ImportOrganizer . Import :: importOf ) . collect ( Collectors . toList ( ) ) ; ImportOrganizer . OrganizedImports organizedImports = importOrganizer . organizeImports ( imports ) ; int expectedImportCount = imports . size ( ) ; int importCount = organizedImports . getImportCount ( ) ; if ( importCount != expectedImportCount ) { throw new IllegalStateException ( String . format ( 'expected %d import(s) in the organized imports but it contained %d' , expectedImportCount , importCount ) ) ; } result . append ( organizedImports . asImportBlock ( ) ) ; String replacementString = result . toString ( ) ; if ( ! hasExistingImports ) { return replacementString ; } else { return CharMatcher . whitespace ( ) . trimTrailingFrom ( replacementString ) ; } }
--------------------------------------------------
private Optional < List < Router >> toRouters ( List < URL > urls ) { if ( urls == null || urls . isEmpty ( ) ) { return Optional . empty ( ) ; } List < Router > routers = new ArrayList < > ( ) ; for ( URL url : urls ) { if ( Constants . EMPTY_PROTOCOL . equals ( url . getProtocol ( ) ) ) { continue ; } String routerType = url . getParameter ( Constants . ROUTER_KEY ) ; if ( routerType != null && routerType . length ( ) > 0 ) { url = url . setProtocol ( routerType ) ; } try { Router router = routerFactory . getRouter ( url ) ; if ( ! routers . contains ( router ) ) { routers . add ( router ) ; } } catch ( Throwable t ) { logger . error ( 'convert router url to router error, url: ' + url , t ) ; } } return Optional . of ( routers ) ; }
--------------------------------------------------
public String toString ( ) { return getFirst ( getAllChecks ( ) . keySet ( ) , '' ) ; }
--------------------------------------------------
public static String toString ( Throwable e ) { UnsafeStringWriter w = new UnsafeStringWriter ( ) ; PrintWriter p = new PrintWriter ( w ) ; p . print ( e . getClass ( ) . getName ( ) ) ; if ( e . getMessage ( ) != null ) { p . print ( ': ' + e . getMessage ( ) ) ; } p . println ( ) ; try { e . printStackTrace ( p ) ; return w . toString ( ) ; } finally { p . close ( ) ; } }
--------------------------------------------------
public Diff toProto ( ) { ApiDiffProto . Diff . Builder builder = ApiDiffProto . Diff . newBuilder ( ) ; for ( String className : unsupportedClasses ( ) ) { builder . addClassDiff ( ApiDiffProto . ClassDiff . newBuilder ( ) . setEverythingDiff ( ApiDiffProto . EverythingDiff . newBuilder ( ) . setClassName ( className ) ) ) ; } for ( String className : unsupportedMembersByClass ( ) . keySet ( ) ) { ApiDiffProto . MemberDiff . Builder memberDiff = ApiDiffProto . MemberDiff . newBuilder ( ) . setClassName ( className ) ; for ( ClassMemberKey member : unsupportedMembersByClass ( ) . get ( className ) ) { memberDiff . addMember ( ApiDiffProto . ClassMember . newBuilder ( ) . setIdentifier ( member . identifier ( ) ) . setMemberDescriptor ( member . descriptor ( ) ) ) ; } builder . addClassDiff ( ApiDiffProto . ClassDiff . newBuilder ( ) . setMemberDiff ( memberDiff ) ) ; } return builder . build ( ) ; }
--------------------------------------------------
private Object toFile ( VisitorState state , Tree fileArg , SuggestedFix . Builder fix ) { Type type = ASTHelpers . getType ( fileArg ) ; if ( ASTHelpers . isSubtype ( type , state . getSymtab ( ) . stringType , state ) ) { fix . addImport ( 'java.io.file' ) ; return String . format ( 'new file(%s)' , state . getSourceForNode ( fileArg ) ) ; } else if ( ASTHelpers . isSubtype ( type , state . getTypeFromString ( 'java.io.file' ) , state ) ) { return state . getSourceForNode ( fileArg ) ; } else { throw new AssertionError ( 'unexpected type: ' + type ) ; } }
--------------------------------------------------
private static String exceptionToString ( TryTree tree , VisitorState state ) { if ( tree . getCatches ( ) . size ( ) != 1 ) { return 'exception' ; } Tree exceptionType = tree . getCatches ( ) . iterator ( ) . next ( ) . getParameter ( ) . getType ( ) ; Type type = ASTHelpers . getType ( exceptionType ) ; if ( type != null && type . isUnion ( ) ) { return 'exception' ; } return state . getSourceForNode ( exceptionType ) ; }
--------------------------------------------------
