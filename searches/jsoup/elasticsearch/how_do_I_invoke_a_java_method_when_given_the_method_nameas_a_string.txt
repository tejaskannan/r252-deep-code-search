private static < A extends AbstractValue < A > , S extends Store < S > , T extends TransferFunction < A , S >> Result < A , S , T > methodDataflow ( TreePath methodPath , Context context , T transfer ) { final ProcessingEnvironment env = JavacProcessingEnvironment . instance ( context ) ; final ControlFlowGraph cfg ; try { cfg = cfgCache . getUnchecked ( CfgParams . create ( methodPath , env ) ) ; } catch ( UncheckedExecutionException e ) { throw e . getCause ( ) instanceof CompletionFailure ? ( CompletionFailure ) e . getCause ( ) : e ; } final AnalysisParams aparams = AnalysisParams . create ( transfer , cfg , env ) ; @ SuppressWarnings ( 'unchecked' ) final Analysis < A , S , T > analysis = ( Analysis < A , S , T > ) analysisCache . getUnchecked ( aparams ) ; return new Result < A , S , T > ( ) { @ Override public Analysis < A , S , T > getAnalysis ( ) { return analysis ; } @ Override public ControlFlowGraph getControlFlowGraph ( ) { return cfg ; } } ; }
--------------------------------------------------
public static boolean containsTestMethod ( Tree tree ) { return firstNonNull ( tree . accept ( new TreeScanner < Boolean , Void > ( ) { @ Override public Boolean visitMethodInvocation ( MethodInvocationTree node , Void unused ) { String name = getSymbol ( node ) . getSimpleName ( ) . toString ( ) ; return name . contains ( 'assert' ) || name . contains ( 'verify' ) || name . contains ( 'check' ) || name . contains ( 'fail' ) || name . contains ( 'expect' ) || firstNonNull ( super . visitMethodInvocation ( node , null ) , false ) ; } @ Override public Boolean reduce ( Boolean a , Boolean b ) { return firstNonNull ( a , false ) || firstNonNull ( b , false ) ; } } , null ) , false ) ; }
--------------------------------------------------
public static Method findMethodByMethodSignature ( Class < ? > clazz , String methodName , String [ ] parameterTypes ) throws NoSuchMethodException , ClassNotFoundException { String signature = clazz . getName ( ) + '.' + methodName ; if ( parameterTypes != null && parameterTypes . length > 0 ) { signature += StringUtils . join ( parameterTypes ) ; } Method method = Signature_METHODS_CACHE . get ( signature ) ; if ( method != null ) { return method ; } if ( parameterTypes == null ) { List < Method > finded = new ArrayList < Method > ( ) ; for ( Method m : clazz . getMethods ( ) ) { if ( m . getName ( ) . equals ( methodName ) ) { finded . add ( m ) ; } } if ( finded . isEmpty ( ) ) { throw new NoSuchMethodException ( 'no such method ' + methodName + ' in class ' + clazz ) ; } if ( finded . size ( ) > 1 ) { String msg = String . format ( 'not unique method for method name(%s) in class(%s), find %d methods.' , methodName , clazz . getName ( ) , finded . size ( ) ) ; throw new IllegalStateException ( msg ) ; } method = finded . get ( 0 ) ; } else { Class < ? > [ ] types = new Class < ? > [ parameterTypes . length ] ; for ( int i = 0 ; i < parameterTypes . length ; i ++ ) { types [ i ] = ReflectUtils . name2class ( parameterTypes [ i ] ) ; } method = clazz . getMethod ( methodName , types ) ; } Signature_METHODS_CACHE . put ( signature , method ) ; return method ; }
--------------------------------------------------
public Description matchMethod ( MethodTree tree , VisitorState state ) { MethodSymbol methodSym = ASTHelpers . getSymbol ( tree ) ; if ( methodSym == null ) { return Description . NO_MATCH ; } if ( methodSym . getModifiers ( ) . contains ( Modifier . ABSTRACT ) ) { return Description . NO_MATCH ; } String annotatedSuperMethod = null ; String matchedAnnotationSimpleName = null ; for ( MethodSymbol method : ASTHelpers . findSuperMethods ( methodSym , state . getTypes ( ) ) ) { for ( AnnotationType annotationType : AnnotationType . values ( ) ) { if ( ASTHelpers . hasAnnotation ( method , annotationType . fullyQualifiedName ( ) , state ) ) { annotatedSuperMethod = getMethodName ( method ) ; matchedAnnotationSimpleName = annotationType . simpleName ( ) ; break ; } } } if ( annotatedSuperMethod == null || matchedAnnotationSimpleName == null ) { return Description . NO_MATCH ; } TreeScanner < Boolean , Void > findSuper = new FindSuperTreeScanner ( tree . getName ( ) . toString ( ) ) ; if ( findSuper . scan ( tree , null ) ) { return Description . NO_MATCH ; } return buildDescription ( tree ) . setMessage ( String . format ( 'this method overrides %s, which is annotated with @%s, but does not call the ' '+' 'super method' , annotatedSuperMethod , matchedAnnotationSimpleName ) ) . build ( ) ; }
--------------------------------------------------
private String generateMethodArguments ( Method method ) { Class < ? > [ ] pts = method . getParameterTypes ( ) ; return IntStream . range ( 0 , pts . length ) . mapToObj ( i -> String . format ( CODE_METHOD_ARGUMENT , pts [ i ] . getCanonicalName ( ) , i ) ) . collect ( Collectors . joining ( ', ' ) ) ; }
--------------------------------------------------
public Description matchMethod ( MethodTree methodTree , VisitorState state ) { if ( ! LOOKS_LIKE_TEST_CASE . matches ( methodTree , state ) ) { return NO_MATCH ; } List < SuggestedFix > fixes = new ArrayList < > ( 0 ) ; if ( not ( methodNameStartsWith ( 'test' ) ) . matches ( methodTree , state ) ) { String fixedName = methodTree . getName ( ) . toString ( ) ; java . util . regex . Matcher matcher = MISSPELLED_NAME . matcher ( fixedName ) ; if ( matcher . lookingAt ( ) ) { fixedName = matcher . replaceFirst ( 'test' ) ; } else if ( wouldRunInJUnit4 . matches ( methodTree , state ) ) { fixedName = 'test' + Ascii . toUpperCase ( fixedName . substring ( 0 , 1 ) ) + fixedName . substring ( 1 ) ; } else { return NO_MATCH ; } fixes . add ( renameMethod ( methodTree , fixedName , state ) ) ; } addModifiers ( methodTree , state , Modifier . PUBLIC ) . ifPresent ( fixes :: add ) ; removeModifiers ( methodTree , state , Modifier . PRIVATE , Modifier . PROTECTED ) . ifPresent ( fixes :: add ) ; removeModifiers ( methodTree , state , Modifier . STATIC ) . ifPresent ( fixes :: add ) ; return describeMatch ( methodTree , mergeFixes ( fixes ) ) ; }
--------------------------------------------------
public String getDescription ( ) { return 'the parameters of this method are inconsistent with other overloaded versions.' '+' ' a consistent order would be: ' + getSuggestedSignature ( ) ; }
--------------------------------------------------
public static < A extends Annotation > Map < ElementType , List < A >> findAnnotations ( Method method , Class < A > annotationClass ) { Retention retention = annotationClass . getAnnotation ( Retention . class ) ; RetentionPolicy retentionPolicy = retention . value ( ) ; if ( ! RetentionPolicy . RUNTIME . equals ( retentionPolicy ) ) { return Collections . emptyMap ( ) ; } Map < ElementType , List < A >> annotationsMap = new LinkedHashMap < ElementType , List < A >> ( ) ; Target target = annotationClass . getAnnotation ( Target . class ) ; ElementType [ ] elementTypes = target . value ( ) ; for ( ElementType elementType : elementTypes ) { List < A > annotationsList = new LinkedList < A > ( ) ; switch ( elementType ) { case PARAMETER : Annotation [ ] [ ] parameterAnnotations = method . getParameterAnnotations ( ) ; for ( Annotation [ ] annotations : parameterAnnotations ) { for ( Annotation annotation : annotations ) { if ( annotationClass . equals ( annotation . annotationType ( ) ) ) { annotationsList . add ( ( A ) annotation ) ; } } } break ; case METHOD : A annotation = findAnnotation ( method , annotationClass ) ; if ( annotation != null ) { annotationsList . add ( annotation ) ; } break ; case TYPE : Class < ? > beanType = method . getDeclaringClass ( ) ; A annotation2 = findAnnotation ( beanType , annotationClass ) ; if ( annotation2 != null ) { annotationsList . add ( annotation2 ) ; } break ; } if ( ! annotationsList . isEmpty ( ) ) { annotationsMap . put ( elementType , annotationsList ) ; } } return Collections . unmodifiableMap ( annotationsMap ) ; }
--------------------------------------------------
private String generateMethod ( Method method ) { String methodReturnType = method . getReturnType ( ) . getCanonicalName ( ) ; String methodName = method . getName ( ) ; String methodContent = generateMethodContent ( method ) ; String methodArgs = generateMethodArguments ( method ) ; String methodThrows = generateMethodThrows ( method ) ; return String . format ( CODE_METHOD_DECLARATION , methodReturnType , methodName , methodArgs , methodThrows , methodContent ) ; }
--------------------------------------------------
public Description matchMethod ( MethodTree tree , VisitorState state ) { MethodSymbol method = ASTHelpers . getSymbol ( tree ) ; boolean checkReturn = hasDirectAnnotationWithSimpleName ( method , CHECK_RETURN_VALUE ) ; boolean canIgnore = hasDirectAnnotationWithSimpleName ( method , CAN_IGNORE_RETURN_VALUE ) ; if ( checkReturn && canIgnore ) { return buildDescription ( tree ) . setMessage ( String . format ( BOTH_ERROR , 'method' ) ) . build ( ) ; } String annotationToValidate ; if ( checkReturn ) { annotationToValidate = CHECK_RETURN_VALUE ; } else if ( canIgnore ) { annotationToValidate = CAN_IGNORE_RETURN_VALUE ; } else { return Description . NO_MATCH ; } if ( method . getKind ( ) != ElementKind . METHOD ) { return Description . NO_MATCH ; } if ( ! ASTHelpers . isVoidType ( method . getReturnType ( ) , state ) ) { return Description . NO_MATCH ; } String message = String . format ( '@%s may not be applied to void-returning methods' , annotationToValidate ) ; return buildDescription ( tree ) . setMessage ( message ) . build ( ) ; }
--------------------------------------------------
