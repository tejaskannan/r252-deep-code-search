public static Template < ? > createTemplate ( Context context , MethodTree decl ) { MethodSymbol declSym = ASTHelpers . getSymbol ( decl ) ; ImmutableClassToInstanceMap < Annotation > annotations = UTemplater . annotationMap ( declSym ) ; ImmutableMap < String , VarSymbol > freeExpressionVars = freeExpressionVariables ( decl ) ; Context subContext = new SubContext ( context ) ; final UTemplater templater = new UTemplater ( freeExpressionVars , subContext ) ; ImmutableMap < String , UType > expressionVarTypes = ImmutableMap . copyOf ( Maps . transformValues ( freeExpressionVars , ( VarSymbol sym ) -> templater . template ( sym . type ) ) ) ; UType genericType = templater . template ( declSym . type ) ; List < UTypeVar > typeParameters ; UMethodType methodType ; if ( genericType instanceof UForAll ) { UForAll forAllType = ( UForAll ) genericType ; typeParameters = forAllType . getTypeVars ( ) ; methodType = ( UMethodType ) forAllType . getQuantifiedType ( ) ; } else if ( genericType instanceof UMethodType ) { typeParameters = ImmutableList . of ( ) ; methodType = ( UMethodType ) genericType ; } else { throw new IllegalArgumentException ( 'expected generictype to be either a forall or a umethodtype, but was ' + genericType ) ; } List < ? extends StatementTree > bodyStatements = decl . getBody ( ) . getStatements ( ) ; if ( bodyStatements . size ( ) == 1 && Iterables . getOnlyElement ( bodyStatements ) . getKind ( ) == Kind . RETURN && context . get ( REQUIRE_BLOCK_KEY ) == null ) { ExpressionTree expression = ( ( ReturnTree ) Iterables . getOnlyElement ( bodyStatements ) ) . getExpression ( ) ; return ExpressionTemplate . create ( annotations , typeParameters , expressionVarTypes , templater . template ( expression ) , methodType . getReturnType ( ) ) ; } else { List < UStatement > templateStatements = new ArrayList < > ( ) ; for ( StatementTree statement : bodyStatements ) { templateStatements . add ( templater . template ( statement ) ) ; } return BlockTemplate . create ( annotations , typeParameters , expressionVarTypes , templateStatements ) ; } }
--------------------------------------------------
private String toAppendMode ( SuggestedFix . Builder fix , Tree appendArg , VisitorState state ) { Boolean value = ASTHelpers . constValue ( appendArg , Boolean . class ) ; if ( value != null ) { if ( value ) { fix . addStaticImport ( 'java.nio.file.standardopenoption.append' ) ; fix . addStaticImport ( 'java.nio.file.standardopenoption.create' ) ; return ', create, append' ; } else { return '' ; } } fix . addImport ( 'java.nio.file.standardopenoption' ) ; fix . addStaticImport ( 'java.nio.file.standardopenoption.append' ) ; fix . addStaticImport ( 'java.nio.file.standardopenoption.create' ) ; return String . format ( ', %s ? new standardopenoption[] {create, append} : new standardopenoption[] {create}' , state . getSourceForNode ( appendArg ) ) ; }
--------------------------------------------------
public String toString ( ) { if ( importStrings . isEmpty ( ) ) { return '' ; } StringBuilder result = new StringBuilder ( ) ; if ( ! hasExistingImports ) { result . append ( '' ) ; } List < ImportOrganizer . Import > imports = importStrings . stream ( ) . map ( ImportOrganizer . Import :: importOf ) . collect ( Collectors . toList ( ) ) ; ImportOrganizer . OrganizedImports organizedImports = importOrganizer . organizeImports ( imports ) ; int expectedImportCount = imports . size ( ) ; int importCount = organizedImports . getImportCount ( ) ; if ( importCount != expectedImportCount ) { throw new IllegalStateException ( String . format ( 'expected %d import(s) in the organized imports but it contained %d' , expectedImportCount , importCount ) ) ; } result . append ( organizedImports . asImportBlock ( ) ) ; String replacementString = result . toString ( ) ; if ( ! hasExistingImports ) { return replacementString ; } else { return CharMatcher . whitespace ( ) . trimTrailingFrom ( replacementString ) ; } }
--------------------------------------------------
private Map < String , Invoker < T >> toInvokers ( List < URL > urls ) { Map < String , Invoker < T >> newUrlInvokerMap = new HashMap < String , Invoker < T >> ( ) ; if ( urls == null || urls . isEmpty ( ) ) { return newUrlInvokerMap ; } Set < String > keys = new HashSet < String > ( ) ; String queryProtocols = this . queryMap . get ( Constants . PROTOCOL_KEY ) ; for ( URL providerUrl : urls ) { if ( queryProtocols != null && queryProtocols . length ( ) > 0 ) { boolean accept = false ; String [ ] acceptProtocols = queryProtocols . split ( ',' ) ; for ( String acceptProtocol : acceptProtocols ) { if ( providerUrl . getProtocol ( ) . equals ( acceptProtocol ) ) { accept = true ; break ; } } if ( ! accept ) { continue ; } } if ( Constants . EMPTY_PROTOCOL . equals ( providerUrl . getProtocol ( ) ) ) { continue ; } if ( ! ExtensionLoader . getExtensionLoader ( Protocol . class ) . hasExtension ( providerUrl . getProtocol ( ) ) ) { logger . error ( new IllegalStateException ( 'unsupported protocol ' + providerUrl . getProtocol ( ) + ' in notified url: ' + providerUrl + ' from registry ' + getUrl ( ) . getAddress ( ) + ' to consumer ' + NetUtils . getLocalHost ( ) + ', supported protocol: ' + ExtensionLoader . getExtensionLoader ( Protocol . class ) . getSupportedExtensions ( ) ) ) ; continue ; } URL url = mergeUrl ( providerUrl ) ; String key = url . toFullString ( ) ; if ( keys . contains ( key ) ) { continue ; } keys . add ( key ) ; Map < String , Invoker < T >> localUrlInvokerMap = this . urlInvokerMap ; Invoker < T > invoker = localUrlInvokerMap == null ? null : localUrlInvokerMap . get ( key ) ; if ( invoker == null ) { try { boolean enabled = true ; if ( url . hasParameter ( Constants . DISABLED_KEY ) ) { enabled = ! url . getParameter ( Constants . DISABLED_KEY , false ) ; } else { enabled = url . getParameter ( Constants . ENABLED_KEY , true ) ; } if ( enabled ) { invoker = new InvokerDelegate < T > ( protocol . refer ( serviceType , url ) , url , providerUrl ) ; } } catch ( Throwable t ) { logger . error ( 'failed to refer invoker for interface:' + serviceType + ',url:(' + url + ')' + t . getMessage ( ) , t ) ; } if ( invoker != null ) { newUrlInvokerMap . put ( key , invoker ) ; } } else { newUrlInvokerMap . put ( key , invoker ) ; } } keys . clear ( ) ; return newUrlInvokerMap ; }
--------------------------------------------------
< ParameterPair > viablePairs ( ) { return formals . stream ( ) . flatMap ( f -> actuals . stream ( ) . map ( a -> ParameterPair . create ( f , a ) ) ) . filter ( p -> costMatrix [ p . formal ( ) . index ( ) ] [ p . actual ( ) . index ( ) ] != Double . POSITIVE_INFINITY ) ; }
--------------------------------------------------
public JavaFileObject forResource ( String fileName ) { Preconditions . checkState ( clazz . isPresent ( ) , 'clazz must be set if you want to add a source from a resource file' ) ; return forResource ( clazz . get ( ) , fileName ) ; }
--------------------------------------------------
private static < A extends AbstractValue < A > , S extends Store < S > , T extends TransferFunction < A , S >> Result < A , S , T > methodDataflow ( TreePath methodPath , Context context , T transfer ) { final ProcessingEnvironment env = JavacProcessingEnvironment . instance ( context ) ; final ControlFlowGraph cfg ; try { cfg = cfgCache . getUnchecked ( CfgParams . create ( methodPath , env ) ) ; } catch ( UncheckedExecutionException e ) { throw e . getCause ( ) instanceof CompletionFailure ? ( CompletionFailure ) e . getCause ( ) : e ; } final AnalysisParams aparams = AnalysisParams . create ( transfer , cfg , env ) ; @ SuppressWarnings ( 'unchecked' ) final Analysis < A , S , T > analysis = ( Analysis < A , S , T > ) analysisCache . getUnchecked ( aparams ) ; return new Result < A , S , T > ( ) { @ Override public Analysis < A , S , T > getAnalysis ( ) { return analysis ; } @ Override public ControlFlowGraph getControlFlowGraph ( ) { return cfg ; } } ; }
--------------------------------------------------
private static void validateTypeStr ( String typeStr ) { if ( typeStr . contains ( '[' ) || typeStr . contains ( ']' ) ) { throw new IllegalArgumentException ( String . format ( 'cannot convert array types (%s), please build them using gettype()' , typeStr ) ) ; } if ( typeStr . contains ( '<' ) || typeStr . contains ( '>' ) ) { throw new IllegalArgumentException ( String . format ( 'cannot convert generic types (%s), please build them using gettype()' , typeStr ) ) ; } }
--------------------------------------------------
public static Object compatibleTypeConvert ( Object value , Class < ? > type ) { if ( value == null || type == null || type . isAssignableFrom ( value . getClass ( ) ) ) { return value ; } if ( value instanceof String ) { String string = ( String ) value ; if ( char . class . equals ( type ) || Character . class . equals ( type ) ) { if ( string . length ( ) != 1 ) { throw new IllegalArgumentException ( String . format ( 'can not convert string(%s) to char!' '+' ' when convert string to char, the string must only 1 char.' , string ) ) ; } return string . charAt ( 0 ) ; } else if ( type . isEnum ( ) ) { return Enum . valueOf ( ( Class < Enum > ) type , string ) ; } else if ( type == BigInteger . class ) { return new BigInteger ( string ) ; } else if ( type == BigDecimal . class ) { return new BigDecimal ( string ) ; } else if ( type == Short . class || type == short . class ) { return new Short ( string ) ; } else if ( type == Integer . class || type == int . class ) { return new Integer ( string ) ; } else if ( type == Long . class || type == long . class ) { return new Long ( string ) ; } else if ( type == Double . class || type == double . class ) { return new Double ( string ) ; } else if ( type == Float . class || type == float . class ) { return new Float ( string ) ; } else if ( type == Byte . class || type == byte . class ) { return new Byte ( string ) ; } else if ( type == Boolean . class || type == boolean . class ) { return new Boolean ( string ) ; } else if ( type == Date . class || type == java . sql . Date . class || type == java . sql . Timestamp . class || type == java . sql . Time . class ) { try { Date date = new SimpleDateFormat ( DATE_FORMAT ) . parse ( ( String ) value ) ; if ( type == java . sql . Date . class ) { return new java . sql . Date ( date . getTime ( ) ) ; } else if ( type == java . sql . Timestamp . class ) { return new java . sql . Timestamp ( date . getTime ( ) ) ; } else if ( type == java . sql . Time . class ) { return new java . sql . Time ( date . getTime ( ) ) ; } else { return date ; } } catch ( ParseException e ) { throw new IllegalStateException ( 'failed to parse date ' + value + ' by format ' + DATE_FORMAT + ', cause: ' + e . getMessage ( ) , e ) ; } } else if ( type == Class . class ) { try { return ReflectUtils . name2class ( ( String ) value ) ; } catch ( ClassNotFoundException e ) { throw new RuntimeException ( e . getMessage ( ) , e ) ; } } else if ( char [ ] . class . equals ( type ) ) { int len = string . length ( ) ; char [ ] chars = new char [ len ] ; string . getChars ( 0 , len , chars , 0 ) ; return chars ; } } else if ( value instanceof Number ) { Number number = ( Number ) value ; if ( type == byte . class || type == Byte . class ) { return number . byteValue ( ) ; } else if ( type == short . class || type == Short . class ) { return number . shortValue ( ) ; } else if ( type == int . class || type == Integer . class ) { return number . intValue ( ) ; } else if ( type == long . class || type == Long . class ) { return number . longValue ( ) ; } else if ( type == float . class || type == Float . class ) { return number . floatValue ( ) ; } else if ( type == double . class || type == Double . class ) { return number . doubleValue ( ) ; } else if ( type == BigInteger . class ) { return BigInteger . valueOf ( number . longValue ( ) ) ; } else if ( type == BigDecimal . class ) { return BigDecimal . valueOf ( number . doubleValue ( ) ) ; } else if ( type == Date . class ) { return new Date ( number . longValue ( ) ) ; } } else if ( value instanceof Collection ) { Collection collection = ( Collection ) value ; if ( type . isArray ( ) ) { int length = collection . size ( ) ; Object array = Array . newInstance ( type . getComponentType ( ) , length ) ; int i = 0 ; for ( Object item : collection ) { Array . set ( array , i ++ , item ) ; } return array ; } else if ( ! type . isInterface ( ) ) { try { Collection result = ( Collection ) type . newInstance ( ) ; result . addAll ( collection ) ; return result ; } catch ( Throwable e ) { } } else if ( type == List . class ) { return new ArrayList < Object > ( collection ) ; } else if ( type == Set . class ) { return new HashSet < Object > ( collection ) ; } } else if ( value . getClass ( ) . isArray ( ) && Collection . class . isAssignableFrom ( type ) ) { Collection collection ; if ( ! type . isInterface ( ) ) { try { collection = ( Collection ) type . newInstance ( ) ; } catch ( Throwable e ) { collection = new ArrayList < Object > ( ) ; } } else if ( type == Set . class ) { collection = new HashSet < Object > ( ) ; } else { collection = new ArrayList < Object > ( ) ; } int length = Array . getLength ( value ) ; for ( int i = 0 ; i < length ; i ++ ) { collection . add ( Array . get ( value , i ) ) ; } return collection ; } return value ; }
--------------------------------------------------
private Description makeDescription ( String rejectedJUnit4 , Tree tree ) { Description . Builder builder = buildDescription ( tree ) . setMessage ( String . format ( '%s cannot be used inside a junit3 class. convert your class to junit4 style.' , rejectedJUnit4 ) ) ; return builder . build ( ) ; }
--------------------------------------------------
