private String generateInvocationArgumentNullCheck ( Method method ) { Class < ? > [ ] pts = method . getParameterTypes ( ) ; return IntStream . range ( 0 , pts . length ) . filter ( i -> CLASSNAME_INVOCATION . equals ( pts [ i ] . getName ( ) ) ) . mapToObj ( i -> String . format ( CODE_INVOCATION_ARGUMENT_NULL_CHECK , i , i ) ) . findFirst ( ) . orElse ( '' ) ; }
--------------------------------------------------
private String generateMethodArguments ( Method method ) { Class < ? > [ ] pts = method . getParameterTypes ( ) ; return IntStream . range ( 0 , pts . length ) . mapToObj ( i -> String . format ( CODE_METHOD_ARGUMENT , pts [ i ] . getCanonicalName ( ) , i ) ) . collect ( Collectors . joining ( ', ' ) ) ; }
--------------------------------------------------
private String generateExtNameAssignment ( String [ ] value , boolean hasInvocation ) { String getNameCode = null ; for ( int i = value . length - 1 ; i >= 0 ; -- i ) { if ( i == value . length - 1 ) { if ( null != defaultExtName ) { if ( ! 'protocol' . equals ( value [ i ] ) ) { if ( hasInvocation ) { getNameCode = String . format ( 'url.getmethodparameter(methodname, '%s', '%s')' , value [ i ] , defaultExtName ) ; } else { getNameCode = String . format ( 'url.getparameter('%s', '%s')' , value [ i ] , defaultExtName ) ; } } else { getNameCode = String . format ( '( url.getprotocol() == null ? '%s' : url.getprotocol() )' , defaultExtName ) ; } } else { if ( ! 'protocol' . equals ( value [ i ] ) ) { if ( hasInvocation ) { getNameCode = String . format ( 'url.getmethodparameter(methodname, '%s', '%s')' , value [ i ] , defaultExtName ) ; } else { getNameCode = String . format ( 'url.getparameter('%s')' , value [ i ] ) ; } } else { getNameCode = 'url.getprotocol()' ; } } } else { if ( ! 'protocol' . equals ( value [ i ] ) ) { if ( hasInvocation ) { getNameCode = String . format ( 'url.getmethodparameter(methodname, '%s', '%s')' , value [ i ] , defaultExtName ) ; } else { getNameCode = String . format ( 'url.getparameter('%s', %s)' , value [ i ] , getNameCode ) ; } } else { getNameCode = String . format ( 'url.getprotocol() == null ? (%s) : url.getprotocol()' , getNameCode ) ; } } } return String . format ( CODE_EXT_NAME_ASSIGNMENT , getNameCode ) ; }
--------------------------------------------------
private String generateUrlAssignmentIndirectly ( Method method ) { Class < ? > [ ] pts = method . getParameterTypes ( ) ; for ( int i = 0 ; i < pts . length ; ++ i ) { for ( Method m : pts [ i ] . getMethods ( ) ) { String name = m . getName ( ) ; if ( ( name . startsWith ( 'get' ) || name . length ( ) > 3 ) && Modifier . isPublic ( m . getModifiers ( ) ) && ! Modifier . isStatic ( m . getModifiers ( ) ) && m . getParameterTypes ( ) . length == 0 && m . getReturnType ( ) == URL . class ) { return generateGetUrlNullCheck ( i , pts [ i ] , name ) ; } } } throw new IllegalStateException ( 'failed to create adaptive class for interface ' + type . getName ( ) + ': not found url parameter or url attribute in parameters of method ' + method . getName ( ) ) ; }
--------------------------------------------------
private static String cacheString ( final char [ ] charBuf , final String [ ] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; if ( count < 1 ) return '' ; int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ; String cached = stringCache [ index ] ; if ( cached == null ) { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } else { if ( rangeEquals ( charBuf , start , count , cached ) ) { return cached ; } else { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } } return cached ; }
--------------------------------------------------
public static Object compatibleTypeConvert ( Object value , Class < ? > type ) { if ( value == null || type == null || type . isAssignableFrom ( value . getClass ( ) ) ) { return value ; } if ( value instanceof String ) { String string = ( String ) value ; if ( char . class . equals ( type ) || Character . class . equals ( type ) ) { if ( string . length ( ) != 1 ) { throw new IllegalArgumentException ( String . format ( 'can not convert string(%s) to char!' '+' ' when convert string to char, the string must only 1 char.' , string ) ) ; } return string . charAt ( 0 ) ; } else if ( type . isEnum ( ) ) { return Enum . valueOf ( ( Class < Enum > ) type , string ) ; } else if ( type == BigInteger . class ) { return new BigInteger ( string ) ; } else if ( type == BigDecimal . class ) { return new BigDecimal ( string ) ; } else if ( type == Short . class || type == short . class ) { return new Short ( string ) ; } else if ( type == Integer . class || type == int . class ) { return new Integer ( string ) ; } else if ( type == Long . class || type == long . class ) { return new Long ( string ) ; } else if ( type == Double . class || type == double . class ) { return new Double ( string ) ; } else if ( type == Float . class || type == float . class ) { return new Float ( string ) ; } else if ( type == Byte . class || type == byte . class ) { return new Byte ( string ) ; } else if ( type == Boolean . class || type == boolean . class ) { return new Boolean ( string ) ; } else if ( type == Date . class || type == java . sql . Date . class || type == java . sql . Timestamp . class || type == java . sql . Time . class ) { try { Date date = new SimpleDateFormat ( DATE_FORMAT ) . parse ( ( String ) value ) ; if ( type == java . sql . Date . class ) { return new java . sql . Date ( date . getTime ( ) ) ; } else if ( type == java . sql . Timestamp . class ) { return new java . sql . Timestamp ( date . getTime ( ) ) ; } else if ( type == java . sql . Time . class ) { return new java . sql . Time ( date . getTime ( ) ) ; } else { return date ; } } catch ( ParseException e ) { throw new IllegalStateException ( 'failed to parse date ' + value + ' by format ' + DATE_FORMAT + ', cause: ' + e . getMessage ( ) , e ) ; } } else if ( type == Class . class ) { try { return ReflectUtils . name2class ( ( String ) value ) ; } catch ( ClassNotFoundException e ) { throw new RuntimeException ( e . getMessage ( ) , e ) ; } } else if ( char [ ] . class . equals ( type ) ) { int len = string . length ( ) ; char [ ] chars = new char [ len ] ; string . getChars ( 0 , len , chars , 0 ) ; return chars ; } } else if ( value instanceof Number ) { Number number = ( Number ) value ; if ( type == byte . class || type == Byte . class ) { return number . byteValue ( ) ; } else if ( type == short . class || type == Short . class ) { return number . shortValue ( ) ; } else if ( type == int . class || type == Integer . class ) { return number . intValue ( ) ; } else if ( type == long . class || type == Long . class ) { return number . longValue ( ) ; } else if ( type == float . class || type == Float . class ) { return number . floatValue ( ) ; } else if ( type == double . class || type == Double . class ) { return number . doubleValue ( ) ; } else if ( type == BigInteger . class ) { return BigInteger . valueOf ( number . longValue ( ) ) ; } else if ( type == BigDecimal . class ) { return BigDecimal . valueOf ( number . doubleValue ( ) ) ; } else if ( type == Date . class ) { return new Date ( number . longValue ( ) ) ; } } else if ( value instanceof Collection ) { Collection collection = ( Collection ) value ; if ( type . isArray ( ) ) { int length = collection . size ( ) ; Object array = Array . newInstance ( type . getComponentType ( ) , length ) ; int i = 0 ; for ( Object item : collection ) { Array . set ( array , i ++ , item ) ; } return array ; } else if ( ! type . isInterface ( ) ) { try { Collection result = ( Collection ) type . newInstance ( ) ; result . addAll ( collection ) ; return result ; } catch ( Throwable e ) { } } else if ( type == List . class ) { return new ArrayList < Object > ( collection ) ; } else if ( type == Set . class ) { return new HashSet < Object > ( collection ) ; } } else if ( value . getClass ( ) . isArray ( ) && Collection . class . isAssignableFrom ( type ) ) { Collection collection ; if ( ! type . isInterface ( ) ) { try { collection = ( Collection ) type . newInstance ( ) ; } catch ( Throwable e ) { collection = new ArrayList < Object > ( ) ; } } else if ( type == Set . class ) { collection = new HashSet < Object > ( ) ; } else { collection = new ArrayList < Object > ( ) ; } int length = Array . getLength ( value ) ; for ( int i = 0 ; i < length ; i ++ ) { collection . add ( Array . get ( value , i ) ) ; } return collection ; } return value ; }
--------------------------------------------------
