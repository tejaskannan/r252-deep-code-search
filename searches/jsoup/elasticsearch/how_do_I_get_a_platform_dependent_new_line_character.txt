private String drawSeparationLine ( final int [ ] widthCacheArray ) { final StringBuilder separationLineSB = new StringBuilder ( ) ; final int lastCol = indexLastCol ( widthCacheArray ) ; final int colCount = widthCacheArray . length ; for ( int colIndex = 0 ; colIndex < colCount ; colIndex ++ ) { final int width = widthCacheArray [ colIndex ] ; if ( width <= 0 ) { continue ; } final boolean isFirstCol = colIndex == 0 ; final boolean isLastCol = colIndex == lastCol ; if ( isFirstCol && border . has ( Border . BORDER_OUTER_LEFT ) ) { separationLineSB . append ( '+' ) ; } if ( ! isFirstCol && border . has ( Border . BORDER_INNER_V ) ) { separationLineSB . append ( '+' ) ; } separationLineSB . append ( repeat ( '-' , width + 2 * padding ) ) ; if ( isLastCol && border . has ( Border . BORDER_OUTER_RIGHT ) ) { separationLineSB . append ( '+' ) ; } } return separationLineSB . toString ( ) ; }
--------------------------------------------------
private static String getFromFile ( String file ) { file = file . substring ( 0 , file . length ( ) - 4 ) ; int i = file . lastIndexOf ( '/' ) ; if ( i >= 0 ) { file = file . substring ( i + 1 ) ; } i = file . indexOf ( '-' ) ; if ( i >= 0 ) { file = file . substring ( i + 1 ) ; } while ( file . length ( ) > 0 && ! Character . isDigit ( file . charAt ( 0 ) ) ) { i = file . indexOf ( '-' ) ; if ( i >= 0 ) { file = file . substring ( i + 1 ) ; } else { break ; } } return file ; }
--------------------------------------------------
private < T > ExporterChangeableWrapper doChangeLocalExport ( final Invoker < T > originInvoker , URL newInvokerUrl ) { String key = getCacheKey ( originInvoker ) ; final ExporterChangeableWrapper < T > exporter = ( ExporterChangeableWrapper < T > ) bounds . get ( key ) ; if ( exporter == null ) { logger . warn ( new IllegalStateException ( 'error state, exporter should not be null' ) ) ; } else { final Invoker < T > invokerDelegate = new InvokerDelegate < T > ( originInvoker , newInvokerUrl ) ; exporter . setExporter ( protocol . export ( invokerDelegate ) ) ; } return exporter ; }
--------------------------------------------------
public static String getName ( final Method m ) { StringBuilder ret = new StringBuilder ( ) ; ret . append ( getName ( m . getReturnType ( ) ) ) . append ( ' ' ) ; ret . append ( m . getName ( ) ) . append ( '(' ) ; Class < ? > [ ] parameterTypes = m . getParameterTypes ( ) ; for ( int i = 0 ; i < parameterTypes . length ; i ++ ) { if ( i > 0 ) { ret . append ( ',' ) ; } ret . append ( getName ( parameterTypes [ i ] ) ) ; } ret . append ( ')' ) ; return ret . toString ( ) ; }
--------------------------------------------------
public static String getName ( final Constructor < ? > c ) { StringBuilder ret = new StringBuilder ( '(' ) ; Class < ? > [ ] parameterTypes = c . getParameterTypes ( ) ; for ( int i = 0 ; i < parameterTypes . length ; i ++ ) { if ( i > 0 ) { ret . append ( ',' ) ; } ret . append ( getName ( parameterTypes [ i ] ) ) ; } ret . append ( ')' ) ; return ret . toString ( ) ; }
--------------------------------------------------
public static String getDesc ( final Method m ) { StringBuilder ret = new StringBuilder ( m . getName ( ) ) . append ( '(' ) ; Class < ? > [ ] parameterTypes = m . getParameterTypes ( ) ; for ( int i = 0 ; i < parameterTypes . length ; i ++ ) { ret . append ( getDesc ( parameterTypes [ i ] ) ) ; } ret . append ( ')' ) . append ( getDesc ( m . getReturnType ( ) ) ) ; return ret . toString ( ) ; }
--------------------------------------------------
public static String getDesc ( final Constructor < ? > c ) { StringBuilder ret = new StringBuilder ( '(' ) ; Class < ? > [ ] parameterTypes = c . getParameterTypes ( ) ; for ( int i = 0 ; i < parameterTypes . length ; i ++ ) { ret . append ( getDesc ( parameterTypes [ i ] ) ) ; } ret . append ( ')' ) . append ( 'v' ) ; return ret . toString ( ) ; }
--------------------------------------------------
public static Proxy getProxy ( ClassLoader cl , Class < ? > ... ics ) { if ( ics . length > Constants . MAX_PROXY_COUNT ) { throw new IllegalArgumentException ( 'interface limit exceeded' ) ; } StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < ics . length ; i ++ ) { String itf = ics [ i ] . getName ( ) ; if ( ! ics [ i ] . isInterface ( ) ) { throw new RuntimeException ( itf + ' is not a interface.' ) ; } Class < ? > tmp = null ; try { tmp = Class . forName ( itf , false , cl ) ; } catch ( ClassNotFoundException e ) { } if ( tmp != ics [ i ] ) { throw new IllegalArgumentException ( ics [ i ] + ' is not visible from class loader' ) ; } sb . append ( itf ) . append ( ';' ) ; } String key = sb . toString ( ) ; Map < String , Object > cache ; synchronized ( ProxyCacheMap ) { cache = ProxyCacheMap . computeIfAbsent ( cl , k -> new HashMap < > ( ) ) ; } Proxy proxy = null ; synchronized ( cache ) { do { Object value = cache . get ( key ) ; if ( value instanceof Reference < ? > ) { proxy = ( Proxy ) ( ( Reference < ? > ) value ) . get ( ) ; if ( proxy != null ) { return proxy ; } } if ( value == PendingGenerationMarker ) { try { cache . wait ( ) ; } catch ( InterruptedException e ) { } } else { cache . put ( key , PendingGenerationMarker ) ; break ; } } while ( true ) ; } long id = PROXY_CLASS_COUNTER . getAndIncrement ( ) ; String pkg = null ; ClassGenerator ccp = null , ccm = null ; try { ccp = ClassGenerator . newInstance ( cl ) ; Set < String > worked = new HashSet < > ( ) ; List < Method > methods = new ArrayList < > ( ) ; for ( int i = 0 ; i < ics . length ; i ++ ) { if ( ! Modifier . isPublic ( ics [ i ] . getModifiers ( ) ) ) { String npkg = ics [ i ] . getPackage ( ) . getName ( ) ; if ( pkg == null ) { pkg = npkg ; } else { if ( ! pkg . equals ( npkg ) ) { throw new IllegalArgumentException ( 'non-public interfaces from different packages' ) ; } } } ccp . addInterface ( ics [ i ] ) ; for ( Method method : ics [ i ] . getMethods ( ) ) { String desc = ReflectUtils . getDesc ( method ) ; if ( worked . contains ( desc ) ) { continue ; } worked . add ( desc ) ; int ix = methods . size ( ) ; Class < ? > rt = method . getReturnType ( ) ; Class < ? > [ ] pts = method . getParameterTypes ( ) ; StringBuilder code = new StringBuilder ( 'object[] args = new object[' ) . append ( pts . length ) . append ( '];' ) ; for ( int j = 0 ; j < pts . length ; j ++ ) { code . append ( ' args[' ) . append ( j ) . append ( '] = ($w)$' ) . append ( j + 1 ) . append ( ';' ) ; } code . append ( ' object ret = handler.invoke(this, methods[' ) . append ( ix ) . append ( '], args);' ) ; if ( ! Void . TYPE . equals ( rt ) ) { code . append ( ' return ' ) . append ( asArgument ( rt , 'ret' ) ) . append ( ';' ) ; } methods . add ( method ) ; ccp . addMethod ( method . getName ( ) , method . getModifiers ( ) , rt , pts , method . getExceptionTypes ( ) , code . toString ( ) ) ; } } if ( pkg == null ) { pkg = PACKAGE_NAME ; } String pcn = pkg + '.proxy' + id ; ccp . setClassName ( pcn ) ; ccp . addField ( 'public static java.lang.reflect.method[] methods;' ) ; ccp . addField ( 'private ' + InvocationHandler . class . getName ( ) + ' handler;' ) ; ccp . addConstructor ( Modifier . PUBLIC , new Class < ? > [ ] { InvocationHandler . class } , new Class < ? > [ 0 ] , 'handler=$1;' ) ; ccp . addDefaultConstructor ( ) ; Class < ? > clazz = ccp . toClass ( ) ; clazz . getField ( 'methods' ) . set ( null , methods . toArray ( new Method [ 0 ] ) ) ; String fcn = Proxy . class . getName ( ) + id ; ccm = ClassGenerator . newInstance ( cl ) ; ccm . setClassName ( fcn ) ; ccm . addDefaultConstructor ( ) ; ccm . setSuperClass ( Proxy . class ) ; ccm . addMethod ( 'public object newinstance(' + InvocationHandler . class . getName ( ) + ' h){ return new ' + pcn + '($1); }' ) ; Class < ? > pc = ccm . toClass ( ) ; proxy = ( Proxy ) pc . newInstance ( ) ; } catch ( RuntimeException e ) { throw e ; } catch ( Exception e ) { throw new RuntimeException ( e . getMessage ( ) , e ) ; } finally { if ( ccp != null ) { ccp . release ( ) ; } if ( ccm != null ) { ccm . release ( ) ; } synchronized ( cache ) { if ( proxy == null ) { cache . remove ( key ) ; } else { cache . put ( key , new WeakReference < Proxy > ( proxy ) ) ; } cache . notifyAll ( ) ; } } return proxy ; }
--------------------------------------------------
public static String getName ( Class < ? > c ) { if ( c . isArray ( ) ) { StringBuilder sb = new StringBuilder ( ) ; do { sb . append ( '[]' ) ; c = c . getComponentType ( ) ; } while ( c . isArray ( ) ) ; return c . getName ( ) + sb . toString ( ) ; } return c . getName ( ) ; }
--------------------------------------------------
public static int getEditDistance ( String source , String target , boolean caseSensitive ) { int sourceLength = isEmptyOrWhitespace ( source ) ? 0 : source . length ( ) ; int targetLength = isEmptyOrWhitespace ( target ) ? 0 : target . length ( ) ; if ( sourceLength == 0 ) { return targetLength ; } if ( targetLength == 0 ) { return sourceLength ; } if ( ! caseSensitive ) { source = Ascii . toLowerCase ( source ) ; target = Ascii . toLowerCase ( target ) ; } int [ ] [ ] levMatrix = new int [ sourceLength + 1 ] [ targetLength + 1 ] ; for ( int i = 0 ; i <= sourceLength ; i ++ ) { levMatrix [ i ] [ 0 ] = i ; } for ( int i = 0 ; i <= targetLength ; i ++ ) { levMatrix [ 0 ] [ i ] = i ; } for ( int i = 1 ; i <= sourceLength ; i ++ ) { char sourceI = source . charAt ( i - 1 ) ; for ( int j = 1 ; j <= targetLength ; j ++ ) { char targetJ = target . charAt ( j - 1 ) ; int cost = 0 ; if ( sourceI != targetJ ) { cost = 1 ; } levMatrix [ i ] [ j ] = Ints . min ( cost + levMatrix [ i - 1 ] [ j - 1 ] , levMatrix [ i - 1 ] [ j ] + 1 , levMatrix [ i ] [ j - 1 ] + 1 ) ; } } return levMatrix [ sourceLength ] [ targetLength ] ; }
--------------------------------------------------
