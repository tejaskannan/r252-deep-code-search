private Object toFile ( VisitorState state , Tree fileArg , SuggestedFix . Builder fix ) { Type type = ASTHelpers . getType ( fileArg ) ; if ( ASTHelpers . isSubtype ( type , state . getSymtab ( ) . stringType , state ) ) { fix . addImport ( 'java.io.file' ) ; return String . format ( 'new file(%s)' , state . getSourceForNode ( fileArg ) ) ; } else if ( ASTHelpers . isSubtype ( type , state . getTypeFromString ( 'java.io.file' ) , state ) ) { return state . getSourceForNode ( fileArg ) ; } else { throw new AssertionError ( 'unexpected type: ' + type ) ; } }
--------------------------------------------------
private static ImmutableList < String > setCompilePolicyToByFile ( ImmutableList < String > args ) { for ( String arg : args ) { if ( arg . startsWith ( '-xdcompilepolicy' ) ) { String value = arg . substring ( arg . indexOf ( '=' ) + 1 ) ; checkCompilePolicy ( value ) ; return args ; } } return ImmutableList . < String > builder ( ) . addAll ( args ) . add ( '-xdcompilepolicy=byfile' ) . build ( ) ; }
--------------------------------------------------
public JavaFileObject forResource ( String fileName ) { Preconditions . checkState ( clazz . isPresent ( ) , 'clazz must be set if you want to add a source from a resource file' ) ; return forResource ( clazz . get ( ) , fileName ) ; }
--------------------------------------------------
public static void writeLines ( File file , String [ ] lines ) throws IOException { if ( file == null ) { throw new IOException ( 'file is null.' ) ; } writeLines ( new FileOutputStream ( file ) , lines ) ; }
--------------------------------------------------
public CompilationTestHelper addSourceFile ( String path ) { this . sources . add ( fileManager . forResource ( path ) ) ; return this ; }
--------------------------------------------------
void writeToClientMap ( List < String > addressList , ZookeeperClient zookeeperClient ) { for ( String address : addressList ) { zookeeperClientMap . put ( address , zookeeperClient ) ; } }
--------------------------------------------------
public String toString ( ) { if ( importStrings . isEmpty ( ) ) { return '' ; } StringBuilder result = new StringBuilder ( ) ; if ( ! hasExistingImports ) { result . append ( '' ) ; } List < ImportOrganizer . Import > imports = importStrings . stream ( ) . map ( ImportOrganizer . Import :: importOf ) . collect ( Collectors . toList ( ) ) ; ImportOrganizer . OrganizedImports organizedImports = importOrganizer . organizeImports ( imports ) ; int expectedImportCount = imports . size ( ) ; int importCount = organizedImports . getImportCount ( ) ; if ( importCount != expectedImportCount ) { throw new IllegalStateException ( String . format ( 'expected %d import(s) in the organized imports but it contained %d' , expectedImportCount , importCount ) ) ; } result . append ( organizedImports . asImportBlock ( ) ) ; String replacementString = result . toString ( ) ; if ( ! hasExistingImports ) { return replacementString ; } else { return CharMatcher . whitespace ( ) . trimTrailingFrom ( replacementString ) ; } }
--------------------------------------------------
public Diff toProto ( ) { ApiDiffProto . Diff . Builder builder = ApiDiffProto . Diff . newBuilder ( ) ; for ( String className : unsupportedClasses ( ) ) { builder . addClassDiff ( ApiDiffProto . ClassDiff . newBuilder ( ) . setEverythingDiff ( ApiDiffProto . EverythingDiff . newBuilder ( ) . setClassName ( className ) ) ) ; } for ( String className : unsupportedMembersByClass ( ) . keySet ( ) ) { ApiDiffProto . MemberDiff . Builder memberDiff = ApiDiffProto . MemberDiff . newBuilder ( ) . setClassName ( className ) ; for ( ClassMemberKey member : unsupportedMembersByClass ( ) . get ( className ) ) { memberDiff . addMember ( ApiDiffProto . ClassMember . newBuilder ( ) . setIdentifier ( member . identifier ( ) ) . setMemberDescriptor ( member . descriptor ( ) ) ) ; } builder . addClassDiff ( ApiDiffProto . ClassDiff . newBuilder ( ) . setMemberDiff ( memberDiff ) ) ; } return builder . build ( ) ; }
--------------------------------------------------
public String chompTo ( String seq ) { String data = consumeTo ( seq ) ; matchChomp ( seq ) ; return data ; }
--------------------------------------------------
public static String toString ( String msg , Throwable e ) { UnsafeStringWriter w = new UnsafeStringWriter ( ) ; w . write ( msg + '' ) ; PrintWriter p = new PrintWriter ( w ) ; try { e . printStackTrace ( p ) ; return w . toString ( ) ; } finally { p . close ( ) ; } }
--------------------------------------------------
