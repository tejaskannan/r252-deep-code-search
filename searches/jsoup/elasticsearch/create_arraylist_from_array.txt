private static Class < ? > [ ] desc2classArray ( ClassLoader cl , String desc ) throws ClassNotFoundException { if ( desc . length ( ) == 0 ) { return EMPTY_CLASS_ARRAY ; } List < Class < ? >> cs = new ArrayList < Class < ? >> ( ) ; Matcher m = DESC_PATTERN . matcher ( desc ) ; while ( m . find ( ) ) { cs . add ( desc2class ( cl , m . group ( ) ) ) ; } return cs . toArray ( EMPTY_CLASS_ARRAY ) ; }
--------------------------------------------------
private < T > Bindings createBindings ( List < Invoker < T >> invokers , Invocation invocation ) { Bindings bindings = engine . createBindings ( ) ; bindings . put ( 'invokers' , new ArrayList < > ( invokers ) ) ; bindings . put ( 'invocation' , invocation ) ; bindings . put ( 'context' , RpcContext . getContext ( ) ) ; return bindings ; }
--------------------------------------------------
public static AccessPath fromFieldAccess ( FieldAccessNode fieldAccess ) { ImmutableList . Builder < String > pathBuilder = ImmutableList . builder ( ) ; Tree tree = fieldAccess . getTree ( ) ; boolean isFieldAccess ; while ( ( isFieldAccess = TreeUtils . isFieldAccess ( tree ) ) || isAutoValueAccessor ( tree ) ) { if ( isFieldAccess ) { pathBuilder . add ( TreeUtils . getFieldName ( tree ) ) ; } else { tree = ( ( MethodInvocationTree ) tree ) . getMethodSelect ( ) ; pathBuilder . add ( TreeUtils . getMethodName ( tree ) + '()' ) ; } if ( tree . getKind ( ) == Kind . IDENTIFIER ) { return AccessPath . create ( null , pathBuilder . build ( ) ) ; } tree = ( ( MemberSelectTree ) tree ) . getExpression ( ) ; } if ( tree . getKind ( ) == Kind . IDENTIFIER && ( ( IdentifierTree ) tree ) . getName ( ) . contentEquals ( 'this' ) ) { return AccessPath . create ( null , pathBuilder . build ( ) ) ; } if ( tree . getKind ( ) == Kind . IDENTIFIER ) { return AccessPath . create ( TreeUtils . elementFromTree ( tree ) , pathBuilder . build ( ) ) ; } return null ; }
--------------------------------------------------
public static ApiDiff fromProto ( Diff diff ) { ImmutableSet . Builder < String > unsupportedClasses = ImmutableSet . builder ( ) ; ImmutableSetMultimap . Builder < String , ClassMemberKey > unsupportedMembersByClass = ImmutableSetMultimap . builder ( ) ; for ( ApiDiffProto . ClassDiff c : diff . getClassDiffList ( ) ) { switch ( c . getDiffCase ( ) ) { case EVERYTHING_DIFF : unsupportedClasses . add ( c . getEverythingDiff ( ) . getClassName ( ) ) ; break ; case MEMBER_DIFF : ApiDiffProto . MemberDiff memberDiff = c . getMemberDiff ( ) ; for ( ApiDiffProto . ClassMember member : memberDiff . getMemberList ( ) ) { unsupportedMembersByClass . put ( memberDiff . getClassName ( ) , ClassMemberKey . create ( member . getIdentifier ( ) , member . getMemberDescriptor ( ) ) ) ; } break ; default : throw new AssertionError ( c . getDiffCase ( ) ) ; } } return new AutoValue_ApiDiff ( unsupportedClasses . build ( ) , unsupportedMembersByClass . build ( ) ) ; }
--------------------------------------------------
public static Template < ? > createTemplate ( Context context , MethodTree decl ) { MethodSymbol declSym = ASTHelpers . getSymbol ( decl ) ; ImmutableClassToInstanceMap < Annotation > annotations = UTemplater . annotationMap ( declSym ) ; ImmutableMap < String , VarSymbol > freeExpressionVars = freeExpressionVariables ( decl ) ; Context subContext = new SubContext ( context ) ; final UTemplater templater = new UTemplater ( freeExpressionVars , subContext ) ; ImmutableMap < String , UType > expressionVarTypes = ImmutableMap . copyOf ( Maps . transformValues ( freeExpressionVars , ( VarSymbol sym ) -> templater . template ( sym . type ) ) ) ; UType genericType = templater . template ( declSym . type ) ; List < UTypeVar > typeParameters ; UMethodType methodType ; if ( genericType instanceof UForAll ) { UForAll forAllType = ( UForAll ) genericType ; typeParameters = forAllType . getTypeVars ( ) ; methodType = ( UMethodType ) forAllType . getQuantifiedType ( ) ; } else if ( genericType instanceof UMethodType ) { typeParameters = ImmutableList . of ( ) ; methodType = ( UMethodType ) genericType ; } else { throw new IllegalArgumentException ( 'expected generictype to be either a forall or a umethodtype, but was ' + genericType ) ; } List < ? extends StatementTree > bodyStatements = decl . getBody ( ) . getStatements ( ) ; if ( bodyStatements . size ( ) == 1 && Iterables . getOnlyElement ( bodyStatements ) . getKind ( ) == Kind . RETURN && context . get ( REQUIRE_BLOCK_KEY ) == null ) { ExpressionTree expression = ( ( ReturnTree ) Iterables . getOnlyElement ( bodyStatements ) ) . getExpression ( ) ; return ExpressionTemplate . create ( annotations , typeParameters , expressionVarTypes , templater . template ( expression ) , methodType . getReturnType ( ) ) ; } else { List < UStatement > templateStatements = new ArrayList < > ( ) ; for ( StatementTree statement : bodyStatements ) { templateStatements . add ( templater . template ( statement ) ) ; } return BlockTemplate . create ( annotations , typeParameters , expressionVarTypes , templateStatements ) ; } }
--------------------------------------------------
public static ScannerSupplier fromBugCheckerClasses ( Iterable < Class < ? extends BugChecker >> checkers ) { ImmutableList . Builder < BugCheckerInfo > builder = ImmutableList . builder ( ) ; for ( Class < ? extends BugChecker > checker : checkers ) { builder . add ( BugCheckerInfo . create ( checker ) ) ; } return fromBugCheckerInfos ( builder . build ( ) ) ; }
--------------------------------------------------
public ZookeeperClient connect ( URL url ) { ZookeeperClient zookeeperClient ; List < String > addressList = getURLBackupAddress ( url ) ; if ( ( zookeeperClient = fetchAndUpdateZookeeperClientCache ( addressList ) ) != null && zookeeperClient . isConnected ( ) ) { logger . info ( 'find valid zookeeper client from the cache for address: ' + url ) ; return zookeeperClient ; } synchronized ( zookeeperClientMap ) { if ( ( zookeeperClient = fetchAndUpdateZookeeperClientCache ( addressList ) ) != null && zookeeperClient . isConnected ( ) ) { logger . info ( 'find valid zookeeper client from the cache for address: ' + url ) ; return zookeeperClient ; } zookeeperClient = createZookeeperClient ( toClientURL ( url ) ) ; logger . info ( 'no valid zookeeper client found from cache, therefore create a new client for url. ' + url ) ; writeToClientMap ( addressList , zookeeperClient ) ; } return zookeeperClient ; }
--------------------------------------------------
protected List < Type > actualTypes ( Inliner inliner ) { ArrayList < Type > result = new ArrayList < > ( ) ; ImmutableList < String > argNames = expressionArgumentTypes ( ) . keySet ( ) . asList ( ) ; for ( int i = 0 ; i < expressionArgumentTypes ( ) . size ( ) ; i ++ ) { String argName = argNames . get ( i ) ; Optional < JCExpression > singleBinding = inliner . getOptionalBinding ( new UFreeIdent . Key ( argName ) ) ; if ( singleBinding . isPresent ( ) ) { result . add ( singleBinding . get ( ) . type ) ; } else { Optional < java . util . List < JCExpression >> exprs = inliner . getOptionalBinding ( new URepeated . Key ( argName ) ) ; if ( exprs . isPresent ( ) && ! exprs . get ( ) . isEmpty ( ) ) { Type [ ] exprTys = new Type [ exprs . get ( ) . size ( ) ] ; for ( int j = 0 ; j < exprs . get ( ) . size ( ) ; j ++ ) { exprTys [ j ] = exprs . get ( ) . get ( j ) . type ; } result . add ( inliner . types ( ) . lub ( List . from ( exprTys ) ) ) ; } } } for ( PlaceholderExpressionKey key : Ordering . natural ( ) . immutableSortedCopy ( Iterables . filter ( inliner . bindings . keySet ( ) , PlaceholderExpressionKey . class ) ) ) { result . add ( inliner . getBinding ( key ) . type ) ; } return List . from ( result ) ; }
--------------------------------------------------
protected List < Type > expectedTypes ( Inliner inliner ) throws CouldNotResolveImportException { ArrayList < Type > result = new ArrayList < > ( ) ; ImmutableList < UType > types = expressionArgumentTypes ( ) . values ( ) . asList ( ) ; ImmutableList < String > argNames = expressionArgumentTypes ( ) . keySet ( ) . asList ( ) ; for ( int i = 0 ; i < argNames . size ( ) ; i ++ ) { String argName = argNames . get ( i ) ; Optional < JCExpression > singleBinding = inliner . getOptionalBinding ( new UFreeIdent . Key ( argName ) ) ; if ( ! singleBinding . isPresent ( ) ) { Optional < java . util . List < JCExpression >> exprs = inliner . getOptionalBinding ( new URepeated . Key ( argName ) ) ; if ( ! exprs . isPresent ( ) || exprs . get ( ) . isEmpty ( ) ) { continue ; } } result . add ( types . get ( i ) . inline ( inliner ) ) ; } for ( PlaceholderExpressionKey key : Ordering . natural ( ) . immutableSortedCopy ( Iterables . filter ( inliner . bindings . keySet ( ) , PlaceholderExpressionKey . class ) ) ) { result . add ( key . method . returnType ( ) . inline ( inliner ) ) ; } return List . from ( result ) ; }
--------------------------------------------------
public static Properties loadProperties ( String fileName , boolean allowMultiFile , boolean optional ) { Properties properties = new Properties ( ) ; if ( checkFileNameExist ( fileName ) ) { try { FileInputStream input = new FileInputStream ( fileName ) ; try { properties . load ( input ) ; } finally { input . close ( ) ; } } catch ( Throwable e ) { logger . warn ( 'failed to load ' + fileName + ' file from ' + fileName + '(ignore this file): ' + e . getMessage ( ) , e ) ; } return properties ; } List < java . net . URL > list = new ArrayList < java . net . URL > ( ) ; try { Enumeration < java . net . URL > urls = ClassHelper . getClassLoader ( ) . getResources ( fileName ) ; list = new ArrayList < java . net . URL > ( ) ; while ( urls . hasMoreElements ( ) ) { list . add ( urls . nextElement ( ) ) ; } } catch ( Throwable t ) { logger . warn ( 'fail to load ' + fileName + ' file: ' + t . getMessage ( ) , t ) ; } if ( list . isEmpty ( ) ) { if ( ! optional ) { logger . warn ( 'no ' + fileName + ' found on the class path.' ) ; } return properties ; } if ( ! allowMultiFile ) { if ( list . size ( ) > 1 ) { String errMsg = String . format ( 'only 1 %s file is expected, but %d dubbo.properties files found on class path: %s' , fileName , list . size ( ) , list . toString ( ) ) ; logger . warn ( errMsg ) ; } try { properties . load ( ClassHelper . getClassLoader ( ) . getResourceAsStream ( fileName ) ) ; } catch ( Throwable e ) { logger . warn ( 'failed to load ' + fileName + ' file from ' + fileName + '(ignore this file): ' + e . getMessage ( ) , e ) ; } return properties ; } logger . info ( 'load ' + fileName + ' properties file from ' + list ) ; for ( java . net . URL url : list ) { try { Properties p = new Properties ( ) ; InputStream input = url . openStream ( ) ; if ( input != null ) { try { p . load ( input ) ; properties . putAll ( p ) ; } finally { try { input . close ( ) ; } catch ( Throwable t ) { } } } } catch ( Throwable e ) { logger . warn ( 'fail to load ' + fileName + ' file from ' + url + '(ignore this file): ' + e . getMessage ( ) , e ) ; } } return properties ; }
--------------------------------------------------
