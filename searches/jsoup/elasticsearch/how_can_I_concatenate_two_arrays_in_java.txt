public static boolean isJavaIdentifier ( String s ) { if ( isEmpty ( s ) || ! Character . isJavaIdentifierStart ( s . charAt ( 0 ) ) ) { return false ; } for ( int i = 1 ; i < s . length ( ) ; i ++ ) { if ( ! Character . isJavaIdentifierPart ( s . charAt ( i ) ) ) { return false ; } } return true ; }
--------------------------------------------------
private String generateUrlAssignmentIndirectly ( Method method ) { Class < ? > [ ] pts = method . getParameterTypes ( ) ; for ( int i = 0 ; i < pts . length ; ++ i ) { for ( Method m : pts [ i ] . getMethods ( ) ) { String name = m . getName ( ) ; if ( ( name . startsWith ( 'get' ) || name . length ( ) > 3 ) && Modifier . isPublic ( m . getModifiers ( ) ) && ! Modifier . isStatic ( m . getModifiers ( ) ) && m . getParameterTypes ( ) . length == 0 && m . getReturnType ( ) == URL . class ) { return generateGetUrlNullCheck ( i , pts [ i ] , name ) ; } } } throw new IllegalStateException ( 'failed to create adaptive class for interface ' + type . getName ( ) + ': not found url parameter or url attribute in parameters of method ' + method . getName ( ) ) ; }
--------------------------------------------------
public static Method findMethodByMethodSignature ( Class < ? > clazz , String methodName , String [ ] parameterTypes ) throws NoSuchMethodException , ClassNotFoundException { String signature = clazz . getName ( ) + '.' + methodName ; if ( parameterTypes != null && parameterTypes . length > 0 ) { signature += StringUtils . join ( parameterTypes ) ; } Method method = Signature_METHODS_CACHE . get ( signature ) ; if ( method != null ) { return method ; } if ( parameterTypes == null ) { List < Method > finded = new ArrayList < Method > ( ) ; for ( Method m : clazz . getMethods ( ) ) { if ( m . getName ( ) . equals ( methodName ) ) { finded . add ( m ) ; } } if ( finded . isEmpty ( ) ) { throw new NoSuchMethodException ( 'no such method ' + methodName + ' in class ' + clazz ) ; } if ( finded . size ( ) > 1 ) { String msg = String . format ( 'not unique method for method name(%s) in class(%s), find %d methods.' , methodName , clazz . getName ( ) , finded . size ( ) ) ; throw new IllegalStateException ( msg ) ; } method = finded . get ( 0 ) ; } else { Class < ? > [ ] types = new Class < ? > [ parameterTypes . length ] ; for ( int i = 0 ; i < parameterTypes . length ; i ++ ) { types [ i ] = ReflectUtils . name2class ( parameterTypes [ i ] ) ; } method = clazz . getMethod ( methodName , types ) ; } Signature_METHODS_CACHE . put ( signature , method ) ; return method ; }
--------------------------------------------------
protected List < Type > expectedTypes ( Inliner inliner ) throws CouldNotResolveImportException { ArrayList < Type > result = new ArrayList < > ( ) ; ImmutableList < UType > types = expressionArgumentTypes ( ) . values ( ) . asList ( ) ; ImmutableList < String > argNames = expressionArgumentTypes ( ) . keySet ( ) . asList ( ) ; for ( int i = 0 ; i < argNames . size ( ) ; i ++ ) { String argName = argNames . get ( i ) ; Optional < JCExpression > singleBinding = inliner . getOptionalBinding ( new UFreeIdent . Key ( argName ) ) ; if ( ! singleBinding . isPresent ( ) ) { Optional < java . util . List < JCExpression >> exprs = inliner . getOptionalBinding ( new URepeated . Key ( argName ) ) ; if ( ! exprs . isPresent ( ) || exprs . get ( ) . isEmpty ( ) ) { continue ; } } result . add ( types . get ( i ) . inline ( inliner ) ) ; } for ( PlaceholderExpressionKey key : Ordering . natural ( ) . immutableSortedCopy ( Iterables . filter ( inliner . bindings . keySet ( ) , PlaceholderExpressionKey . class ) ) ) { result . add ( key . method . returnType ( ) . inline ( inliner ) ) ; } return List . from ( result ) ; }
--------------------------------------------------
public static Object compatibleTypeConvert ( Object value , Class < ? > type ) { if ( value == null || type == null || type . isAssignableFrom ( value . getClass ( ) ) ) { return value ; } if ( value instanceof String ) { String string = ( String ) value ; if ( char . class . equals ( type ) || Character . class . equals ( type ) ) { if ( string . length ( ) != 1 ) { throw new IllegalArgumentException ( String . format ( 'can not convert string(%s) to char!' '+' ' when convert string to char, the string must only 1 char.' , string ) ) ; } return string . charAt ( 0 ) ; } else if ( type . isEnum ( ) ) { return Enum . valueOf ( ( Class < Enum > ) type , string ) ; } else if ( type == BigInteger . class ) { return new BigInteger ( string ) ; } else if ( type == BigDecimal . class ) { return new BigDecimal ( string ) ; } else if ( type == Short . class || type == short . class ) { return new Short ( string ) ; } else if ( type == Integer . class || type == int . class ) { return new Integer ( string ) ; } else if ( type == Long . class || type == long . class ) { return new Long ( string ) ; } else if ( type == Double . class || type == double . class ) { return new Double ( string ) ; } else if ( type == Float . class || type == float . class ) { return new Float ( string ) ; } else if ( type == Byte . class || type == byte . class ) { return new Byte ( string ) ; } else if ( type == Boolean . class || type == boolean . class ) { return new Boolean ( string ) ; } else if ( type == Date . class || type == java . sql . Date . class || type == java . sql . Timestamp . class || type == java . sql . Time . class ) { try { Date date = new SimpleDateFormat ( DATE_FORMAT ) . parse ( ( String ) value ) ; if ( type == java . sql . Date . class ) { return new java . sql . Date ( date . getTime ( ) ) ; } else if ( type == java . sql . Timestamp . class ) { return new java . sql . Timestamp ( date . getTime ( ) ) ; } else if ( type == java . sql . Time . class ) { return new java . sql . Time ( date . getTime ( ) ) ; } else { return date ; } } catch ( ParseException e ) { throw new IllegalStateException ( 'failed to parse date ' + value + ' by format ' + DATE_FORMAT + ', cause: ' + e . getMessage ( ) , e ) ; } } else if ( type == Class . class ) { try { return ReflectUtils . name2class ( ( String ) value ) ; } catch ( ClassNotFoundException e ) { throw new RuntimeException ( e . getMessage ( ) , e ) ; } } else if ( char [ ] . class . equals ( type ) ) { int len = string . length ( ) ; char [ ] chars = new char [ len ] ; string . getChars ( 0 , len , chars , 0 ) ; return chars ; } } else if ( value instanceof Number ) { Number number = ( Number ) value ; if ( type == byte . class || type == Byte . class ) { return number . byteValue ( ) ; } else if ( type == short . class || type == Short . class ) { return number . shortValue ( ) ; } else if ( type == int . class || type == Integer . class ) { return number . intValue ( ) ; } else if ( type == long . class || type == Long . class ) { return number . longValue ( ) ; } else if ( type == float . class || type == Float . class ) { return number . floatValue ( ) ; } else if ( type == double . class || type == Double . class ) { return number . doubleValue ( ) ; } else if ( type == BigInteger . class ) { return BigInteger . valueOf ( number . longValue ( ) ) ; } else if ( type == BigDecimal . class ) { return BigDecimal . valueOf ( number . doubleValue ( ) ) ; } else if ( type == Date . class ) { return new Date ( number . longValue ( ) ) ; } } else if ( value instanceof Collection ) { Collection collection = ( Collection ) value ; if ( type . isArray ( ) ) { int length = collection . size ( ) ; Object array = Array . newInstance ( type . getComponentType ( ) , length ) ; int i = 0 ; for ( Object item : collection ) { Array . set ( array , i ++ , item ) ; } return array ; } else if ( ! type . isInterface ( ) ) { try { Collection result = ( Collection ) type . newInstance ( ) ; result . addAll ( collection ) ; return result ; } catch ( Throwable e ) { } } else if ( type == List . class ) { return new ArrayList < Object > ( collection ) ; } else if ( type == Set . class ) { return new HashSet < Object > ( collection ) ; } } else if ( value . getClass ( ) . isArray ( ) && Collection . class . isAssignableFrom ( type ) ) { Collection collection ; if ( ! type . isInterface ( ) ) { try { collection = ( Collection ) type . newInstance ( ) ; } catch ( Throwable e ) { collection = new ArrayList < Object > ( ) ; } } else if ( type == Set . class ) { collection = new HashSet < Object > ( ) ; } else { collection = new ArrayList < Object > ( ) ; } int length = Array . getLength ( value ) ; for ( int i = 0 ; i < length ; i ++ ) { collection . add ( Array . get ( value , i ) ) ; } return collection ; } return value ; }
--------------------------------------------------
protected List < Type > actualTypes ( Inliner inliner ) { ArrayList < Type > result = new ArrayList < > ( ) ; ImmutableList < String > argNames = expressionArgumentTypes ( ) . keySet ( ) . asList ( ) ; for ( int i = 0 ; i < expressionArgumentTypes ( ) . size ( ) ; i ++ ) { String argName = argNames . get ( i ) ; Optional < JCExpression > singleBinding = inliner . getOptionalBinding ( new UFreeIdent . Key ( argName ) ) ; if ( singleBinding . isPresent ( ) ) { result . add ( singleBinding . get ( ) . type ) ; } else { Optional < java . util . List < JCExpression >> exprs = inliner . getOptionalBinding ( new URepeated . Key ( argName ) ) ; if ( exprs . isPresent ( ) && ! exprs . get ( ) . isEmpty ( ) ) { Type [ ] exprTys = new Type [ exprs . get ( ) . size ( ) ] ; for ( int j = 0 ; j < exprs . get ( ) . size ( ) ; j ++ ) { exprTys [ j ] = exprs . get ( ) . get ( j ) . type ; } result . add ( inliner . types ( ) . lub ( List . from ( exprTys ) ) ) ; } } } for ( PlaceholderExpressionKey key : Ordering . natural ( ) . immutableSortedCopy ( Iterables . filter ( inliner . bindings . keySet ( ) , PlaceholderExpressionKey . class ) ) ) { result . add ( inliner . getBinding ( key ) . type ) ; } return List . from ( result ) ; }
--------------------------------------------------
public static boolean compilesWithFix ( Fix fix , VisitorState state ) { if ( fix . isEmpty ( ) ) { return true ; } JCCompilationUnit compilationUnit = ( JCCompilationUnit ) state . getPath ( ) . getCompilationUnit ( ) ; JavaFileObject modifiedFile = compilationUnit . getSourceFile ( ) ; BasicJavacTask javacTask = ( BasicJavacTask ) state . context . get ( JavacTask . class ) ; if ( javacTask == null ) { throw new IllegalArgumentException ( 'no javactask in context.' ) ; } Arguments arguments = Arguments . instance ( javacTask . getContext ( ) ) ; List < JavaFileObject > fileObjects = new ArrayList < > ( arguments . getFileObjects ( ) ) ; for ( int i = 0 ; i < fileObjects . size ( ) ; i ++ ) { final JavaFileObject oldFile = fileObjects . get ( i ) ; if ( modifiedFile . toUri ( ) . equals ( oldFile . toUri ( ) ) ) { DescriptionBasedDiff diff = DescriptionBasedDiff . create ( compilationUnit , ImportOrganizer . STATIC_FIRST_ORGANIZER ) ; diff . handleFix ( fix ) ; SourceFile fixSource ; try { fixSource = new SourceFile ( modifiedFile . getName ( ) , modifiedFile . getCharContent ( false ) ) ; } catch ( IOException e ) { return false ; } diff . applyDifferences ( fixSource ) ; fileObjects . set ( i , new SimpleJavaFileObject ( sourceURI ( modifiedFile . toUri ( ) ) , Kind . SOURCE ) { @ Override public CharSequence getCharContent ( boolean ignoreEncodingErrors ) throws IOException { return fixSource . getAsSequence ( ) ; } } ) ; break ; } } DiagnosticCollector < JavaFileObject > diagnosticListener = new DiagnosticCollector < > ( ) ; Context context = new Context ( ) ; Options options = Options . instance ( context ) ; Options originalOptions = Options . instance ( javacTask . getContext ( ) ) ; for ( String key : originalOptions . keySet ( ) ) { String value = originalOptions . get ( key ) ; if ( key . equals ( '-xplugin:' ) && value . startsWith ( 'errorprone' ) ) { continue ; } options . put ( key , value ) ; } JavacTask newTask = JavacTool . create ( ) . getTask ( CharStreams . nullWriter ( ) , state . context . get ( JavaFileManager . class ) , diagnosticListener , ImmutableList . of ( ) , arguments . getClassNames ( ) , fileObjects , context ) ; try { newTask . analyze ( ) ; } catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } return countErrors ( diagnosticListener ) == 0 ; }
--------------------------------------------------
public List < T > getActivateExtension ( URL url , String [ ] values , String group ) { List < T > exts = new ArrayList < > ( ) ; List < String > names = values == null ? new ArrayList < > ( 0 ) : Arrays . asList ( values ) ; if ( ! names . contains ( Constants . REMOVE_VALUE_PREFIX + Constants . DEFAULT_KEY ) ) { getExtensionClasses ( ) ; for ( Map . Entry < String , Object > entry : cachedActivates . entrySet ( ) ) { String name = entry . getKey ( ) ; Object activate = entry . getValue ( ) ; String [ ] activateGroup , activateValue ; if ( activate instanceof Activate ) { activateGroup = ( ( Activate ) activate ) . group ( ) ; activateValue = ( ( Activate ) activate ) . value ( ) ; } else if ( activate instanceof com . alibaba . dubbo . common . extension . Activate ) { activateGroup = ( ( com . alibaba . dubbo . common . extension . Activate ) activate ) . group ( ) ; activateValue = ( ( com . alibaba . dubbo . common . extension . Activate ) activate ) . value ( ) ; } else { continue ; } if ( isMatchGroup ( group , activateGroup ) ) { T ext = getExtension ( name ) ; if ( ! names . contains ( name ) && ! names . contains ( Constants . REMOVE_VALUE_PREFIX + name ) && isActive ( activateValue , url ) ) { exts . add ( ext ) ; } } } exts . sort ( ActivateComparator . COMPARATOR ) ; } List < T > usrs = new ArrayList < > ( ) ; for ( int i = 0 ; i < names . size ( ) ; i ++ ) { String name = names . get ( i ) ; if ( ! name . startsWith ( Constants . REMOVE_VALUE_PREFIX ) && ! names . contains ( Constants . REMOVE_VALUE_PREFIX + name ) ) { if ( Constants . DEFAULT_KEY . equals ( name ) ) { if ( ! usrs . isEmpty ( ) ) { exts . addAll ( 0 , usrs ) ; usrs . clear ( ) ; } } else { T ext = getExtension ( name ) ; usrs . add ( ext ) ; } } } if ( ! usrs . isEmpty ( ) ) { exts . addAll ( usrs ) ; } return exts ; }
--------------------------------------------------
