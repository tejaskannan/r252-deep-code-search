private static String exportOrUnexportCallbackService ( Channel channel , URL url , Class clazz , Object inst , Boolean export ) throws IOException { int instid = System . identityHashCode ( inst ) ; Map < String , String > params = new HashMap < > ( 3 ) ; params . put ( Constants . IS_SERVER_KEY , Boolean . FALSE . toString ( ) ) ; params . put ( Constants . IS_CALLBACK_SERVICE , Boolean . TRUE . toString ( ) ) ; String group = ( url == null ? null : url . getParameter ( Constants . GROUP_KEY ) ) ; if ( group != null && group . length ( ) > 0 ) { params . put ( Constants . GROUP_KEY , group ) ; } params . put ( Constants . METHODS_KEY , StringUtils . join ( Wrapper . getWrapper ( clazz ) . getDeclaredMethodNames ( ) , ',' ) ) ; Map < String , String > tmpMap = new HashMap < > ( url . getParameters ( ) ) ; tmpMap . putAll ( params ) ; tmpMap . remove ( Constants . VERSION_KEY ) ; tmpMap . put ( Constants . INTERFACE_KEY , clazz . getName ( ) ) ; URL exportUrl = new URL ( DubboProtocol . NAME , channel . getLocalAddress ( ) . getAddress ( ) . getHostAddress ( ) , channel . getLocalAddress ( ) . getPort ( ) , clazz . getName ( ) + '.' + instid , tmpMap ) ; String cacheKey = getClientSideCallbackServiceCacheKey ( instid ) ; String countKey = getClientSideCountKey ( clazz . getName ( ) ) ; if ( export ) { if ( ! channel . hasAttribute ( cacheKey ) ) { if ( ! isInstancesOverLimit ( channel , url , clazz . getName ( ) , instid , false ) ) { Invoker < ? > invoker = proxyFactory . getInvoker ( inst , clazz , exportUrl ) ; Exporter < ? > exporter = protocol . export ( invoker ) ; channel . setAttribute ( cacheKey , exporter ) ; logger . info ( 'export a callback service :' + exportUrl + ', on ' + channel + ', url is: ' + url ) ; increaseInstanceCount ( channel , countKey ) ; } } } else { if ( channel . hasAttribute ( cacheKey ) ) { Exporter < ? > exporter = ( Exporter < ? > ) channel . getAttribute ( cacheKey ) ; exporter . unexport ( ) ; channel . removeAttribute ( cacheKey ) ; decreaseInstanceCount ( channel , countKey ) ; } } return String . valueOf ( instid ) ; }
--------------------------------------------------
public ScannerSupplier applyOverrides ( ErrorProneOptions errorProneOptions ) { Map < String , Severity > severityOverrides = errorProneOptions . getSeverityMap ( ) ; if ( severityOverrides . isEmpty ( ) && errorProneOptions . getFlags ( ) . isEmpty ( ) && ! errorProneOptions . isEnableAllChecksAsWarnings ( ) && ! errorProneOptions . isDropErrorsToWarnings ( ) && ! errorProneOptions . isDisableAllChecks ( ) ) { return this ; } ImmutableBiMap < String , BugCheckerInfo > checks = getAllChecks ( ) ; Map < String , SeverityLevel > severities = new LinkedHashMap < > ( severities ( ) ) ; Set < String > disabled = new HashSet < > ( disabled ( ) ) ; Map < String , String > flagsMap = new HashMap < > ( getFlags ( ) . getFlagsMap ( ) ) ; if ( errorProneOptions . isEnableAllChecksAsWarnings ( ) ) { disabled . forEach ( c -> severities . put ( c , SeverityLevel . WARNING ) ) ; disabled . clear ( ) ; } if ( errorProneOptions . isDropErrorsToWarnings ( ) ) { getAllChecks ( ) . values ( ) . stream ( ) . filter ( c -> c . defaultSeverity ( ) == SeverityLevel . ERROR && c . disableable ( ) ) . forEach ( c -> severities . put ( c . canonicalName ( ) , SeverityLevel . WARNING ) ) ; } if ( errorProneOptions . isDisableAllChecks ( ) ) { getAllChecks ( ) . values ( ) . stream ( ) . filter ( c -> c . disableable ( ) ) . forEach ( c -> disabled . add ( c . canonicalName ( ) ) ) ; } severityOverrides . forEach ( ( checkName , newSeverity ) -> { BugCheckerInfo check = getAllChecks ( ) . get ( checkName ) ; if ( check == null ) { if ( errorProneOptions . ignoreUnknownChecks ( ) ) { return ; } throw new InvalidCommandLineOptionException ( checkName + ' is not a valid checker name' ) ; } switch ( newSeverity ) { case OFF : if ( ! check . disableable ( ) ) { throw new InvalidCommandLineOptionException ( check . canonicalName ( ) + ' may not be disabled' ) ; } severities . remove ( check . canonicalName ( ) ) ; disabled . add ( check . canonicalName ( ) ) ; break ; case DEFAULT : severities . put ( check . canonicalName ( ) , check . defaultSeverity ( ) ) ; disabled . remove ( check . canonicalName ( ) ) ; break ; case WARN : if ( ! disabled ( ) . contains ( check . canonicalName ( ) ) && ! check . disableable ( ) && check . defaultSeverity ( ) == SeverityLevel . ERROR ) { throw new InvalidCommandLineOptionException ( check . canonicalName ( ) + ' is not disableable and may not be demoted to a warning' ) ; } severities . put ( check . canonicalName ( ) , SeverityLevel . WARNING ) ; disabled . remove ( check . canonicalName ( ) ) ; break ; case ERROR : severities . put ( check . canonicalName ( ) , SeverityLevel . ERROR ) ; disabled . remove ( check . canonicalName ( ) ) ; break ; default : throw new IllegalStateException ( 'unexpected severity level: ' + newSeverity ) ; } } ) ; flagsMap . putAll ( errorProneOptions . getFlags ( ) . getFlagsMap ( ) ) ; return new ScannerSupplierImpl ( checks , ImmutableMap . copyOf ( severities ) , ImmutableSet . copyOf ( disabled ) , ErrorProneFlags . fromMap ( flagsMap ) ) ; }
--------------------------------------------------
public static Proxy getProxy ( ClassLoader cl , Class < ? > ... ics ) { if ( ics . length > Constants . MAX_PROXY_COUNT ) { throw new IllegalArgumentException ( 'interface limit exceeded' ) ; } StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < ics . length ; i ++ ) { String itf = ics [ i ] . getName ( ) ; if ( ! ics [ i ] . isInterface ( ) ) { throw new RuntimeException ( itf + ' is not a interface.' ) ; } Class < ? > tmp = null ; try { tmp = Class . forName ( itf , false , cl ) ; } catch ( ClassNotFoundException e ) { } if ( tmp != ics [ i ] ) { throw new IllegalArgumentException ( ics [ i ] + ' is not visible from class loader' ) ; } sb . append ( itf ) . append ( ';' ) ; } String key = sb . toString ( ) ; Map < String , Object > cache ; synchronized ( ProxyCacheMap ) { cache = ProxyCacheMap . computeIfAbsent ( cl , k -> new HashMap < > ( ) ) ; } Proxy proxy = null ; synchronized ( cache ) { do { Object value = cache . get ( key ) ; if ( value instanceof Reference < ? > ) { proxy = ( Proxy ) ( ( Reference < ? > ) value ) . get ( ) ; if ( proxy != null ) { return proxy ; } } if ( value == PendingGenerationMarker ) { try { cache . wait ( ) ; } catch ( InterruptedException e ) { } } else { cache . put ( key , PendingGenerationMarker ) ; break ; } } while ( true ) ; } long id = PROXY_CLASS_COUNTER . getAndIncrement ( ) ; String pkg = null ; ClassGenerator ccp = null , ccm = null ; try { ccp = ClassGenerator . newInstance ( cl ) ; Set < String > worked = new HashSet < > ( ) ; List < Method > methods = new ArrayList < > ( ) ; for ( int i = 0 ; i < ics . length ; i ++ ) { if ( ! Modifier . isPublic ( ics [ i ] . getModifiers ( ) ) ) { String npkg = ics [ i ] . getPackage ( ) . getName ( ) ; if ( pkg == null ) { pkg = npkg ; } else { if ( ! pkg . equals ( npkg ) ) { throw new IllegalArgumentException ( 'non-public interfaces from different packages' ) ; } } } ccp . addInterface ( ics [ i ] ) ; for ( Method method : ics [ i ] . getMethods ( ) ) { String desc = ReflectUtils . getDesc ( method ) ; if ( worked . contains ( desc ) ) { continue ; } worked . add ( desc ) ; int ix = methods . size ( ) ; Class < ? > rt = method . getReturnType ( ) ; Class < ? > [ ] pts = method . getParameterTypes ( ) ; StringBuilder code = new StringBuilder ( 'object[] args = new object[' ) . append ( pts . length ) . append ( '];' ) ; for ( int j = 0 ; j < pts . length ; j ++ ) { code . append ( ' args[' ) . append ( j ) . append ( '] = ($w)$' ) . append ( j + 1 ) . append ( ';' ) ; } code . append ( ' object ret = handler.invoke(this, methods[' ) . append ( ix ) . append ( '], args);' ) ; if ( ! Void . TYPE . equals ( rt ) ) { code . append ( ' return ' ) . append ( asArgument ( rt , 'ret' ) ) . append ( ';' ) ; } methods . add ( method ) ; ccp . addMethod ( method . getName ( ) , method . getModifiers ( ) , rt , pts , method . getExceptionTypes ( ) , code . toString ( ) ) ; } } if ( pkg == null ) { pkg = PACKAGE_NAME ; } String pcn = pkg + '.proxy' + id ; ccp . setClassName ( pcn ) ; ccp . addField ( 'public static java.lang.reflect.method[] methods;' ) ; ccp . addField ( 'private ' + InvocationHandler . class . getName ( ) + ' handler;' ) ; ccp . addConstructor ( Modifier . PUBLIC , new Class < ? > [ ] { InvocationHandler . class } , new Class < ? > [ 0 ] , 'handler=$1;' ) ; ccp . addDefaultConstructor ( ) ; Class < ? > clazz = ccp . toClass ( ) ; clazz . getField ( 'methods' ) . set ( null , methods . toArray ( new Method [ 0 ] ) ) ; String fcn = Proxy . class . getName ( ) + id ; ccm = ClassGenerator . newInstance ( cl ) ; ccm . setClassName ( fcn ) ; ccm . addDefaultConstructor ( ) ; ccm . setSuperClass ( Proxy . class ) ; ccm . addMethod ( 'public object newinstance(' + InvocationHandler . class . getName ( ) + ' h){ return new ' + pcn + '($1); }' ) ; Class < ? > pc = ccm . toClass ( ) ; proxy = ( Proxy ) pc . newInstance ( ) ; } catch ( RuntimeException e ) { throw e ; } catch ( Exception e ) { throw new RuntimeException ( e . getMessage ( ) , e ) ; } finally { if ( ccp != null ) { ccp . release ( ) ; } if ( ccm != null ) { ccm . release ( ) ; } synchronized ( cache ) { if ( proxy == null ) { cache . remove ( key ) ; } else { cache . put ( key , new WeakReference < Proxy > ( proxy ) ) ; } cache . notifyAll ( ) ; } } return proxy ; }
--------------------------------------------------
