default int compareTo ( Configurator o ) { if ( o == null ) { return - 1 ; } int ipCompare = getUrl ( ) . getHost ( ) . compareTo ( o . getUrl ( ) . getHost ( ) ) ; if ( ipCompare == 0 ) { int i = getUrl ( ) . getParameter ( Constants . PRIORITY_KEY , 0 ) ; int j = o . getUrl ( ) . getParameter ( Constants . PRIORITY_KEY , 0 ) ; return Integer . compare ( i , j ) ; } else { return ipCompare ; } }
--------------------------------------------------
public static boolean isJavaIdentifier ( String s ) { if ( isEmpty ( s ) || ! Character . isJavaIdentifierStart ( s . charAt ( 0 ) ) ) { return false ; } for ( int i = 1 ; i < s . length ( ) ; i ++ ) { if ( ! Character . isJavaIdentifierPart ( s . charAt ( i ) ) ) { return false ; } } return true ; }
--------------------------------------------------
private static char [ ] zzUnpackCMap ( String packed ) { char [ ] map = new char [ 10000 ] ; int i = 0 ; int j = 0 ; while ( i < 122 ) { int count = packed . charAt ( i ++ ) ; char value = packed . charAt ( i ++ ) ; do { map [ j ++ ] = value ; } while ( -- count > 0 ) ; } return map ; }
--------------------------------------------------
private String generateUrlAssignmentIndirectly ( Method method ) { Class < ? > [ ] pts = method . getParameterTypes ( ) ; for ( int i = 0 ; i < pts . length ; ++ i ) { for ( Method m : pts [ i ] . getMethods ( ) ) { String name = m . getName ( ) ; if ( ( name . startsWith ( 'get' ) || name . length ( ) > 3 ) && Modifier . isPublic ( m . getModifiers ( ) ) && ! Modifier . isStatic ( m . getModifiers ( ) ) && m . getParameterTypes ( ) . length == 0 && m . getReturnType ( ) == URL . class ) { return generateGetUrlNullCheck ( i , pts [ i ] , name ) ; } } } throw new IllegalStateException ( 'failed to create adaptive class for interface ' + type . getName ( ) + ': not found url parameter or url attribute in parameters of method ' + method . getName ( ) ) ; }
--------------------------------------------------
public static Method findMethodByMethodSignature ( Class < ? > clazz , String methodName , String [ ] parameterTypes ) throws NoSuchMethodException , ClassNotFoundException { String signature = clazz . getName ( ) + '.' + methodName ; if ( parameterTypes != null && parameterTypes . length > 0 ) { signature += StringUtils . join ( parameterTypes ) ; } Method method = Signature_METHODS_CACHE . get ( signature ) ; if ( method != null ) { return method ; } if ( parameterTypes == null ) { List < Method > finded = new ArrayList < Method > ( ) ; for ( Method m : clazz . getMethods ( ) ) { if ( m . getName ( ) . equals ( methodName ) ) { finded . add ( m ) ; } } if ( finded . isEmpty ( ) ) { throw new NoSuchMethodException ( 'no such method ' + methodName + ' in class ' + clazz ) ; } if ( finded . size ( ) > 1 ) { String msg = String . format ( 'not unique method for method name(%s) in class(%s), find %d methods.' , methodName , clazz . getName ( ) , finded . size ( ) ) ; throw new IllegalStateException ( msg ) ; } method = finded . get ( 0 ) ; } else { Class < ? > [ ] types = new Class < ? > [ parameterTypes . length ] ; for ( int i = 0 ; i < parameterTypes . length ; i ++ ) { types [ i ] = ReflectUtils . name2class ( parameterTypes [ i ] ) ; } method = clazz . getMethod ( methodName , types ) ; } Signature_METHODS_CACHE . put ( signature , method ) ; return method ; }
--------------------------------------------------
protected List < Type > expectedTypes ( Inliner inliner ) throws CouldNotResolveImportException { ArrayList < Type > result = new ArrayList < > ( ) ; ImmutableList < UType > types = expressionArgumentTypes ( ) . values ( ) . asList ( ) ; ImmutableList < String > argNames = expressionArgumentTypes ( ) . keySet ( ) . asList ( ) ; for ( int i = 0 ; i < argNames . size ( ) ; i ++ ) { String argName = argNames . get ( i ) ; Optional < JCExpression > singleBinding = inliner . getOptionalBinding ( new UFreeIdent . Key ( argName ) ) ; if ( ! singleBinding . isPresent ( ) ) { Optional < java . util . List < JCExpression >> exprs = inliner . getOptionalBinding ( new URepeated . Key ( argName ) ) ; if ( ! exprs . isPresent ( ) || exprs . get ( ) . isEmpty ( ) ) { continue ; } } result . add ( types . get ( i ) . inline ( inliner ) ) ; } for ( PlaceholderExpressionKey key : Ordering . natural ( ) . immutableSortedCopy ( Iterables . filter ( inliner . bindings . keySet ( ) , PlaceholderExpressionKey . class ) ) ) { result . add ( key . method . returnType ( ) . inline ( inliner ) ) ; } return List . from ( result ) ; }
--------------------------------------------------
protected List < Type > actualTypes ( Inliner inliner ) { ArrayList < Type > result = new ArrayList < > ( ) ; ImmutableList < String > argNames = expressionArgumentTypes ( ) . keySet ( ) . asList ( ) ; for ( int i = 0 ; i < expressionArgumentTypes ( ) . size ( ) ; i ++ ) { String argName = argNames . get ( i ) ; Optional < JCExpression > singleBinding = inliner . getOptionalBinding ( new UFreeIdent . Key ( argName ) ) ; if ( singleBinding . isPresent ( ) ) { result . add ( singleBinding . get ( ) . type ) ; } else { Optional < java . util . List < JCExpression >> exprs = inliner . getOptionalBinding ( new URepeated . Key ( argName ) ) ; if ( exprs . isPresent ( ) && ! exprs . get ( ) . isEmpty ( ) ) { Type [ ] exprTys = new Type [ exprs . get ( ) . size ( ) ] ; for ( int j = 0 ; j < exprs . get ( ) . size ( ) ; j ++ ) { exprTys [ j ] = exprs . get ( ) . get ( j ) . type ; } result . add ( inliner . types ( ) . lub ( List . from ( exprTys ) ) ) ; } } } for ( PlaceholderExpressionKey key : Ordering . natural ( ) . immutableSortedCopy ( Iterables . filter ( inliner . bindings . keySet ( ) , PlaceholderExpressionKey . class ) ) ) { result . add ( inliner . getBinding ( key ) . type ) ; } return List . from ( result ) ; }
--------------------------------------------------
public static Object compatibleTypeConvert ( Object value , Class < ? > type ) { if ( value == null || type == null || type . isAssignableFrom ( value . getClass ( ) ) ) { return value ; } if ( value instanceof String ) { String string = ( String ) value ; if ( char . class . equals ( type ) || Character . class . equals ( type ) ) { if ( string . length ( ) != 1 ) { throw new IllegalArgumentException ( String . format ( 'can not convert string(%s) to char!' '+' ' when convert string to char, the string must only 1 char.' , string ) ) ; } return string . charAt ( 0 ) ; } else if ( type . isEnum ( ) ) { return Enum . valueOf ( ( Class < Enum > ) type , string ) ; } else if ( type == BigInteger . class ) { return new BigInteger ( string ) ; } else if ( type == BigDecimal . class ) { return new BigDecimal ( string ) ; } else if ( type == Short . class || type == short . class ) { return new Short ( string ) ; } else if ( type == Integer . class || type == int . class ) { return new Integer ( string ) ; } else if ( type == Long . class || type == long . class ) { return new Long ( string ) ; } else if ( type == Double . class || type == double . class ) { return new Double ( string ) ; } else if ( type == Float . class || type == float . class ) { return new Float ( string ) ; } else if ( type == Byte . class || type == byte . class ) { return new Byte ( string ) ; } else if ( type == Boolean . class || type == boolean . class ) { return new Boolean ( string ) ; } else if ( type == Date . class || type == java . sql . Date . class || type == java . sql . Timestamp . class || type == java . sql . Time . class ) { try { Date date = new SimpleDateFormat ( DATE_FORMAT ) . parse ( ( String ) value ) ; if ( type == java . sql . Date . class ) { return new java . sql . Date ( date . getTime ( ) ) ; } else if ( type == java . sql . Timestamp . class ) { return new java . sql . Timestamp ( date . getTime ( ) ) ; } else if ( type == java . sql . Time . class ) { return new java . sql . Time ( date . getTime ( ) ) ; } else { return date ; } } catch ( ParseException e ) { throw new IllegalStateException ( 'failed to parse date ' + value + ' by format ' + DATE_FORMAT + ', cause: ' + e . getMessage ( ) , e ) ; } } else if ( type == Class . class ) { try { return ReflectUtils . name2class ( ( String ) value ) ; } catch ( ClassNotFoundException e ) { throw new RuntimeException ( e . getMessage ( ) , e ) ; } } else if ( char [ ] . class . equals ( type ) ) { int len = string . length ( ) ; char [ ] chars = new char [ len ] ; string . getChars ( 0 , len , chars , 0 ) ; return chars ; } } else if ( value instanceof Number ) { Number number = ( Number ) value ; if ( type == byte . class || type == Byte . class ) { return number . byteValue ( ) ; } else if ( type == short . class || type == Short . class ) { return number . shortValue ( ) ; } else if ( type == int . class || type == Integer . class ) { return number . intValue ( ) ; } else if ( type == long . class || type == Long . class ) { return number . longValue ( ) ; } else if ( type == float . class || type == Float . class ) { return number . floatValue ( ) ; } else if ( type == double . class || type == Double . class ) { return number . doubleValue ( ) ; } else if ( type == BigInteger . class ) { return BigInteger . valueOf ( number . longValue ( ) ) ; } else if ( type == BigDecimal . class ) { return BigDecimal . valueOf ( number . doubleValue ( ) ) ; } else if ( type == Date . class ) { return new Date ( number . longValue ( ) ) ; } } else if ( value instanceof Collection ) { Collection collection = ( Collection ) value ; if ( type . isArray ( ) ) { int length = collection . size ( ) ; Object array = Array . newInstance ( type . getComponentType ( ) , length ) ; int i = 0 ; for ( Object item : collection ) { Array . set ( array , i ++ , item ) ; } return array ; } else if ( ! type . isInterface ( ) ) { try { Collection result = ( Collection ) type . newInstance ( ) ; result . addAll ( collection ) ; return result ; } catch ( Throwable e ) { } } else if ( type == List . class ) { return new ArrayList < Object > ( collection ) ; } else if ( type == Set . class ) { return new HashSet < Object > ( collection ) ; } } else if ( value . getClass ( ) . isArray ( ) && Collection . class . isAssignableFrom ( type ) ) { Collection collection ; if ( ! type . isInterface ( ) ) { try { collection = ( Collection ) type . newInstance ( ) ; } catch ( Throwable e ) { collection = new ArrayList < Object > ( ) ; } } else if ( type == Set . class ) { collection = new HashSet < Object > ( ) ; } else { collection = new ArrayList < Object > ( ) ; } int length = Array . getLength ( value ) ; for ( int i = 0 ; i < length ; i ++ ) { collection . add ( Array . get ( value , i ) ) ; } return collection ; } return value ; }
--------------------------------------------------
public static boolean compilesWithFix ( Fix fix , VisitorState state ) { if ( fix . isEmpty ( ) ) { return true ; } JCCompilationUnit compilationUnit = ( JCCompilationUnit ) state . getPath ( ) . getCompilationUnit ( ) ; JavaFileObject modifiedFile = compilationUnit . getSourceFile ( ) ; BasicJavacTask javacTask = ( BasicJavacTask ) state . context . get ( JavacTask . class ) ; if ( javacTask == null ) { throw new IllegalArgumentException ( 'no javactask in context.' ) ; } Arguments arguments = Arguments . instance ( javacTask . getContext ( ) ) ; List < JavaFileObject > fileObjects = new ArrayList < > ( arguments . getFileObjects ( ) ) ; for ( int i = 0 ; i < fileObjects . size ( ) ; i ++ ) { final JavaFileObject oldFile = fileObjects . get ( i ) ; if ( modifiedFile . toUri ( ) . equals ( oldFile . toUri ( ) ) ) { DescriptionBasedDiff diff = DescriptionBasedDiff . create ( compilationUnit , ImportOrganizer . STATIC_FIRST_ORGANIZER ) ; diff . handleFix ( fix ) ; SourceFile fixSource ; try { fixSource = new SourceFile ( modifiedFile . getName ( ) , modifiedFile . getCharContent ( false ) ) ; } catch ( IOException e ) { return false ; } diff . applyDifferences ( fixSource ) ; fileObjects . set ( i , new SimpleJavaFileObject ( sourceURI ( modifiedFile . toUri ( ) ) , Kind . SOURCE ) { @ Override public CharSequence getCharContent ( boolean ignoreEncodingErrors ) throws IOException { return fixSource . getAsSequence ( ) ; } } ) ; break ; } } DiagnosticCollector < JavaFileObject > diagnosticListener = new DiagnosticCollector < > ( ) ; Context context = new Context ( ) ; Options options = Options . instance ( context ) ; Options originalOptions = Options . instance ( javacTask . getContext ( ) ) ; for ( String key : originalOptions . keySet ( ) ) { String value = originalOptions . get ( key ) ; if ( key . equals ( '-xplugin:' ) && value . startsWith ( 'errorprone' ) ) { continue ; } options . put ( key , value ) ; } JavacTask newTask = JavacTool . create ( ) . getTask ( CharStreams . nullWriter ( ) , state . context . get ( JavaFileManager . class ) , diagnosticListener , ImmutableList . of ( ) , arguments . getClassNames ( ) , fileObjects , context ) ; try { newTask . analyze ( ) ; } catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } return countErrors ( diagnosticListener ) == 0 ; }
--------------------------------------------------
public static Proxy getProxy ( ClassLoader cl , Class < ? > ... ics ) { if ( ics . length > Constants . MAX_PROXY_COUNT ) { throw new IllegalArgumentException ( 'interface limit exceeded' ) ; } StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < ics . length ; i ++ ) { String itf = ics [ i ] . getName ( ) ; if ( ! ics [ i ] . isInterface ( ) ) { throw new RuntimeException ( itf + ' is not a interface.' ) ; } Class < ? > tmp = null ; try { tmp = Class . forName ( itf , false , cl ) ; } catch ( ClassNotFoundException e ) { } if ( tmp != ics [ i ] ) { throw new IllegalArgumentException ( ics [ i ] + ' is not visible from class loader' ) ; } sb . append ( itf ) . append ( ';' ) ; } String key = sb . toString ( ) ; Map < String , Object > cache ; synchronized ( ProxyCacheMap ) { cache = ProxyCacheMap . computeIfAbsent ( cl , k -> new HashMap < > ( ) ) ; } Proxy proxy = null ; synchronized ( cache ) { do { Object value = cache . get ( key ) ; if ( value instanceof Reference < ? > ) { proxy = ( Proxy ) ( ( Reference < ? > ) value ) . get ( ) ; if ( proxy != null ) { return proxy ; } } if ( value == PendingGenerationMarker ) { try { cache . wait ( ) ; } catch ( InterruptedException e ) { } } else { cache . put ( key , PendingGenerationMarker ) ; break ; } } while ( true ) ; } long id = PROXY_CLASS_COUNTER . getAndIncrement ( ) ; String pkg = null ; ClassGenerator ccp = null , ccm = null ; try { ccp = ClassGenerator . newInstance ( cl ) ; Set < String > worked = new HashSet < > ( ) ; List < Method > methods = new ArrayList < > ( ) ; for ( int i = 0 ; i < ics . length ; i ++ ) { if ( ! Modifier . isPublic ( ics [ i ] . getModifiers ( ) ) ) { String npkg = ics [ i ] . getPackage ( ) . getName ( ) ; if ( pkg == null ) { pkg = npkg ; } else { if ( ! pkg . equals ( npkg ) ) { throw new IllegalArgumentException ( 'non-public interfaces from different packages' ) ; } } } ccp . addInterface ( ics [ i ] ) ; for ( Method method : ics [ i ] . getMethods ( ) ) { String desc = ReflectUtils . getDesc ( method ) ; if ( worked . contains ( desc ) ) { continue ; } worked . add ( desc ) ; int ix = methods . size ( ) ; Class < ? > rt = method . getReturnType ( ) ; Class < ? > [ ] pts = method . getParameterTypes ( ) ; StringBuilder code = new StringBuilder ( 'object[] args = new object[' ) . append ( pts . length ) . append ( '];' ) ; for ( int j = 0 ; j < pts . length ; j ++ ) { code . append ( ' args[' ) . append ( j ) . append ( '] = ($w)$' ) . append ( j + 1 ) . append ( ';' ) ; } code . append ( ' object ret = handler.invoke(this, methods[' ) . append ( ix ) . append ( '], args);' ) ; if ( ! Void . TYPE . equals ( rt ) ) { code . append ( ' return ' ) . append ( asArgument ( rt , 'ret' ) ) . append ( ';' ) ; } methods . add ( method ) ; ccp . addMethod ( method . getName ( ) , method . getModifiers ( ) , rt , pts , method . getExceptionTypes ( ) , code . toString ( ) ) ; } } if ( pkg == null ) { pkg = PACKAGE_NAME ; } String pcn = pkg + '.proxy' + id ; ccp . setClassName ( pcn ) ; ccp . addField ( 'public static java.lang.reflect.method[] methods;' ) ; ccp . addField ( 'private ' + InvocationHandler . class . getName ( ) + ' handler;' ) ; ccp . addConstructor ( Modifier . PUBLIC , new Class < ? > [ ] { InvocationHandler . class } , new Class < ? > [ 0 ] , 'handler=$1;' ) ; ccp . addDefaultConstructor ( ) ; Class < ? > clazz = ccp . toClass ( ) ; clazz . getField ( 'methods' ) . set ( null , methods . toArray ( new Method [ 0 ] ) ) ; String fcn = Proxy . class . getName ( ) + id ; ccm = ClassGenerator . newInstance ( cl ) ; ccm . setClassName ( fcn ) ; ccm . addDefaultConstructor ( ) ; ccm . setSuperClass ( Proxy . class ) ; ccm . addMethod ( 'public object newinstance(' + InvocationHandler . class . getName ( ) + ' h){ return new ' + pcn + '($1); }' ) ; Class < ? > pc = ccm . toClass ( ) ; proxy = ( Proxy ) pc . newInstance ( ) ; } catch ( RuntimeException e ) { throw e ; } catch ( Exception e ) { throw new RuntimeException ( e . getMessage ( ) , e ) ; } finally { if ( ccp != null ) { ccp . release ( ) ; } if ( ccm != null ) { ccm . release ( ) ; } synchronized ( cache ) { if ( proxy == null ) { cache . remove ( key ) ; } else { cache . put ( key , new WeakReference < Proxy > ( proxy ) ) ; } cache . notifyAll ( ) ; } } return proxy ; }
--------------------------------------------------
