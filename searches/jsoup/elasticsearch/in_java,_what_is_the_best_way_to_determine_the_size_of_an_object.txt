public String toString ( ) { if ( importStrings . isEmpty ( ) ) { return '' ; } StringBuilder result = new StringBuilder ( ) ; if ( ! hasExistingImports ) { result . append ( '' ) ; } List < ImportOrganizer . Import > imports = importStrings . stream ( ) . map ( ImportOrganizer . Import :: importOf ) . collect ( Collectors . toList ( ) ) ; ImportOrganizer . OrganizedImports organizedImports = importOrganizer . organizeImports ( imports ) ; int expectedImportCount = imports . size ( ) ; int importCount = organizedImports . getImportCount ( ) ; if ( importCount != expectedImportCount ) { throw new IllegalStateException ( String . format ( 'expected %d import(s) in the organized imports but it contained %d' , expectedImportCount , importCount ) ) ; } result . append ( organizedImports . asImportBlock ( ) ) ; String replacementString = result . toString ( ) ; if ( ! hasExistingImports ) { return replacementString ; } else { return CharMatcher . whitespace ( ) . trimTrailingFrom ( replacementString ) ; } }
--------------------------------------------------
private ClassSymbol isEnclosedIn ( ClassSymbol startingClass , Symbol member , Types types ) { for ( ClassSymbol scope = startingClass . owner . enclClass ( ) ; scope != null ; scope = scope . owner . enclClass ( ) ) { if ( member . isMemberOf ( scope . type . tsym , types ) ) { return scope ; } } return null ; }
--------------------------------------------------
public static boolean isJavaIdentifier ( String s ) { if ( isEmpty ( s ) || ! Character . isJavaIdentifierStart ( s . charAt ( 0 ) ) ) { return false ; } for ( int i = 1 ; i < s . length ( ) ; i ++ ) { if ( ! Character . isJavaIdentifierPart ( s . charAt ( i ) ) ) { return false ; } } return true ; }
--------------------------------------------------
( Tree parent , ExpressionTree tree , VisitorState state ) { if ( isStringConcat ( parent , state ) ) { return ToStringKind . IMPLICIT ; } if ( parent instanceof ExpressionTree ) { ExpressionTree parentExpression = ( ExpressionTree ) parent ; if ( PRINT_STRING . matches ( parentExpression , state ) ) { return ToStringKind . IMPLICIT ; } if ( VALUE_OF . matches ( parentExpression , state ) ) { return ToStringKind . EXPLICIT ; } } return ToStringKind . NONE ; }
--------------------------------------------------
boolean isAssignableTo ( Parameter target , VisitorState state ) { if ( state . getTypes ( ) . isSameType ( type ( ) , Type . noType ) || state . getTypes ( ) . isSameType ( target . type ( ) , Type . noType ) ) { return false ; } try { return state . getTypes ( ) . isAssignable ( type ( ) , target . type ( ) ) ; } catch ( CompletionFailure e ) { Check . instance ( state . context ) . completionError ( ( DiagnosticPosition ) state . getPath ( ) . getLeaf ( ) , e ) ; return false ; } }
--------------------------------------------------
private void registerServiceBean ( BeanDefinitionHolder beanDefinitionHolder , BeanDefinitionRegistry registry , DubboClassPathBeanDefinitionScanner scanner ) { Class < ? > beanClass = resolveClass ( beanDefinitionHolder ) ; Service service = findAnnotation ( beanClass , Service . class ) ; Class < ? > interfaceClass = resolveServiceInterfaceClass ( beanClass , service ) ; String annotatedServiceBeanName = beanDefinitionHolder . getBeanName ( ) ; AbstractBeanDefinition serviceBeanDefinition = buildServiceBeanDefinition ( service , interfaceClass , annotatedServiceBeanName ) ; String beanName = generateServiceBeanName ( service , interfaceClass , annotatedServiceBeanName ) ; if ( scanner . checkCandidate ( beanName , serviceBeanDefinition ) ) { registry . registerBeanDefinition ( beanName , serviceBeanDefinition ) ; if ( logger . isInfoEnabled ( ) ) { logger . info ( 'the beandefinition[' + serviceBeanDefinition + '] of servicebean has been registered with name : ' + beanName ) ; } } else { if ( logger . isWarnEnabled ( ) ) { logger . warn ( 'the duplicated beandefinition[' + serviceBeanDefinition + '] of servicebean[ bean name : ' + beanName + '] was be found , did @dubbocomponentscan scan to same package in many times?' ) ; } } }
--------------------------------------------------
static Optional < List < Configurator >> toConfigurators ( List < URL > urls ) { if ( CollectionUtils . isEmpty ( urls ) ) { return Optional . empty ( ) ; } ConfiguratorFactory configuratorFactory = ExtensionLoader . getExtensionLoader ( ConfiguratorFactory . class ) . getAdaptiveExtension ( ) ; List < Configurator > configurators = new ArrayList < > ( urls . size ( ) ) ; for ( URL url : urls ) { if ( Constants . EMPTY_PROTOCOL . equals ( url . getProtocol ( ) ) ) { configurators . clear ( ) ; break ; } Map < String , String > override = new HashMap < > ( url . getParameters ( ) ) ; override . remove ( Constants . ANYHOST_KEY ) ; if ( override . size ( ) == 0 ) { configurators . clear ( ) ; continue ; } configurators . add ( configuratorFactory . getConfigurator ( url ) ) ; } Collections . sort ( configurators ) ; return Optional . of ( configurators ) ; }
--------------------------------------------------
public List < String > getLines ( ) { try { return CharSource . wrap ( sourceBuilder ) . readLines ( ) ; } catch ( IOException e ) { throw new AssertionError ( 'ioexception not possible, as the string is in-memory' ) ; } }
--------------------------------------------------
private void registerServiceBean ( BeanDefinitionHolder beanDefinitionHolder , BeanDefinitionRegistry registry , DubboClassPathBeanDefinitionScanner scanner ) { Class < ? > beanClass = resolveClass ( beanDefinitionHolder ) ; Service service = findAnnotation ( beanClass , Service . class ) ; Class < ? > interfaceClass = resolveServiceInterfaceClass ( beanClass , service ) ; String annotatedServiceBeanName = beanDefinitionHolder . getBeanName ( ) ; AbstractBeanDefinition serviceBeanDefinition = buildServiceBeanDefinition ( service , interfaceClass , annotatedServiceBeanName ) ; String beanName = generateServiceBeanName ( service , interfaceClass , annotatedServiceBeanName ) ; if ( scanner . checkCandidate ( beanName , serviceBeanDefinition ) ) { registry . registerBeanDefinition ( beanName , serviceBeanDefinition ) ; if ( logger . isInfoEnabled ( ) ) { logger . warn ( 'the beandefinition[' + serviceBeanDefinition + '] of servicebean has been registered with name : ' + beanName ) ; } } else { if ( logger . isWarnEnabled ( ) ) { logger . warn ( 'the duplicated beandefinition[' + serviceBeanDefinition + '] of servicebean[ bean name : ' + beanName + '] was be found , did @compatibledubbocomponentscan scan to same package in many times?' ) ; } } }
--------------------------------------------------
private Object toFile ( VisitorState state , Tree fileArg , SuggestedFix . Builder fix ) { Type type = ASTHelpers . getType ( fileArg ) ; if ( ASTHelpers . isSubtype ( type , state . getSymtab ( ) . stringType , state ) ) { fix . addImport ( 'java.io.file' ) ; return String . format ( 'new file(%s)' , state . getSourceForNode ( fileArg ) ) ; } else if ( ASTHelpers . isSubtype ( type , state . getTypeFromString ( 'java.io.file' ) , state ) ) { return state . getSourceForNode ( fileArg ) ; } else { throw new AssertionError ( 'unexpected type: ' + type ) ; } }
--------------------------------------------------
