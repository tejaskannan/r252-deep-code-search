public static Optional < Integer > asIntegerValue ( Attribute a ) { class Visitor extends SimpleAnnotationValueVisitor8 < Integer , Void > { @ Override public Integer visitInt ( int i , Void unused ) { return i ; } } return Optional . ofNullable ( a . accept ( new Visitor ( ) , null ) ) ; }
--------------------------------------------------
default int compareTo ( Configurator o ) { if ( o == null ) { return - 1 ; } int ipCompare = getUrl ( ) . getHost ( ) . compareTo ( o . getUrl ( ) . getHost ( ) ) ; if ( ipCompare == 0 ) { int i = getUrl ( ) . getParameter ( Constants . PRIORITY_KEY , 0 ) ; int j = o . getUrl ( ) . getParameter ( Constants . PRIORITY_KEY , 0 ) ; return Integer . compare ( i , j ) ; } else { return ipCompare ; } }
--------------------------------------------------
public static ExpressionTree getRootAssignable ( MethodInvocationTree methodInvocationTree ) { if ( ! ( methodInvocationTree instanceof JCMethodInvocation ) ) { throw new IllegalArgumentException ( 'expected type to be jcmethodinvocation, but was ' + methodInvocationTree . getClass ( ) ) ; } if ( ( ( JCMethodInvocation ) methodInvocationTree ) . getMethodSelect ( ) instanceof JCIdent ) { return null ; } ExpressionTree expr = methodInvocationTree ; while ( expr instanceof JCMethodInvocation ) { expr = ( ( JCMethodInvocation ) expr ) . getMethodSelect ( ) ; if ( expr instanceof JCFieldAccess ) { expr = ( ( JCFieldAccess ) expr ) . getExpression ( ) ; } } Symbol sym = getSymbol ( expr ) ; if ( sym instanceof VarSymbol ) { return expr ; } return null ; }
--------------------------------------------------
( Tree parent , ExpressionTree tree , VisitorState state ) { if ( isStringConcat ( parent , state ) ) { return ToStringKind . IMPLICIT ; } if ( parent instanceof ExpressionTree ) { ExpressionTree parentExpression = ( ExpressionTree ) parent ; if ( PRINT_STRING . matches ( parentExpression , state ) ) { return ToStringKind . IMPLICIT ; } if ( VALUE_OF . matches ( parentExpression , state ) ) { return ToStringKind . EXPLICIT ; } } return ToStringKind . NONE ; }
--------------------------------------------------
boolean isAssignableTo ( Parameter target , VisitorState state ) { if ( state . getTypes ( ) . isSameType ( type ( ) , Type . noType ) || state . getTypes ( ) . isSameType ( target . type ( ) , Type . noType ) ) { return false ; } try { return state . getTypes ( ) . isAssignable ( type ( ) , target . type ( ) ) ; } catch ( CompletionFailure e ) { Check . instance ( state . context ) . completionError ( ( DiagnosticPosition ) state . getPath ( ) . getLeaf ( ) , e ) ; return false ; } }
--------------------------------------------------
private Object toFile ( VisitorState state , Tree fileArg , SuggestedFix . Builder fix ) { Type type = ASTHelpers . getType ( fileArg ) ; if ( ASTHelpers . isSubtype ( type , state . getSymtab ( ) . stringType , state ) ) { fix . addImport ( 'java.io.file' ) ; return String . format ( 'new file(%s)' , state . getSourceForNode ( fileArg ) ) ; } else if ( ASTHelpers . isSubtype ( type , state . getTypeFromString ( 'java.io.file' ) , state ) ) { return state . getSourceForNode ( fileArg ) ; } else { throw new AssertionError ( 'unexpected type: ' + type ) ; } }
--------------------------------------------------
private static IdentifierTree getRootIdentifier ( ExpressionTree tree ) { if ( tree == null ) { return null ; } switch ( tree . getKind ( ) ) { case IDENTIFIER : return ( IdentifierTree ) tree ; case MEMBER_SELECT : case METHOD_INVOCATION : return getRootIdentifier ( ASTHelpers . getReceiver ( tree ) ) ; default : return null ; } }
--------------------------------------------------
public TermEditDistance ( BiFunction < String , String , Double > editDistanceFn , BiFunction < Integer , Integer , Double > maxDistanceFn ) { this . editDistanceFn = editDistanceFn ; this . maxDistanceFn = maxDistanceFn ; }
--------------------------------------------------
public static boolean isSubtype ( Type s , Type t , VisitorState state ) { if ( s == null || t == null ) { return false ; } if ( SUBTYPE_UNDEFINED . contains ( s . getTag ( ) ) || SUBTYPE_UNDEFINED . contains ( t . getTag ( ) ) ) { return false ; } Types types = state . getTypes ( ) ; return types . isSubtype ( types . erasure ( s ) , types . erasure ( t ) ) ; }
--------------------------------------------------
public String toString ( ) { if ( importStrings . isEmpty ( ) ) { return '' ; } StringBuilder result = new StringBuilder ( ) ; if ( ! hasExistingImports ) { result . append ( '' ) ; } List < ImportOrganizer . Import > imports = importStrings . stream ( ) . map ( ImportOrganizer . Import :: importOf ) . collect ( Collectors . toList ( ) ) ; ImportOrganizer . OrganizedImports organizedImports = importOrganizer . organizeImports ( imports ) ; int expectedImportCount = imports . size ( ) ; int importCount = organizedImports . getImportCount ( ) ; if ( importCount != expectedImportCount ) { throw new IllegalStateException ( String . format ( 'expected %d import(s) in the organized imports but it contained %d' , expectedImportCount , importCount ) ) ; } result . append ( organizedImports . asImportBlock ( ) ) ; String replacementString = result . toString ( ) ; if ( ! hasExistingImports ) { return replacementString ; } else { return CharMatcher . whitespace ( ) . trimTrailingFrom ( replacementString ) ; } }
--------------------------------------------------
