public static String [ ] readLines ( InputStream is ) throws IOException { List < String > lines = new ArrayList < String > ( ) ; BufferedReader reader = new BufferedReader ( new InputStreamReader ( is ) ) ; try { String line ; while ( ( line = reader . readLine ( ) ) != null ) { lines . add ( line ) ; } return lines . toArray ( new String [ 0 ] ) ; } finally { reader . close ( ) ; } }
--------------------------------------------------
private String drawSeparationLine ( final int [ ] widthCacheArray ) { final StringBuilder separationLineSB = new StringBuilder ( ) ; final int lastCol = indexLastCol ( widthCacheArray ) ; final int colCount = widthCacheArray . length ; for ( int colIndex = 0 ; colIndex < colCount ; colIndex ++ ) { final int width = widthCacheArray [ colIndex ] ; if ( width <= 0 ) { continue ; } final boolean isFirstCol = colIndex == 0 ; final boolean isLastCol = colIndex == lastCol ; if ( isFirstCol && border . has ( Border . BORDER_OUTER_LEFT ) ) { separationLineSB . append ( '+' ) ; } if ( ! isFirstCol && border . has ( Border . BORDER_INNER_V ) ) { separationLineSB . append ( '+' ) ; } separationLineSB . append ( repeat ( '-' , width + 2 * padding ) ) ; if ( isLastCol && border . has ( Border . BORDER_OUTER_RIGHT ) ) { separationLineSB . append ( '+' ) ; } } return separationLineSB . toString ( ) ; }
--------------------------------------------------
public static String [ ] readLines ( File file ) throws IOException { if ( file == null || ! file . exists ( ) || ! file . canRead ( ) ) { return new String [ 0 ] ; } return readLines ( new FileInputStream ( file ) ) ; }
--------------------------------------------------
private Object toFile ( VisitorState state , Tree fileArg , SuggestedFix . Builder fix ) { Type type = ASTHelpers . getType ( fileArg ) ; if ( ASTHelpers . isSubtype ( type , state . getSymtab ( ) . stringType , state ) ) { fix . addImport ( 'java.io.file' ) ; return String . format ( 'new file(%s)' , state . getSourceForNode ( fileArg ) ) ; } else if ( ASTHelpers . isSubtype ( type , state . getTypeFromString ( 'java.io.file' ) , state ) ) { return state . getSourceForNode ( fileArg ) ; } else { throw new AssertionError ( 'unexpected type: ' + type ) ; } }
--------------------------------------------------
private static ImmutableList < String > setCompilePolicyToByFile ( ImmutableList < String > args ) { for ( String arg : args ) { if ( arg . startsWith ( '-xdcompilepolicy' ) ) { String value = arg . substring ( arg . indexOf ( '=' ) + 1 ) ; checkCompilePolicy ( value ) ; return args ; } } return ImmutableList . < String > builder ( ) . addAll ( args ) . add ( '-xdcompilepolicy=byfile' ) . build ( ) ; }
--------------------------------------------------
private static List < String > extractPatterns ( String line , BufferedReader reader , String matchString ) throws IOException { int bugMarkerIndex = line . indexOf ( matchString ) ; if ( bugMarkerIndex < 0 ) { throw new IllegalArgumentException ( 'line must contain bug marker prefix' ) ; } List < String > result = new ArrayList < > ( ) ; String restOfLine = line . substring ( bugMarkerIndex + matchString . length ( ) ) . trim ( ) ; result . add ( restOfLine ) ; line = reader . readLine ( ) . trim ( ) ; while ( line . startsWith ( '//' ) ) { restOfLine = line . substring ( 2 ) . trim ( ) ; result . add ( restOfLine ) ; line = reader . readLine ( ) . trim ( ) ; } return result ; }
--------------------------------------------------
public static ImmutableSet < String > getGeneratedBy ( ClassSymbol symbol , VisitorState state ) { checkNotNull ( symbol ) ; Optional < Compound > c = Stream . of ( 'javax.annotation.generated' , 'javax.annotation.processing.generated' ) . map ( state :: getSymbolFromString ) . filter ( a -> a != null ) . map ( symbol :: attribute ) . filter ( a -> a != null ) . findFirst ( ) ; if ( ! c . isPresent ( ) ) { return ImmutableSet . of ( ) ; } Optional < Attribute > values = c . get ( ) . getElementValues ( ) . entrySet ( ) . stream ( ) . filter ( e -> e . getKey ( ) . getSimpleName ( ) . contentEquals ( 'value' ) ) . map ( e -> e . getValue ( ) ) . findAny ( ) ; if ( ! values . isPresent ( ) ) { return ImmutableSet . of ( ) ; } ImmutableSet . Builder < String > suppressions = ImmutableSet . builder ( ) ; values . get ( ) . accept ( new SimpleAnnotationValueVisitor8 < Void , Void > ( ) { @ Override public Void visitString ( String s , Void aVoid ) { suppressions . add ( s ) ; return super . visitString ( s , aVoid ) ; } @ Override public Void visitArray ( List < ? extends AnnotationValue > vals , Void aVoid ) { vals . stream ( ) . forEachOrdered ( v -> v . accept ( this , null ) ) ; return super . visitArray ( vals , aVoid ) ; } } , null ) ; return suppressions . build ( ) ; }
--------------------------------------------------
public static void writeLines ( OutputStream os , String [ ] lines ) throws IOException { PrintWriter writer = new PrintWriter ( new OutputStreamWriter ( os ) ) ; try { for ( String line : lines ) { writer . println ( line ) ; } writer . flush ( ) ; } finally { writer . close ( ) ; } }
--------------------------------------------------
public void assertHasDiagnosticOnAllMatchingLines ( JavaFileObject source , LookForCheckNameInDiagnostic lookForCheckNameInDiagnostic ) throws IOException { final List < Diagnostic < ? extends JavaFileObject >> diagnostics = getDiagnostics ( ) ; final LineNumberReader reader = new LineNumberReader ( CharSource . wrap ( source . getCharContent ( false ) ) . openStream ( ) ) ; do { String line = reader . readLine ( ) ; if ( line == null ) { break ; } List < Predicate < ? super String >> predicates = null ; if ( line . contains ( BUG_MARKER_COMMENT_INLINE ) ) { List < String > patterns = extractPatterns ( line , reader , BUG_MARKER_COMMENT_INLINE ) ; predicates = new ArrayList < > ( patterns . size ( ) ) ; for ( String pattern : patterns ) { predicates . add ( new SimpleStringContains ( pattern ) ) ; } } else if ( line . contains ( BUG_MARKER_COMMENT_LOOKUP ) ) { int markerLineNumber = reader . getLineNumber ( ) ; List < String > lookupKeys = extractPatterns ( line , reader , BUG_MARKER_COMMENT_LOOKUP ) ; predicates = new ArrayList < > ( lookupKeys . size ( ) ) ; for ( String lookupKey : lookupKeys ) { assertWithMessage ( 'no expected error message with key [%s] as expected from line [%s] ' '+' 'with diagnostic [%s]' , lookupKey , markerLineNumber , line . trim ( ) ) . that ( expectedErrorMsgs . containsKey ( lookupKey ) ) . isTrue ( ) ; predicates . add ( expectedErrorMsgs . get ( lookupKey ) ) ; usedLookupKeys . add ( lookupKey ) ; } } if ( predicates != null ) { int lineNumber = reader . getLineNumber ( ) ; for ( Predicate < ? super String > predicate : predicates ) { Matcher < ? super Iterable < Diagnostic < ? extends JavaFileObject >>> patternMatcher = hasItem ( diagnosticOnLine ( source . toUri ( ) , lineNumber , predicate ) ) ; assertWithMessage ( 'did not see an error on line %s matching %s. %s' , lineNumber , predicate , allErrors ( diagnostics ) ) . that ( patternMatcher . matches ( diagnostics ) ) . isTrue ( ) ; } if ( checkName != null && lookForCheckNameInDiagnostic == LookForCheckNameInDiagnostic . YES ) { Matcher < ? super Iterable < Diagnostic < ? extends JavaFileObject >>> checkNameMatcher = hasItem ( diagnosticOnLine ( source . toUri ( ) , lineNumber , new SimpleStringContains ( '[' + checkName + ']' ) ) ) ; assertWithMessage ( 'did not see an error on line %s containing [%s]. %s' , lineNumber , checkName , allErrors ( diagnostics ) ) . that ( checkNameMatcher . matches ( diagnostics ) ) . isTrue ( ) ; } } else { int lineNumber = reader . getLineNumber ( ) ; Matcher < ? super Iterable < Diagnostic < ? extends JavaFileObject >>> matcher = hasItem ( diagnosticOnLine ( source . toUri ( ) , lineNumber ) ) ; if ( matcher . matches ( diagnostics ) ) { fail ( 'saw unexpected error on line ' + lineNumber + '. ' + allErrors ( diagnostics ) ) ; } } } while ( true ) ; reader . close ( ) ; }
--------------------------------------------------
public JavaFileObject forResource ( String fileName ) { Preconditions . checkState ( clazz . isPresent ( ) , 'clazz must be set if you want to add a source from a resource file' ) ; return forResource ( clazz . get ( ) , fileName ) ; }
--------------------------------------------------
