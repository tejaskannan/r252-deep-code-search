public static ImmutableSet < String > getGeneratedBy ( ClassSymbol symbol , VisitorState state ) { checkNotNull ( symbol ) ; Optional < Compound > c = Stream . of ( 'javax.annotation.generated' , 'javax.annotation.processing.generated' ) . map ( state :: getSymbolFromString ) . filter ( a -> a != null ) . map ( symbol :: attribute ) . filter ( a -> a != null ) . findFirst ( ) ; if ( ! c . isPresent ( ) ) { return ImmutableSet . of ( ) ; } Optional < Attribute > values = c . get ( ) . getElementValues ( ) . entrySet ( ) . stream ( ) . filter ( e -> e . getKey ( ) . getSimpleName ( ) . contentEquals ( 'value' ) ) . map ( e -> e . getValue ( ) ) . findAny ( ) ; if ( ! values . isPresent ( ) ) { return ImmutableSet . of ( ) ; } ImmutableSet . Builder < String > suppressions = ImmutableSet . builder ( ) ; values . get ( ) . accept ( new SimpleAnnotationValueVisitor8 < Void , Void > ( ) { @ Override public Void visitString ( String s , Void aVoid ) { suppressions . add ( s ) ; return super . visitString ( s , aVoid ) ; } @ Override public Void visitArray ( List < ? extends AnnotationValue > vals , Void aVoid ) { vals . stream ( ) . forEachOrdered ( v -> v . accept ( this , null ) ) ; return super . visitArray ( vals , aVoid ) ; } } , null ) ; return suppressions . build ( ) ; }
--------------------------------------------------
public static VisitorState createForCustomFindingCollection ( Context context , DescriptionListener listener ) { return new VisitorState ( context , listener , ImmutableMap . of ( ) , ErrorProneOptions . empty ( ) , StatisticsCollector . createCollector ( ) , null , null , SuppressedState . UNSUPPRESSED ) ; }
--------------------------------------------------
public static Method findMethodByMethodSignature ( Class < ? > clazz , String methodName , String [ ] parameterTypes ) throws NoSuchMethodException , ClassNotFoundException { String signature = clazz . getName ( ) + '.' + methodName ; if ( parameterTypes != null && parameterTypes . length > 0 ) { signature += StringUtils . join ( parameterTypes ) ; } Method method = Signature_METHODS_CACHE . get ( signature ) ; if ( method != null ) { return method ; } if ( parameterTypes == null ) { List < Method > finded = new ArrayList < Method > ( ) ; for ( Method m : clazz . getMethods ( ) ) { if ( m . getName ( ) . equals ( methodName ) ) { finded . add ( m ) ; } } if ( finded . isEmpty ( ) ) { throw new NoSuchMethodException ( 'no such method ' + methodName + ' in class ' + clazz ) ; } if ( finded . size ( ) > 1 ) { String msg = String . format ( 'not unique method for method name(%s) in class(%s), find %d methods.' , methodName , clazz . getName ( ) , finded . size ( ) ) ; throw new IllegalStateException ( msg ) ; } method = finded . get ( 0 ) ; } else { Class < ? > [ ] types = new Class < ? > [ parameterTypes . length ] ; for ( int i = 0 ; i < parameterTypes . length ; i ++ ) { types [ i ] = ReflectUtils . name2class ( parameterTypes [ i ] ) ; } method = clazz . getMethod ( methodName , types ) ; } Signature_METHODS_CACHE . put ( signature , method ) ; return method ; }
--------------------------------------------------
static Optional < List < Configurator >> toConfigurators ( List < URL > urls ) { if ( CollectionUtils . isEmpty ( urls ) ) { return Optional . empty ( ) ; } ConfiguratorFactory configuratorFactory = ExtensionLoader . getExtensionLoader ( ConfiguratorFactory . class ) . getAdaptiveExtension ( ) ; List < Configurator > configurators = new ArrayList < > ( urls . size ( ) ) ; for ( URL url : urls ) { if ( Constants . EMPTY_PROTOCOL . equals ( url . getProtocol ( ) ) ) { configurators . clear ( ) ; break ; } Map < String , String > override = new HashMap < > ( url . getParameters ( ) ) ; override . remove ( Constants . ANYHOST_KEY ) ; if ( override . size ( ) == 0 ) { configurators . clear ( ) ; continue ; } configurators . add ( configuratorFactory . getConfigurator ( url ) ) ; } Collections . sort ( configurators ) ; return Optional . of ( configurators ) ; }
--------------------------------------------------
private String buildMessage ( GuardedByExpression guard , HeldLockSet locks ) { int heldLocks = locks . allLocks ( ) . size ( ) ; StringBuilder message = new StringBuilder ( ) ; Select enclosing = findOuterInstance ( guard ) ; if ( enclosing != null && ! enclosingInstance ( guard ) ) { if ( guard == enclosing ) { message . append ( String . format ( 'access should be guarded by enclosing instance '%s' of '%s',' '+' ' which is not accessible in this scope' , enclosing . sym ( ) . owner , enclosing . base ( ) ) ) ; } else { message . append ( String . format ( 'access should be guarded by '%s' in enclosing instance '%s' of '%s',' '+' ' which is not accessible in this scope' , guard . sym ( ) , enclosing . sym ( ) . owner , enclosing . base ( ) ) ) ; } if ( heldLocks > 0 ) { message . append ( String . format ( '; instead found: '%s'' , Joiner . on ( '', '' ) . join ( locks . allLocks ( ) ) ) ) ; } return message . toString ( ) ; } message . append ( String . format ( 'this access should be guarded by '%s'' , guard ) ) ; if ( guard . kind ( ) == GuardedByExpression . Kind . ERROR ) { message . append ( ', which could not be resolved' ) ; return message . toString ( ) ; } if ( heldLocks == 0 ) { message . append ( ', which is not currently held' ) ; } else { message . append ( String . format ( '; instead found: '%s'' , Joiner . on ( '', '' ) . join ( locks . allLocks ( ) ) ) ) ; } return message . toString ( ) ; }
--------------------------------------------------
public static List < VarSymbol > findAllFields ( Type classType , VisitorState state ) { return state . getTypes ( ) . closure ( classType ) . stream ( ) . flatMap ( type -> { TypeSymbol tsym = type . tsym ; if ( tsym == null ) { return ImmutableList . < VarSymbol > of ( ) . stream ( ) ; } WriteableScope scope = tsym . members ( ) ; if ( scope == null ) { return ImmutableList . < VarSymbol > of ( ) . stream ( ) ; } return ImmutableList . copyOf ( scope . getSymbols ( VarSymbol . class :: isInstance ) ) . reverse ( ) . stream ( ) . map ( v -> ( VarSymbol ) v ) . filter ( v -> isVisible ( v , state . getPath ( ) ) ) ; } ) . collect ( Collectors . toCollection ( ArrayList :: new ) ) ; }
--------------------------------------------------
public List < T > getActivateExtension ( URL url , String [ ] values , String group ) { List < T > exts = new ArrayList < > ( ) ; List < String > names = values == null ? new ArrayList < > ( 0 ) : Arrays . asList ( values ) ; if ( ! names . contains ( Constants . REMOVE_VALUE_PREFIX + Constants . DEFAULT_KEY ) ) { getExtensionClasses ( ) ; for ( Map . Entry < String , Object > entry : cachedActivates . entrySet ( ) ) { String name = entry . getKey ( ) ; Object activate = entry . getValue ( ) ; String [ ] activateGroup , activateValue ; if ( activate instanceof Activate ) { activateGroup = ( ( Activate ) activate ) . group ( ) ; activateValue = ( ( Activate ) activate ) . value ( ) ; } else if ( activate instanceof com . alibaba . dubbo . common . extension . Activate ) { activateGroup = ( ( com . alibaba . dubbo . common . extension . Activate ) activate ) . group ( ) ; activateValue = ( ( com . alibaba . dubbo . common . extension . Activate ) activate ) . value ( ) ; } else { continue ; } if ( isMatchGroup ( group , activateGroup ) ) { T ext = getExtension ( name ) ; if ( ! names . contains ( name ) && ! names . contains ( Constants . REMOVE_VALUE_PREFIX + name ) && isActive ( activateValue , url ) ) { exts . add ( ext ) ; } } } exts . sort ( ActivateComparator . COMPARATOR ) ; } List < T > usrs = new ArrayList < > ( ) ; for ( int i = 0 ; i < names . size ( ) ; i ++ ) { String name = names . get ( i ) ; if ( ! name . startsWith ( Constants . REMOVE_VALUE_PREFIX ) && ! names . contains ( Constants . REMOVE_VALUE_PREFIX + name ) ) { if ( Constants . DEFAULT_KEY . equals ( name ) ) { if ( ! usrs . isEmpty ( ) ) { exts . addAll ( 0 , usrs ) ; usrs . clear ( ) ; } } else { T ext = getExtension ( name ) ; usrs . add ( ext ) ; } } } if ( ! usrs . isEmpty ( ) ) { exts . addAll ( usrs ) ; } return exts ; }
--------------------------------------------------
private Optional < List < Router >> toRouters ( List < URL > urls ) { if ( urls == null || urls . isEmpty ( ) ) { return Optional . empty ( ) ; } List < Router > routers = new ArrayList < > ( ) ; for ( URL url : urls ) { if ( Constants . EMPTY_PROTOCOL . equals ( url . getProtocol ( ) ) ) { continue ; } String routerType = url . getParameter ( Constants . ROUTER_KEY ) ; if ( routerType != null && routerType . length ( ) > 0 ) { url = url . setProtocol ( routerType ) ; } try { Router router = routerFactory . getRouter ( url ) ; if ( ! routers . contains ( router ) ) { routers . add ( router ) ; } } catch ( Throwable t ) { logger . error ( 'convert router url to router error, url: ' + url , t ) ; } } return Optional . of ( routers ) ; }
--------------------------------------------------
private Description checkAnnotations ( Tree tree , int treePos , List < ? extends AnnotationTree > annotations , Comment danglingJavadoc , int firstModifierPos , int lastModifierPos , VisitorState state ) { SuggestedFix . Builder builder = SuggestedFix . builder ( ) ; List < AnnotationTree > moveBefore = new ArrayList < > ( ) ; List < AnnotationTree > moveAfter = new ArrayList < > ( ) ; boolean annotationProblem = false ; for ( AnnotationTree annotation : annotations ) { int annotationPos = ( ( JCTree ) annotation ) . getStartPosition ( ) ; if ( annotationPos <= firstModifierPos ) { continue ; } AnnotationType annotationType = ASTHelpers . getAnnotationType ( annotation , getSymbol ( tree ) , state ) ; if ( annotationPos >= lastModifierPos ) { if ( tree instanceof ClassTree || annotationType == AnnotationType . DECLARATION ) { annotationProblem = true ; moveBefore . add ( annotation ) ; } } else { annotationProblem = true ; if ( tree instanceof ClassTree || annotationType == AnnotationType . DECLARATION || annotationType == null ) { moveBefore . add ( annotation ) ; } else { moveAfter . add ( annotation ) ; } } } if ( annotationProblem ) { for ( AnnotationTree annotation : moveBefore ) { builder . delete ( annotation ) ; } for ( AnnotationTree annotation : moveAfter ) { builder . delete ( annotation ) ; } String javadoc = danglingJavadoc == null ? '' : removeJavadoc ( state , treePos , danglingJavadoc , builder ) ; builder . replace ( firstModifierPos , firstModifierPos , String . format ( '%s%s ' , javadoc , joinSource ( state , moveBefore ) ) ) . replace ( lastModifierPos , lastModifierPos , String . format ( '%s ' , joinSource ( state , moveAfter ) ) ) ; ImmutableList < String > names = annotations . stream ( ) . map ( ASTHelpers :: getSymbol ) . filter ( Objects :: nonNull ) . map ( Symbol :: getSimpleName ) . map ( a -> '@' + a ) . collect ( toImmutableList ( ) ) ; String flattened = names . stream ( ) . collect ( joining ( ', ' ) ) ; String isAre = names . size ( ) > 1 ? 'are not type annotations' : 'is not a type annotation' ; String message = String . format ( '%s %s, so should appear before any modifiers and after javadocs.' , flattened , isAre ) ; return buildDescription ( tree ) . setMessage ( message ) . addFix ( builder . build ( ) ) . build ( ) ; } return NO_MATCH ; }
--------------------------------------------------
private static List < List < Parameter >> findArgumentsForOtherInstances ( MethodSymbol calledMethod , Tree currentNode , VisitorState state ) { Tree enclosingNode = ASTHelpers . findEnclosingNode ( state . getPath ( ) , MethodTree . class ) ; if ( enclosingNode == null ) { enclosingNode = ASTHelpers . findEnclosingNode ( state . getPath ( ) , ClassTree . class ) ; } if ( enclosingNode == null ) { return ImmutableList . of ( ) ; } ImmutableList . Builder < List < Parameter >> resultBuilder = ImmutableList . builder ( ) ; new TreeScanner < Void , Void > ( ) { @ Override public Void visitMethodInvocation ( MethodInvocationTree methodInvocationTree , Void aVoid ) { addToResult ( ASTHelpers . getSymbol ( methodInvocationTree ) , methodInvocationTree ) ; return super . visitMethodInvocation ( methodInvocationTree , aVoid ) ; } @ Override public Void visitNewClass ( NewClassTree newClassTree , Void aVoid ) { addToResult ( ASTHelpers . getSymbol ( newClassTree ) , newClassTree ) ; return super . visitNewClass ( newClassTree , aVoid ) ; } @ Override public Void visitMethod ( MethodTree methodTree , Void aVoid ) { MethodSymbol methodSymbol = ASTHelpers . getSymbol ( methodTree ) ; if ( methodSymbol != null ) { addToResult ( methodSymbol , methodTree ) ; for ( MethodSymbol superSymbol : ASTHelpers . findSuperMethods ( methodSymbol , state . getTypes ( ) ) ) { addToResult ( superSymbol , methodTree ) ; } } return super . visitMethod ( methodTree , aVoid ) ; } private void addToResult ( MethodSymbol foundSymbol , Tree tree ) { if ( foundSymbol != null && Objects . equals ( calledMethod , foundSymbol ) && ! currentNode . equals ( tree ) ) { resultBuilder . add ( createParameterList ( tree ) ) ; } } private ImmutableList < Parameter > createParameterList ( Tree tree ) { if ( tree instanceof MethodInvocationTree ) { return Parameter . createListFromExpressionTrees ( ( ( MethodInvocationTree ) tree ) . getArguments ( ) ) ; } if ( tree instanceof NewClassTree ) { return Parameter . createListFromExpressionTrees ( ( ( NewClassTree ) tree ) . getArguments ( ) ) ; } if ( tree instanceof MethodTree ) { return Parameter . createListFromVariableTrees ( ( ( MethodTree ) tree ) . getParameters ( ) ) ; } return ImmutableList . of ( ) ; } } . scan ( enclosingNode , null ) ; return resultBuilder . build ( ) ; }
--------------------------------------------------
