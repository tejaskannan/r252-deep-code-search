public static < T extends Enum < T >> Optional < T > asEnumValue ( Class < T > clazz , Attribute a ) { class Visitor extends SimpleAnnotationValueVisitor8 < T , Void > { @ Override public T visitEnumConstant ( VariableElement c , Void unused ) { return Enum . valueOf ( clazz , c . getSimpleName ( ) . toString ( ) ) ; } } return Optional . ofNullable ( a . accept ( new Visitor ( ) , null ) ) ; }
--------------------------------------------------
public < T extends Enum < T >> Optional < ImmutableSet < T >> getEnumSet ( String key , Class < T > clazz ) { return this . get ( key ) . map ( value -> Streams . stream ( Splitter . on ( ',' ) . omitEmptyStrings ( ) . split ( value ) ) . map ( v -> asEnumValue ( key , v , clazz ) ) . collect ( toImmutableSet ( ) ) ) ; }
--------------------------------------------------
public static LinkedHashSet < String > enumValues ( TypeSymbol enumType ) { if ( enumType . getKind ( ) != ElementKind . ENUM ) { throw new IllegalStateException ( ) ; } Scope scope = enumType . members ( ) ; Deque < String > values = new ArrayDeque < > ( ) ; for ( Symbol sym : scope . getSymbols ( ) ) { if ( sym instanceof VarSymbol ) { VarSymbol var = ( VarSymbol ) sym ; if ( ( var . flags ( ) & Flags . ENUM ) != 0 ) { values . push ( sym . name . toString ( ) ) ; } } } return new LinkedHashSet < > ( values ) ; }
--------------------------------------------------
public static ImmutableSet < String > getGeneratedBy ( ClassSymbol symbol , VisitorState state ) { checkNotNull ( symbol ) ; Optional < Compound > c = Stream . of ( 'javax.annotation.generated' , 'javax.annotation.processing.generated' ) . map ( state :: getSymbolFromString ) . filter ( a -> a != null ) . map ( symbol :: attribute ) . filter ( a -> a != null ) . findFirst ( ) ; if ( ! c . isPresent ( ) ) { return ImmutableSet . of ( ) ; } Optional < Attribute > values = c . get ( ) . getElementValues ( ) . entrySet ( ) . stream ( ) . filter ( e -> e . getKey ( ) . getSimpleName ( ) . contentEquals ( 'value' ) ) . map ( e -> e . getValue ( ) ) . findAny ( ) ; if ( ! values . isPresent ( ) ) { return ImmutableSet . of ( ) ; } ImmutableSet . Builder < String > suppressions = ImmutableSet . builder ( ) ; values . get ( ) . accept ( new SimpleAnnotationValueVisitor8 < Void , Void > ( ) { @ Override public Void visitString ( String s , Void aVoid ) { suppressions . add ( s ) ; return super . visitString ( s , aVoid ) ; } @ Override public Void visitArray ( List < ? extends AnnotationValue > vals , Void aVoid ) { vals . stream ( ) . forEachOrdered ( v -> v . accept ( this , null ) ) ; return super . visitArray ( vals , aVoid ) ; } } , null ) ; return suppressions . build ( ) ; }
--------------------------------------------------
private static ImmutableList < String > setCompilePolicyToByFile ( ImmutableList < String > args ) { for ( String arg : args ) { if ( arg . startsWith ( '-xdcompilepolicy' ) ) { String value = arg . substring ( arg . indexOf ( '=' ) + 1 ) ; checkCompilePolicy ( value ) ; return args ; } } return ImmutableList . < String > builder ( ) . addAll ( args ) . add ( '-xdcompilepolicy=byfile' ) . build ( ) ; }
--------------------------------------------------
public static void checkGuardedBy ( boolean condition , String formatString , Object ... formatArgs ) { if ( ! condition ) { throw new IllegalGuardedBy ( String . format ( formatString , formatArgs ) ) ; } }
--------------------------------------------------
public static void checkGuardedBy ( boolean condition , String message ) { if ( ! condition ) { throw new IllegalGuardedBy ( message ) ; } }
--------------------------------------------------
public boolean setIndexedVariable ( int index , Object value ) { Object [ ] lookup = indexedVariables ; if ( index < lookup . length ) { Object oldValue = lookup [ index ] ; lookup [ index ] = value ; return oldValue == UNSET ; } else { expandIndexedVariableTableAndSet ( index , value ) ; return true ; } }
--------------------------------------------------
public static String getIpByHost ( String hostName ) { try { return InetAddress . getByName ( hostName ) . getHostAddress ( ) ; } catch ( UnknownHostException e ) { return hostName ; } }
--------------------------------------------------
public String getFragmentByLines ( int startLine , int endLine ) { Preconditions . checkArgument ( startLine <= endLine ) ; return Joiner . on ( '' ) . join ( getLines ( startLine , endLine ) ) + '' ; }
--------------------------------------------------
