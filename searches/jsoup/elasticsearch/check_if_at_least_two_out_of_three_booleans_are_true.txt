public Violation checkInstantiation ( Collection < TypeVariableSymbol > typeParameters , Collection < Type > typeArguments ) { return Streams . zip ( typeParameters . stream ( ) , typeArguments . stream ( ) , ( sym , type ) -> { if ( ! hasThreadSafeTypeParameterAnnotation ( sym ) ) { return Violation . absent ( ) ; } Violation info = isThreadSafeType ( true , ImmutableSet . of ( ) , type ) ; if ( ! info . isPresent ( ) ) { return Violation . absent ( ) ; } return info . plus ( String . format ( 'instantiation of '%s' is %s' , sym , purpose . mutableOrNotThreadSafe ( ) ) ) ; } ) . filter ( Violation :: isPresent ) . findFirst ( ) . orElse ( Violation . absent ( ) ) ; }
--------------------------------------------------
private Optional < Double > check ( ExpressionTree toleranceArgument , ExpressionTree actualArgument ) { Number actual = ASTHelpers . constValue ( actualArgument , Number . class ) ; Number tolerance = ASTHelpers . constValue ( toleranceArgument , Number . class ) ; if ( actual == null || tolerance == null ) { return Optional . empty ( ) ; } return isIntolerantComparison ( tolerance , actual ) ? Optional . of ( nextNumber ( actual ) . doubleValue ( ) ) : Optional . empty ( ) ; }
--------------------------------------------------
private Description checkAnnotations ( Tree tree , int treePos , List < ? extends AnnotationTree > annotations , Comment danglingJavadoc , int firstModifierPos , int lastModifierPos , VisitorState state ) { SuggestedFix . Builder builder = SuggestedFix . builder ( ) ; List < AnnotationTree > moveBefore = new ArrayList < > ( ) ; List < AnnotationTree > moveAfter = new ArrayList < > ( ) ; boolean annotationProblem = false ; for ( AnnotationTree annotation : annotations ) { int annotationPos = ( ( JCTree ) annotation ) . getStartPosition ( ) ; if ( annotationPos <= firstModifierPos ) { continue ; } AnnotationType annotationType = ASTHelpers . getAnnotationType ( annotation , getSymbol ( tree ) , state ) ; if ( annotationPos >= lastModifierPos ) { if ( tree instanceof ClassTree || annotationType == AnnotationType . DECLARATION ) { annotationProblem = true ; moveBefore . add ( annotation ) ; } } else { annotationProblem = true ; if ( tree instanceof ClassTree || annotationType == AnnotationType . DECLARATION || annotationType == null ) { moveBefore . add ( annotation ) ; } else { moveAfter . add ( annotation ) ; } } } if ( annotationProblem ) { for ( AnnotationTree annotation : moveBefore ) { builder . delete ( annotation ) ; } for ( AnnotationTree annotation : moveAfter ) { builder . delete ( annotation ) ; } String javadoc = danglingJavadoc == null ? '' : removeJavadoc ( state , treePos , danglingJavadoc , builder ) ; builder . replace ( firstModifierPos , firstModifierPos , String . format ( '%s%s ' , javadoc , joinSource ( state , moveBefore ) ) ) . replace ( lastModifierPos , lastModifierPos , String . format ( '%s ' , joinSource ( state , moveAfter ) ) ) ; ImmutableList < String > names = annotations . stream ( ) . map ( ASTHelpers :: getSymbol ) . filter ( Objects :: nonNull ) . map ( Symbol :: getSimpleName ) . map ( a -> '@' + a ) . collect ( toImmutableList ( ) ) ; String flattened = names . stream ( ) . collect ( joining ( ', ' ) ) ; String isAre = names . size ( ) > 1 ? 'are not type annotations' : 'is not a type annotation' ; String message = String . format ( '%s %s, so should appear before any modifiers and after javadocs.' , flattened , isAre ) ; return buildDescription ( tree ) . setMessage ( message ) . addFix ( builder . build ( ) ) . build ( ) ; } return NO_MATCH ; }
--------------------------------------------------
( Optional < ClassTree > tree , ImmutableSet < String > immutableTyParams , ClassType classType , ViolationReporter reporter ) { ClassSymbol classSym = ( ClassSymbol ) classType . tsym ; if ( classSym . members ( ) == null ) { return Violation . absent ( ) ; } Filter < Symbol > instanceFieldFilter = new Filter < Symbol > ( ) { @ Override public boolean accepts ( Symbol symbol ) { return symbol . getKind ( ) == ElementKind . FIELD && ! symbol . isStatic ( ) ; } } ; Map < Symbol , Tree > declarations = new HashMap < > ( ) ; if ( tree . isPresent ( ) ) { for ( Tree member : tree . get ( ) . getMembers ( ) ) { Symbol sym = ASTHelpers . getSymbol ( member ) ; if ( sym != null ) { declarations . put ( sym , member ) ; } } } List < Symbol > members = ImmutableList . copyOf ( classSym . members ( ) . getSymbols ( instanceFieldFilter ) ) . reverse ( ) ; for ( Symbol member : members ) { Optional < Tree > memberTree = Optional . ofNullable ( declarations . get ( member ) ) ; Violation info = isFieldImmutable ( memberTree , immutableTyParams , classSym , classType , ( VarSymbol ) member , reporter ) ; if ( info . isPresent ( ) ) { return info ; } } return Violation . absent ( ) ; }
--------------------------------------------------
private long calculateLeastDuration ( int time ) { if ( time / Constants . HEARTBEAT_CHECK_TICK <= 0 ) { return Constants . LEAST_HEARTBEAT_DURATION ; } else { return time / Constants . HEARTBEAT_CHECK_TICK ; } }
--------------------------------------------------
private long calculateLeastDuration ( int time ) { if ( time / Constants . HEARTBEAT_CHECK_TICK <= 0 ) { return Constants . LEAST_HEARTBEAT_DURATION ; } else { return time / Constants . HEARTBEAT_CHECK_TICK ; } }
--------------------------------------------------
private Description checkSubtype ( ClassTree tree , VisitorState state ) { ClassSymbol sym = ASTHelpers . getSymbol ( tree ) ; if ( sym == null ) { return NO_MATCH ; } Type superType = immutableSupertype ( sym , state ) ; if ( superType == null ) { return NO_MATCH ; } String message = String . format ( 'class extends @immutable type %s, but is not annotated as immutable' , superType ) ; Fix fix = SuggestedFix . builder ( ) . prefixWith ( tree , '@immutable ' ) . addImport ( Immutable . class . getName ( ) ) . build ( ) ; return buildDescription ( tree ) . setMessage ( message ) . addFix ( fix ) . build ( ) ; }
--------------------------------------------------
protected void checkRegistry ( ) { loadRegistriesFromBackwardConfig ( ) ; convertRegistryIdsToRegistries ( ) ; for ( RegistryConfig registryConfig : registries ) { if ( ! registryConfig . isValid ( ) ) { throw new IllegalStateException ( 'no registry config found or it's not a valid config! ' '+' 'the registry config is: ' + registryConfig ) ; } } useRegistryForConfigIfNecessary ( ) ; }
--------------------------------------------------
public Violation checkSuperInstantiation ( Set < String > containerTypeParameters , AnnotationInfo annotation , Type type ) { Violation info = threadSafeInstantiation ( containerTypeParameters , annotation , type ) ; if ( info . isPresent ( ) ) { return info ; } return Streams . zip ( type . asElement ( ) . getTypeParameters ( ) . stream ( ) , type . getTypeArguments ( ) . stream ( ) , ( typaram , argument ) -> { if ( containerOfSubtyping ( containerTypeParameters , annotation , typaram , argument ) ) { return Violation . of ( String . format ( ''%s' is not a container of '%s'' , annotation . typeName ( ) , typaram ) ) ; } return Violation . absent ( ) ; } ) . filter ( Violation :: isPresent ) . findFirst ( ) . orElse ( Violation . absent ( ) ) ; }
--------------------------------------------------
private MethodType callCheckMethod ( Warner warner , Inliner inliner , Object resultInfo , List < Type > actualArgTypes , MethodSymbol methodSymbol , Type site , Env < AttrContext > env ) throws InferException { try { Method checkMethod ; checkMethod = Resolve . class . getDeclaredMethod ( 'checkmethod' , Env . class , Type . class , Symbol . class , Class . forName ( 'com.sun.tools.javac.comp.attr$resultinfo' ) , List . class , List . class , Warner . class ) ; checkMethod . setAccessible ( true ) ; return ( MethodType ) checkMethod . invoke ( Resolve . instance ( inliner . getContext ( ) ) , env , site , methodSymbol , resultInfo , actualArgTypes , List . < Type > nil ( ) , warner ) ; } catch ( InvocationTargetException e ) { if ( e . getCause ( ) instanceof Resolve . InapplicableMethodException ) { throw new InferException ( ImmutableList . of ( ( ( Resolve . InapplicableMethodException ) e . getTargetException ( ) ) . getDiagnostic ( ) ) ) ; } throw new LinkageError ( e . getMessage ( ) , e . getCause ( ) ) ; } catch ( ReflectiveOperationException e ) { throw new LinkageError ( e . getMessage ( ) , e ) ; } }
--------------------------------------------------
