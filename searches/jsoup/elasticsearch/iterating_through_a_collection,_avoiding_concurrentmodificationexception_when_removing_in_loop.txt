public static < T extends Tree > Matcher < T > inLoop ( ) { return new Matcher < T > ( ) { @ Override public boolean matches ( Tree tree , VisitorState state ) { TreePath path = state . getPath ( ) . getParentPath ( ) ; Tree node = path . getLeaf ( ) ; while ( path != null ) { switch ( node . getKind ( ) ) { case METHOD : case CLASS : return false ; case WHILE_LOOP : case FOR_LOOP : case ENHANCED_FOR_LOOP : case DO_WHILE_LOOP : return true ; default : path = path . getParentPath ( ) ; node = path . getLeaf ( ) ; break ; } } return false ; } } ; }
--------------------------------------------------
static boolean enclosingLoop ( TreePath path , ExpressionTree collection ) { for ( Tree node : path ) { switch ( node . getKind ( ) ) { case METHOD : case CLASS : case LAMBDA_EXPRESSION : return false ; case ENHANCED_FOR_LOOP : if ( sameVariable ( collection , ( ( EnhancedForLoopTree ) node ) . getExpression ( ) ) ) { return true ; } break ; default : } } return false ; }
--------------------------------------------------
private BeanNameGenerator resolveBeanNameGenerator ( BeanDefinitionRegistry registry ) { BeanNameGenerator beanNameGenerator = null ; if ( registry instanceof SingletonBeanRegistry ) { SingletonBeanRegistry singletonBeanRegistry = SingletonBeanRegistry . class . cast ( registry ) ; beanNameGenerator = ( BeanNameGenerator ) singletonBeanRegistry . getSingleton ( CONFIGURATION_BEAN_NAME_GENERATOR ) ; } if ( beanNameGenerator == null ) { if ( logger . isInfoEnabled ( ) ) { logger . info ( 'beannamegenerator bean can't be found in beanfactory with name [' + CONFIGURATION_BEAN_NAME_GENERATOR + ']' ) ; logger . info ( 'beannamegenerator will be a instance of ' + AnnotationBeanNameGenerator . class . getName ( ) + ' , it maybe a potential problem on bean name generation.' ) ; } beanNameGenerator = new AnnotationBeanNameGenerator ( ) ; } return beanNameGenerator ; }
--------------------------------------------------
private BeanNameGenerator resolveBeanNameGenerator ( BeanDefinitionRegistry registry ) { BeanNameGenerator beanNameGenerator = null ; if ( registry instanceof SingletonBeanRegistry ) { SingletonBeanRegistry singletonBeanRegistry = SingletonBeanRegistry . class . cast ( registry ) ; beanNameGenerator = ( BeanNameGenerator ) singletonBeanRegistry . getSingleton ( CONFIGURATION_BEAN_NAME_GENERATOR ) ; } if ( beanNameGenerator == null ) { if ( logger . isInfoEnabled ( ) ) { logger . info ( 'beannamegenerator bean can't be found in beanfactory with name [' + CONFIGURATION_BEAN_NAME_GENERATOR + ']' ) ; logger . info ( 'beannamegenerator will be a instance of ' + AnnotationBeanNameGenerator . class . getName ( ) + ' , it maybe a potential problem on bean name generation.' ) ; } beanNameGenerator = new AnnotationBeanNameGenerator ( ) ; } return beanNameGenerator ; }
--------------------------------------------------
private List < Invoker < T >> selectMockInvoker ( Invocation invocation ) { List < Invoker < T >> invokers = null ; if ( invocation instanceof RpcInvocation ) { ( ( RpcInvocation ) invocation ) . setAttachment ( Constants . INVOCATION_NEED_MOCK , Boolean . TRUE . toString ( ) ) ; try { invokers = directory . list ( invocation ) ; } catch ( RpcException e ) { if ( logger . isInfoEnabled ( ) ) { logger . info ( 'exception when try to invoke mock. get mock invokers error for service:' + directory . getUrl ( ) . getServiceInterface ( ) + ', method:' + invocation . getMethodName ( ) + ', will contruct a new mock with 'new mockinvoker()'.' , e ) ; } } } return invokers ; }
--------------------------------------------------
public static Object compatibleTypeConvert ( Object value , Class < ? > type ) { if ( value == null || type == null || type . isAssignableFrom ( value . getClass ( ) ) ) { return value ; } if ( value instanceof String ) { String string = ( String ) value ; if ( char . class . equals ( type ) || Character . class . equals ( type ) ) { if ( string . length ( ) != 1 ) { throw new IllegalArgumentException ( String . format ( 'can not convert string(%s) to char!' '+' ' when convert string to char, the string must only 1 char.' , string ) ) ; } return string . charAt ( 0 ) ; } else if ( type . isEnum ( ) ) { return Enum . valueOf ( ( Class < Enum > ) type , string ) ; } else if ( type == BigInteger . class ) { return new BigInteger ( string ) ; } else if ( type == BigDecimal . class ) { return new BigDecimal ( string ) ; } else if ( type == Short . class || type == short . class ) { return new Short ( string ) ; } else if ( type == Integer . class || type == int . class ) { return new Integer ( string ) ; } else if ( type == Long . class || type == long . class ) { return new Long ( string ) ; } else if ( type == Double . class || type == double . class ) { return new Double ( string ) ; } else if ( type == Float . class || type == float . class ) { return new Float ( string ) ; } else if ( type == Byte . class || type == byte . class ) { return new Byte ( string ) ; } else if ( type == Boolean . class || type == boolean . class ) { return new Boolean ( string ) ; } else if ( type == Date . class || type == java . sql . Date . class || type == java . sql . Timestamp . class || type == java . sql . Time . class ) { try { Date date = new SimpleDateFormat ( DATE_FORMAT ) . parse ( ( String ) value ) ; if ( type == java . sql . Date . class ) { return new java . sql . Date ( date . getTime ( ) ) ; } else if ( type == java . sql . Timestamp . class ) { return new java . sql . Timestamp ( date . getTime ( ) ) ; } else if ( type == java . sql . Time . class ) { return new java . sql . Time ( date . getTime ( ) ) ; } else { return date ; } } catch ( ParseException e ) { throw new IllegalStateException ( 'failed to parse date ' + value + ' by format ' + DATE_FORMAT + ', cause: ' + e . getMessage ( ) , e ) ; } } else if ( type == Class . class ) { try { return ReflectUtils . name2class ( ( String ) value ) ; } catch ( ClassNotFoundException e ) { throw new RuntimeException ( e . getMessage ( ) , e ) ; } } else if ( char [ ] . class . equals ( type ) ) { int len = string . length ( ) ; char [ ] chars = new char [ len ] ; string . getChars ( 0 , len , chars , 0 ) ; return chars ; } } else if ( value instanceof Number ) { Number number = ( Number ) value ; if ( type == byte . class || type == Byte . class ) { return number . byteValue ( ) ; } else if ( type == short . class || type == Short . class ) { return number . shortValue ( ) ; } else if ( type == int . class || type == Integer . class ) { return number . intValue ( ) ; } else if ( type == long . class || type == Long . class ) { return number . longValue ( ) ; } else if ( type == float . class || type == Float . class ) { return number . floatValue ( ) ; } else if ( type == double . class || type == Double . class ) { return number . doubleValue ( ) ; } else if ( type == BigInteger . class ) { return BigInteger . valueOf ( number . longValue ( ) ) ; } else if ( type == BigDecimal . class ) { return BigDecimal . valueOf ( number . doubleValue ( ) ) ; } else if ( type == Date . class ) { return new Date ( number . longValue ( ) ) ; } } else if ( value instanceof Collection ) { Collection collection = ( Collection ) value ; if ( type . isArray ( ) ) { int length = collection . size ( ) ; Object array = Array . newInstance ( type . getComponentType ( ) , length ) ; int i = 0 ; for ( Object item : collection ) { Array . set ( array , i ++ , item ) ; } return array ; } else if ( ! type . isInterface ( ) ) { try { Collection result = ( Collection ) type . newInstance ( ) ; result . addAll ( collection ) ; return result ; } catch ( Throwable e ) { } } else if ( type == List . class ) { return new ArrayList < Object > ( collection ) ; } else if ( type == Set . class ) { return new HashSet < Object > ( collection ) ; } } else if ( value . getClass ( ) . isArray ( ) && Collection . class . isAssignableFrom ( type ) ) { Collection collection ; if ( ! type . isInterface ( ) ) { try { collection = ( Collection ) type . newInstance ( ) ; } catch ( Throwable e ) { collection = new ArrayList < Object > ( ) ; } } else if ( type == Set . class ) { collection = new HashSet < Object > ( ) ; } else { collection = new ArrayList < Object > ( ) ; } int length = Array . getLength ( value ) ; for ( int i = 0 ; i < length ; i ++ ) { collection . add ( Array . get ( value , i ) ) ; } return collection ; } return value ; }
--------------------------------------------------
private static ValidationResult validateFormatStringVariable ( ExpressionTree formatStringTree , final Symbol formatStringSymbol , final List < ? extends ExpressionTree > args , final VisitorState state ) { if ( formatStringSymbol . getKind ( ) != ElementKind . LOCAL_VARIABLE ) { return ValidationResult . create ( null , String . format ( 'variables used as format strings that are not local variables must be compile time' '+' ' constants.%s is neither a local variable nor a compile time constant.' , formatStringTree ) ) ; } Symbol owner = formatStringSymbol . owner ; TreePath path = TreePath . getPath ( state . getPath ( ) , formatStringTree ) ; while ( path != null && ASTHelpers . getSymbol ( path . getLeaf ( ) ) != owner ) { path = path . getParentPath ( ) ; } if ( path == null ) { throw new IllegalStateException ( String . format ( 'could not find the tree where local variable %s is declared. ' '+' 'this should be impossible.' , formatStringTree ) ) ; } ValidationResult result = path . getLeaf ( ) . accept ( new TreeScanner < ValidationResult , Void > ( ) { @ Override public ValidationResult visitVariable ( VariableTree node , Void unused ) { if ( ASTHelpers . getSymbol ( node ) == formatStringSymbol ) { if ( node . getInitializer ( ) == null ) { return ValidationResult . create ( null , String . format ( 'variables used as format strings must be initialized when they are' '+' ' declared.invalid declaration: %s' , node ) ) ; } return validateStringFromAssignment ( node , node . getInitializer ( ) , args , state ) ; } return super . visitVariable ( node , unused ) ; } @ Override public ValidationResult reduce ( ValidationResult r1 , ValidationResult r2 ) { if ( r1 == null && r2 == null ) { return null ; } return MoreObjects . firstNonNull ( r1 , r2 ) ; } } , null ) ; return result ; }
--------------------------------------------------
