public Iterator < Attribute > iterator ( ) { return new Iterator < Attribute > ( ) { int i = 0 ; @ Override public boolean hasNext ( ) { return i < size ; } @ Override public Attribute next ( ) { final Attribute attr = new Attribute ( keys [ i ] , vals [ i ] , Attributes . this ) ; i ++ ; return attr ; } @ Override public void remove ( ) { Attributes . this . remove ( -- i ) ; } } ; }
--------------------------------------------------
public Iterator < Map . Entry < String , String >> iterator ( ) { return new DatasetIterator ( ) ; }
--------------------------------------------------
void emit ( Token token ) { Validate . isFalse ( isEmitPending , "there is an unread token pending!" ) ; emitPending = token ; isEmitPending = true ; if ( token . type == Token . TokenType . StartTag ) { Token . StartTag startTag = ( Token . StartTag ) token ; lastStartTag = startTag . tagName ; } else if ( token . type == Token . TokenType . EndTag ) { Token . EndTag endTag = ( Token . EndTag ) token ; if ( endTag . attributes != null ) error ( "attributes incorrectly present on end tag" ) ; } }
--------------------------------------------------
public Elements attr ( String attributeKey , String attributeValue ) { for ( Element element : this ) { element . attr ( attributeKey , attributeValue ) ; } return this ; }
--------------------------------------------------
public Element attr ( String attributeKey , String attributeValue ) { super . attr ( attributeKey , attributeValue ) ; return this ; }
--------------------------------------------------
CharsetEncoder prepareEncoder ( ) { CharsetEncoder encoder = charset . newEncoder ( ) ; encoderThreadLocal . set ( encoder ) ; coreCharset = Entities . CoreCharset . byName ( encoder . charset ( ) . name ( ) ) ; return encoder ; }
--------------------------------------------------
public Node attr ( String attributeKey , String attributeValue ) { attributeKey = NodeUtils . parser ( this ) . settings ( ) . normalizeAttribute ( attributeKey ) ; attributes ( ) . putIgnoreCase ( attributeKey , attributeValue ) ; return this ; }
--------------------------------------------------
int codepointForName ( final String name ) { int index = Arrays . binarySearch ( nameKeys , name ) ; return index >= 0 ? codeVals [ index ] : empty ; }
--------------------------------------------------
public XmlDeclaration ( String name , boolean isProcessingInstruction ) { Validate . notNull ( name ) ; value = name ; this . isProcessingInstruction = isProcessingInstruction ; }
--------------------------------------------------
FormElement insertForm ( Token . StartTag startTag , boolean onStack ) { Tag tag = Tag . valueOf ( startTag . name ( ) , settings ) ; FormElement el = new FormElement ( tag , baseUri , startTag . attributes ) ; setFormElement ( el ) ; insertNode ( el ) ; if ( onStack ) stack . add ( el ) ; return el ; }
--------------------------------------------------
