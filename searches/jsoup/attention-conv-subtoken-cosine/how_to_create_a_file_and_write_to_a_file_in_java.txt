public void charset ( Charset charset ) { updateMetaCharsetElement ( true ) ; outputSettings . charset ( charset ) ; ensureMetaCharsetElement ( ) ; }
--------------------------------------------------
private static void writePost ( final Connection . Request req , final OutputStream outputStream , final String bound ) throws IOException { final Collection < Connection . KeyVal > data = req . data ( ) ; final BufferedWriter w = new BufferedWriter ( new OutputStreamWriter ( outputStream , req . postDataCharset ( ) ) ) ; if ( bound != null ) { for ( Connection . KeyVal keyVal : data ) { w . write ( "--" ) ; w . write ( bound ) ; w . write ( "
" ) ; w . write ( "content-disposition: form-data; name="" ) ; w . write ( encodeMimeName ( keyVal . key ( ) ) ) ; w . write ( """ ) ; if ( keyVal . hasInputStream ( ) ) { w . write ( "; filename="" ) ; w . write ( encodeMimeName ( keyVal . value ( ) ) ) ; w . write ( ""
content-type: " ) ; w . write ( keyVal . contentType ( ) != null ? keyVal . contentType ( ) : DefaultUploadType ) ; w . write ( "

" ) ; w . flush ( ) ; DataUtil . crossStreams ( keyVal . inputStream ( ) , outputStream ) ; outputStream . flush ( ) ; } else { w . write ( "

" ) ; w . write ( keyVal . value ( ) ) ; } w . write ( "
" ) ; } w . write ( "--" ) ; w . write ( bound ) ; w . write ( "--" ) ; } else if ( req . requestBody ( ) != null ) { w . write ( req . requestBody ( ) ) ; } else { boolean first = true ; for ( Connection . KeyVal keyVal : data ) { if ( ! first ) w . append ( '&' ) ; else first = false ; w . write ( URLEncoder . encode ( keyVal . key ( ) , req . postDataCharset ( ) ) ) ; w . write ( '=' ) ; w . write ( URLEncoder . encode ( keyVal . value ( ) , req . postDataCharset ( ) ) ) ; } } w . close ( ) ; }
--------------------------------------------------
public void clear ( ) { onContentsChanged ( ) ; super . clear ( ) ; }
--------------------------------------------------
private static String encodeUrl ( String url ) { try { URL u = new URL ( url ) ; return encodeUrl ( u ) . toExternalForm ( ) ; } catch ( Exception e ) { return url ; } }
--------------------------------------------------
static String mimeBoundary ( ) { final StringBuilder mime = StringUtil . borrowBuilder ( ) ; final Random rand = new Random ( ) ; for ( int i = 0 ; i < boundaryLength ; i ++ ) { mime . append ( mimeBoundaryChars [ rand . nextInt ( mimeBoundaryChars . length ) ] ) ; } return StringUtil . releaseBuilder ( mime ) ; }
--------------------------------------------------
private ConstrainableInputStream ( InputStream in , int bufferSize , int maxSize ) { super ( in , bufferSize ) ; Validate . isTrue ( maxSize >= 0 ) ; this . maxSize = maxSize ; remaining = maxSize ; capped = maxSize != 0 ; startTime = System . nanoTime ( ) ; }
--------------------------------------------------
public boolean remove ( Object o ) { onContentsChanged ( ) ; return super . remove ( o ) ; }
--------------------------------------------------
protected void initialiseParse ( Reader input , String baseUri , Parser parser ) { super . initialiseParse ( input , baseUri , parser ) ; stack . add ( doc ) ; doc . outputSettings ( ) . syntax ( Document . OutputSettings . Syntax . xml ) ; }
--------------------------------------------------
public String absUrl ( String key ) { ensureAttributes ( ) ; return super . absUrl ( key ) ; }
--------------------------------------------------
public Attributes clone ( ) { Attributes clone ; try { clone = ( Attributes ) super . clone ( ) ; } catch ( CloneNotSupportedException e ) { throw new RuntimeException ( e ) ; } clone . size = size ; keys = copyOf ( keys , size ) ; vals = copyOf ( vals , size ) ; return clone ; }
--------------------------------------------------
