public String toString ( ) { return super . toString ( ) + ". mimetype=" + mimeType + ", url=" + url ; }
--------------------------------------------------
void mark ( ) { bufSplitPoint = 0 ; bufferUp ( ) ; bufMark = bufPos ; }
--------------------------------------------------
static void crossStreams ( final InputStream in , final OutputStream out ) throws IOException { final byte [ ] buffer = new byte [ bufferSize ] ; int len ; while ( ( len = in . read ( buffer ) ) != - 1 ) { out . write ( buffer , 0 , len ) ; } }
--------------------------------------------------
public String toString ( ) { return String . format ( ":containsown(%s)" , searchText ) ; }
--------------------------------------------------
public String toString ( ) { return String . format ( ":contains(%s)" , searchText ) ; }
--------------------------------------------------
public String toString ( ) { return String . format ( ":containsdata(%s)" , searchText ) ; }
--------------------------------------------------
public Document clean ( Document dirtyDocument ) { Validate . notNull ( dirtyDocument ) ; Document clean = Document . createShell ( dirtyDocument . baseUri ( ) ) ; if ( dirtyDocument . body ( ) != null ) copySafeNodes ( dirtyDocument . body ( ) , clean . body ( ) ) ; return clean ; }
--------------------------------------------------
public void clear ( ) { onContentsChanged ( ) ; super . clear ( ) ; }
--------------------------------------------------
public static List < Node > parseFragment ( String fragmentHtml , Element context , String baseUri ) { HtmlTreeBuilder treeBuilder = new HtmlTreeBuilder ( ) ; return treeBuilder . parseFragment ( fragmentHtml , context , baseUri , new Parser ( treeBuilder ) ) ; }
--------------------------------------------------
public String toString ( ) { return queue . substring ( pos ) ; }
--------------------------------------------------
