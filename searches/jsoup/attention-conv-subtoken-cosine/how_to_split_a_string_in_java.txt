void mark ( ) { bufSplitPoint = 0 ; bufferUp ( ) ; bufMark = bufPos ; }
--------------------------------------------------
public Element empty ( ) { childNodes . clear ( ) ; return this ; }
--------------------------------------------------
public String toString ( ) { return super . toString ( ) + ". mimetype=" + mimeType + ", url=" + url ; }
--------------------------------------------------
static void crossStreams ( final InputStream in , final OutputStream out ) throws IOException { final byte [ ] buffer = new byte [ bufferSize ] ; int len ; while ( ( len = in . read ( buffer ) ) != - 1 ) { out . write ( buffer , 0 , len ) ; } }
--------------------------------------------------
public void clear ( ) { onContentsChanged ( ) ; super . clear ( ) ; }
--------------------------------------------------
public Attributes clone ( ) { Attributes clone ; try { clone = ( Attributes ) super . clone ( ) ; } catch ( CloneNotSupportedException e ) { throw new RuntimeException ( e ) ; } clone . size = size ; keys = copyOf ( keys , size ) ; vals = copyOf ( vals , size ) ; return clone ; }
--------------------------------------------------
public Connection parser ( Parser parser ) { req . parser ( parser ) ; return this ; }
--------------------------------------------------
public String header ( String name ) { Validate . notNull ( name , "header name must not be null" ) ; List < String > vals = getHeadersCaseInsensitive ( name ) ; if ( vals . size ( ) > 0 ) { return StringUtil . join ( vals , ", " ) ; } return null ; }
--------------------------------------------------
public String toString ( ) { if ( a == 0 ) return String . format ( ":%s(%d)" , getPseudoClass ( ) , b ) ; if ( b == 0 ) return String . format ( ":%s(%dn)" , getPseudoClass ( ) , a ) ; return String . format ( ":%s(%dn%+d)" , getPseudoClass ( ) , a , b ) ; }
--------------------------------------------------
public String toString ( ) { return key + "=" + value ; }
--------------------------------------------------
