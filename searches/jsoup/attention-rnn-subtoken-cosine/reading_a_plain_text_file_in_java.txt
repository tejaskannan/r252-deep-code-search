protected static void html ( String key , String val , Appendable accum , Document . OutputSettings out ) throws IOException { accum . append ( key ) ; if ( ! shouldCollapseAttribute ( key , val , out ) ) { accum . append ( "="" ) ; Entities . escape ( accum , Attributes . checkNotNull ( val ) , out , true , false , false ) ; accum . append ( '"' ) ; } }
--------------------------------------------------
final void html ( final Appendable accum , final Document . OutputSettings out ) throws IOException { final int sz = size ; for ( int i = 0 ; i < sz ; i ++ ) { final String key = keys [ i ] ; final String val = vals [ i ] ; accum . append ( ' ' ) . append ( key ) ; if ( ! Attribute . shouldCollapseAttribute ( key , val , out ) ) { accum . append ( "="" ) ; Entities . escape ( accum , val == null ? EmptyString : val , out , true , false , false ) ; accum . append ( '"' ) ; } } }
--------------------------------------------------
protected int calculatePosition ( Element root , Element element ) { int pos = 0 ; Elements family = element . parent ( ) . children ( ) ; for ( Element el : family ) { if ( el . tag ( ) . equals ( element . tag ( ) ) ) pos ++ ; if ( el == element ) break ; } return pos ; }
--------------------------------------------------
public String html ( ) { StringBuilder sb = StringUtil . borrowBuilder ( ) ; try { html ( sb , ( new Document ( "" ) ) . outputSettings ( ) ) ; } catch ( IOException e ) { throw new SerializationException ( e ) ; } return StringUtil . releaseBuilder ( sb ) ; }
--------------------------------------------------
public String html ( ) { StringBuilder sb = StringUtil . borrowBuilder ( ) ; try { html ( sb , ( new Document ( "" ) ) . outputSettings ( ) ) ; } catch ( IOException exception ) { throw new SerializationException ( exception ) ; } return StringUtil . releaseBuilder ( sb ) ; }
--------------------------------------------------
private void ownText ( StringBuilder accum ) { for ( Node child : childNodes ) { if ( child instanceof TextNode ) { TextNode textNode = ( TextNode ) child ; appendNormalisedText ( accum , textNode ) ; } else if ( child instanceof Element ) { appendWhitespaceIfBr ( ( Element ) child , accum ) ; } } }
--------------------------------------------------
public < T extends Appendable > T html ( T appendable ) { final int size = childNodes . size ( ) ; for ( int i = 0 ; i < size ; i ++ ) childNodes . get ( i ) . outerHtml ( appendable ) ; return appendable ; }
--------------------------------------------------
protected int calculatePosition ( Element root , Element element ) { int pos = 0 ; Elements family = element . parent ( ) . children ( ) ; for ( int i = element . elementSiblingIndex ( ) ; i < family . size ( ) ; i ++ ) { if ( family . get ( i ) . tag ( ) . equals ( element . tag ( ) ) ) pos ++ ; } return pos ; }
--------------------------------------------------
private static void serialiseRequestUrl ( Connection . Request req ) throws IOException { URL in = req . url ( ) ; StringBuilder url = StringUtil . borrowBuilder ( ) ; boolean first = true ; url . append ( in . getProtocol ( ) ) . append ( "://" ) . append ( in . getAuthority ( ) ) . append ( in . getPath ( ) ) . append ( "?" ) ; if ( in . getQuery ( ) != null ) { url . append ( in . getQuery ( ) ) ; first = false ; } for ( Connection . KeyVal keyVal : req . data ( ) ) { Validate . isFalse ( keyVal . hasInputStream ( ) , "inputstream data not supported in url query string." ) ; if ( ! first ) url . append ( '&' ) ; else first = false ; url . append ( URLEncoder . encode ( keyVal . key ( ) , DataUtil . defaultCharset ) ) . append ( '=' ) . append ( URLEncoder . encode ( keyVal . value ( ) , DataUtil . defaultCharset ) ) ; } req . url ( new URL ( StringUtil . releaseBuilder ( url ) ) ) ; req . data ( ) . clear ( ) ; }
--------------------------------------------------
public < T extends Appendable > T html ( T appendable ) { outerHtml ( appendable ) ; return appendable ; }
--------------------------------------------------
