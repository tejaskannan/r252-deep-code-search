private static void serialiseRequestUrl ( Connection . Request req ) throws IOException { URL in = req . url ( ) ; StringBuilder url = StringUtil . borrowBuilder ( ) ; boolean first = true ; url . append ( in . getProtocol ( ) ) . append ( "://" ) . append ( in . getAuthority ( ) ) . append ( in . getPath ( ) ) . append ( "?" ) ; if ( in . getQuery ( ) != null ) { url . append ( in . getQuery ( ) ) ; first = false ; } for ( Connection . KeyVal keyVal : req . data ( ) ) { Validate . isFalse ( keyVal . hasInputStream ( ) , "inputstream data not supported in url query string." ) ; if ( ! first ) url . append ( '&' ) ; else first = false ; url . append ( URLEncoder . encode ( keyVal . key ( ) , DataUtil . defaultCharset ) ) . append ( '=' ) . append ( URLEncoder . encode ( keyVal . value ( ) , DataUtil . defaultCharset ) ) ; } req . url ( new URL ( StringUtil . releaseBuilder ( url ) ) ) ; req . data ( ) . clear ( ) ; }
--------------------------------------------------
public XmlDeclaration ( String name , boolean isProcessingInstruction ) { Validate . notNull ( name ) ; value = name ; this . isProcessingInstruction = isProcessingInstruction ; }
--------------------------------------------------
public static Whitelist simpleText ( ) { return new Whitelist ( ) . addTags ( "b" , "em" , "i" , "strong" , "u" ) ; }
--------------------------------------------------
public static Attribute createFromEncoded ( String unencodedKey , String encodedValue ) { String value = Entities . unescape ( encodedValue , true ) ; return new Attribute ( unencodedKey , value , null ) ; }
--------------------------------------------------
public T url ( URL url ) { Validate . notNull ( url , "url must not be null" ) ; this . url = url ; return ( T ) this ; }
--------------------------------------------------
protected void initialiseParse ( Reader input , String baseUri , Parser parser ) { super . initialiseParse ( input , baseUri , parser ) ; state = HtmlTreeBuilderState . Initial ; originalState = null ; baseUriSetFromDoc = false ; headElement = null ; formElement = null ; contextElement = null ; formattingElements = new ArrayList < > ( ) ; pendingTableCharacters = new ArrayList < > ( ) ; emptyEnd = new Token . EndTag ( ) ; framesetOk = true ; fosterInserts = false ; fragmentParsing = false ; }
--------------------------------------------------
public Whitelist addTags ( String ... tags ) { Validate . notNull ( tags ) ; for ( String tagName : tags ) { Validate . notEmpty ( tagName ) ; tagNames . add ( TagName . valueOf ( tagName ) ) ; } return this ; }
--------------------------------------------------
static String mimeBoundary ( ) { final StringBuilder mime = StringUtil . borrowBuilder ( ) ; final Random rand = new Random ( ) ; for ( int i = 0 ; i < boundaryLength ; i ++ ) { mime . append ( mimeBoundaryChars [ rand . nextInt ( mimeBoundaryChars . length ) ] ) ; } return StringUtil . releaseBuilder ( mime ) ; }
--------------------------------------------------
public String text ( ) { StringBuilder sb = StringUtil . borrowBuilder ( ) ; for ( Element element : this ) { if ( sb . length ( ) != 0 ) sb . append ( " " ) ; sb . append ( element . text ( ) ) ; } return StringUtil . releaseBuilder ( sb ) ; }
--------------------------------------------------
public Element appendElement ( String tagName ) { Element child = new Element ( Tag . valueOf ( tagName , NodeUtils . parser ( this ) . settings ( ) ) , baseUri ( ) ) ; appendChild ( child ) ; return child ; }
--------------------------------------------------
