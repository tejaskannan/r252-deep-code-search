void insertInFosterParent ( Node in ) { Element fosterParent ; Element lastTable = getFromStack ( "table" ) ; boolean isLastTableParent = false ; if ( lastTable != null ) { if ( lastTable . parent ( ) != null ) { fosterParent = lastTable . parent ( ) ; isLastTableParent = true ; } else fosterParent = aboveOnStack ( lastTable ) ; } else { fosterParent = stack . get ( 0 ) ; } if ( isLastTableParent ) { Validate . notNull ( lastTable ) ; lastTable . before ( in ) ; } else fosterParent . appendChild ( in ) ; }
--------------------------------------------------
private void checkCapacity ( int minNewSize ) { Validate . isTrue ( minNewSize >= size ) ; int curSize = keys . length ; if ( curSize >= minNewSize ) return ; int newSize = curSize >= InitialCapacity ? size * GrowthFactor : InitialCapacity ; if ( minNewSize > newSize ) newSize = minNewSize ; keys = copyOf ( keys , newSize ) ; vals = copyOf ( vals , newSize ) ; }
--------------------------------------------------
FormElement insertForm ( Token . StartTag startTag , boolean onStack ) { Tag tag = Tag . valueOf ( startTag . name ( ) , settings ) ; FormElement el = new FormElement ( tag , baseUri , startTag . attributes ) ; setFormElement ( el ) ; insertNode ( el ) ; if ( onStack ) stack . add ( el ) ; return el ; }
--------------------------------------------------
boolean inSelectScope ( String targetName ) { for ( int pos = stack . size ( ) - 1 ; pos >= 0 ; pos -- ) { Element el = stack . get ( pos ) ; String elName = el . normalName ( ) ; if ( elName . equals ( targetName ) ) return true ; if ( ! inSorted ( elName , TagSearchSelectScope ) ) return false ; } Validate . fail ( "should not be reachable" ) ; return false ; }
--------------------------------------------------
Element insertStartTag ( String startTagName ) { Element el = new Element ( Tag . valueOf ( startTagName , settings ) , baseUri ) ; insert ( el ) ; return el ; }
--------------------------------------------------
void resetInsertionMode ( ) { boolean last = false ; for ( int pos = stack . size ( ) - 1 ; pos >= 0 ; pos -- ) { Element node = stack . get ( pos ) ; if ( pos == 0 ) { last = true ; node = contextElement ; } String name = node . normalName ( ) ; if ( "select" . equals ( name ) ) { transition ( HtmlTreeBuilderState . InSelect ) ; break ; } else if ( ( "td" . equals ( name ) || "th" . equals ( name ) && ! last ) ) { transition ( HtmlTreeBuilderState . InCell ) ; break ; } else if ( "tr" . equals ( name ) ) { transition ( HtmlTreeBuilderState . InRow ) ; break ; } else if ( "tbody" . equals ( name ) || "thead" . equals ( name ) || "tfoot" . equals ( name ) ) { transition ( HtmlTreeBuilderState . InTableBody ) ; break ; } else if ( "caption" . equals ( name ) ) { transition ( HtmlTreeBuilderState . InCaption ) ; break ; } else if ( "colgroup" . equals ( name ) ) { transition ( HtmlTreeBuilderState . InColumnGroup ) ; break ; } else if ( "table" . equals ( name ) ) { transition ( HtmlTreeBuilderState . InTable ) ; break ; } else if ( "head" . equals ( name ) ) { transition ( HtmlTreeBuilderState . InBody ) ; break ; } else if ( "body" . equals ( name ) ) { transition ( HtmlTreeBuilderState . InBody ) ; break ; } else if ( "frameset" . equals ( name ) ) { transition ( HtmlTreeBuilderState . InFrameset ) ; break ; } else if ( "html" . equals ( name ) ) { transition ( HtmlTreeBuilderState . BeforeHead ) ; break ; } else if ( last ) { transition ( HtmlTreeBuilderState . InBody ) ; break ; } } }
--------------------------------------------------
public Element prependElement ( String tagName ) { Element child = new Element ( Tag . valueOf ( tagName , NodeUtils . parser ( this ) . settings ( ) ) , baseUri ( ) ) ; prependChild ( child ) ; return child ; }
--------------------------------------------------
public Document normalise ( ) { Element htmlEl = findFirstElementByTagName ( "html" , this ) ; if ( htmlEl == null ) htmlEl = appendElement ( "html" ) ; if ( head ( ) == null ) htmlEl . prependElement ( "head" ) ; if ( body ( ) == null ) htmlEl . appendElement ( "body" ) ; normaliseTextNodes ( head ( ) ) ; normaliseTextNodes ( htmlEl ) ; normaliseTextNodes ( this ) ; normaliseStructure ( "head" , htmlEl ) ; normaliseStructure ( "body" , htmlEl ) ; ensureMetaCharsetElement ( ) ; return this ; }
--------------------------------------------------
public static Whitelist simpleText ( ) { return new Whitelist ( ) . addTags ( "b" , "em" , "i" , "strong" , "u" ) ; }
--------------------------------------------------
public Connection . Response bufferUp ( ) { prepareByteData ( ) ; return this ; }
--------------------------------------------------
