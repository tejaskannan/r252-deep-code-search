Element getFromStack ( String elName ) { for ( int pos = stack . size ( ) - 1 ; pos >= 0 ; pos -- ) { Element next = stack . get ( pos ) ; if ( next . normalName ( ) . equals ( elName ) ) { return next ; } } return null ; }
--------------------------------------------------
public Connection cookies ( Map < String , String > cookies ) { Validate . notNull ( cookies , "cookie map must not be null" ) ; for ( Map . Entry < String , String > entry : cookies . entrySet ( ) ) { req . cookie ( entry . getKey ( ) , entry . getValue ( ) ) ; } return this ; }
--------------------------------------------------
private void clearStackToContext ( String ... nodeNames ) { for ( int pos = stack . size ( ) - 1 ; pos >= 0 ; pos -- ) { Element next = stack . get ( pos ) ; if ( StringUtil . in ( next . normalName ( ) , nodeNames ) || next . normalName ( ) . equals ( "html" ) ) break ; else stack . remove ( pos ) ; } }
--------------------------------------------------
FormElement insertForm ( Token . StartTag startTag , boolean onStack ) { Tag tag = Tag . valueOf ( startTag . name ( ) , settings ) ; FormElement el = new FormElement ( tag , baseUri , startTag . attributes ) ; setFormElement ( el ) ; insertNode ( el ) ; if ( onStack ) stack . add ( el ) ; return el ; }
--------------------------------------------------
@ Override Tag reset ( ) { tagName = null ; normalName = null ; pendingAttributeName = null ; reset ( pendingAttributeValue ) ; pendingAttributeValueS = null ; hasEmptyAttributeValue = false ; hasPendingAttributeValue = false ; selfClosing = false ; attributes = null ; return this ; }
--------------------------------------------------
Element insertStartTag ( String startTagName ) { Element el = new Element ( Tag . valueOf ( startTagName , settings ) , baseUri ) ; insert ( el ) ; return el ; }
--------------------------------------------------
private void getWholeDeclaration ( Appendable accum , Document . OutputSettings out ) throws IOException { for ( Attribute attribute : attributes ( ) ) { if ( ! attribute . getKey ( ) . equals ( nodeName ( ) ) ) { accum . append ( ' ' ) ; attribute . html ( accum , out ) ; } } }
--------------------------------------------------
public List < Attribute > asList ( ) { ArrayList < Attribute > list = new ArrayList < > ( size ) ; for ( int i = 0 ; i < size ; i ++ ) { Attribute attr = vals [ i ] == null ? new BooleanAttribute ( keys [ i ] ) : new Attribute ( keys [ i ] , vals [ i ] , Attributes . this ) ; list . add ( attr ) ; } return Collections . unmodifiableList ( list ) ; }
--------------------------------------------------
void reconstructFormattingElements ( ) { Element last = lastFormattingElement ( ) ; if ( last == null || onStack ( last ) ) return ; Element entry = last ; int size = formattingElements . size ( ) ; int pos = size - 1 ; boolean skip = false ; while ( true ) { if ( pos == 0 ) { skip = true ; break ; } entry = formattingElements . get ( -- pos ) ; if ( entry == null || onStack ( entry ) ) break ; } while ( true ) { if ( ! skip ) entry = formattingElements . get ( ++ pos ) ; Validate . notNull ( entry ) ; skip = false ; Element newEl = insertStartTag ( entry . normalName ( ) ) ; newEl . attributes ( ) . addAll ( entry . attributes ( ) ) ; formattingElements . set ( pos , newEl ) ; if ( pos == size - 1 ) break ; } }
--------------------------------------------------
private List < String > getHeadersCaseInsensitive ( String name ) { Validate . notNull ( name ) ; for ( Map . Entry < String , List < String >> entry : headers . entrySet ( ) ) { if ( name . equalsIgnoreCase ( entry . getKey ( ) ) ) return entry . getValue ( ) ; } return Collections . emptyList ( ) ; }
--------------------------------------------------
