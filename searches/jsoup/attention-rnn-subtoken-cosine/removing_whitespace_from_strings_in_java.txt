public Connection submit ( ) { String action = hasAttr ( "action" ) ? absUrl ( "action" ) : baseUri ( ) ; Validate . notEmpty ( action , "could not determine a form action url for submit. ensure you set a base uri when parsing." ) ; Connection . Method method = attr ( "method" ) . toUpperCase ( ) . equals ( "post" ) ? Connection . Method . POST : Connection . Method . GET ; return Jsoup . connect ( action ) . data ( formData ( ) ) . method ( method ) ; }
--------------------------------------------------
void read ( Tokeniser t , CharacterReader r ) { char c = r . consume ( ) ; switch ( c ) { case '>' : t . emitDoctypePending ( ) ; t . transition ( Data ) ; break ; case eof : t . emitDoctypePending ( ) ; t . transition ( Data ) ; break ; default : break ; } }
--------------------------------------------------
private static void readCharRef ( Tokeniser t , TokeniserState advance ) { int [ ] c = t . consumeCharacterReference ( null , false ) ; if ( c == null ) t . emit ( '&' ) ; else t . emit ( c ) ; t . transition ( advance ) ; }
--------------------------------------------------
void read ( Tokeniser t , CharacterReader r ) { switch ( r . consume ( ) ) { case '/' : t . createTempBuffer ( ) ; t . transition ( ScriptDataEndTagOpen ) ; break ; case '!' : t . emit ( "<!" ) ; t . transition ( ScriptDataEscapeStart ) ; break ; default : t . emit ( "<" ) ; r . unconsume ( ) ; t . transition ( ScriptData ) ; } }
--------------------------------------------------
void read ( Tokeniser t , CharacterReader r ) { switch ( r . current ( ) ) { case '&' : t . advanceTransition ( CharacterReferenceInData ) ; break ; case '<' : t . advanceTransition ( TagOpen ) ; break ; case nullChar : t . error ( this ) ; t . emit ( r . consume ( ) ) ; break ; case eof : t . emit ( new Token . EOF ( ) ) ; break ; default : String data = r . consumeData ( ) ; t . emit ( data ) ; break ; } }
--------------------------------------------------
void read ( Tokeniser t , CharacterReader r ) { String name = r . consumeToAnySorted ( attributeNameCharsSorted ) ; t . tagPending . appendAttributeName ( name ) ; char c = r . consume ( ) ; switch ( c ) { case '\t' : case '\n' : case '\r' : case '\f' : case ' ' : t . transition ( AfterAttributeName ) ; break ; case '/' : t . transition ( SelfClosingStartTag ) ; break ; case '=' : t . transition ( BeforeAttributeValue ) ; break ; case '>' : t . emitTagPending ( ) ; t . transition ( Data ) ; break ; case nullChar : t . error ( this ) ; t . tagPending . appendAttributeName ( replacementChar ) ; break ; case eof : t . eofError ( this ) ; t . transition ( Data ) ; break ; case '"' : case ''' : case '<' : t . error ( this ) ; t . tagPending . appendAttributeName ( c ) ; break ; default : t . tagPending . appendAttributeName ( c ) ; } }
--------------------------------------------------
void read ( Tokeniser t , CharacterReader r ) { String value = r . consumeToAny ( attributeDoubleValueCharsSorted ) ; if ( value . length ( ) > 0 ) t . tagPending . appendAttributeValue ( value ) ; else t . tagPending . setEmptyAttributeValue ( ) ; char c = r . consume ( ) ; switch ( c ) { case '"' : t . transition ( AfterAttributeValue_quoted ) ; break ; case '&' : int [ ] ref = t . consumeCharacterReference ( '"' , true ) ; if ( ref != null ) t . tagPending . appendAttributeValue ( ref ) ; else t . tagPending . appendAttributeValue ( '&' ) ; break ; case nullChar : t . error ( this ) ; t . tagPending . appendAttributeValue ( replacementChar ) ; break ; case eof : t . eofError ( this ) ; t . transition ( Data ) ; break ; default : t . tagPending . appendAttributeValue ( c ) ; } }
--------------------------------------------------
void read ( Tokeniser t , CharacterReader r ) { String tagName = r . consumeTagName ( ) ; t . tagPending . appendTagName ( tagName ) ; char c = r . consume ( ) ; switch ( c ) { case '\t' : case '\n' : case '\r' : case '\f' : case ' ' : t . transition ( BeforeAttributeName ) ; break ; case '/' : t . transition ( SelfClosingStartTag ) ; break ; case '<' : t . error ( this ) ; r . unconsume ( ) ; case '>' : t . emitTagPending ( ) ; t . transition ( Data ) ; break ; case nullChar : t . tagPending . appendTagName ( replacementStr ) ; break ; case eof : t . eofError ( this ) ; t . transition ( Data ) ; break ; default : t . tagPending . appendTagName ( c ) ; } }
--------------------------------------------------
void read ( Tokeniser t , CharacterReader r ) { String value = r . consumeToAny ( attributeSingleValueCharsSorted ) ; if ( value . length ( ) > 0 ) t . tagPending . appendAttributeValue ( value ) ; else t . tagPending . setEmptyAttributeValue ( ) ; char c = r . consume ( ) ; switch ( c ) { case ''' : t . transition ( AfterAttributeValue_quoted ) ; break ; case '&' : int [ ] ref = t . consumeCharacterReference ( ''' , true ) ; if ( ref != null ) t . tagPending . appendAttributeValue ( ref ) ; else t . tagPending . appendAttributeValue ( '&' ) ; break ; case nullChar : t . error ( this ) ; t . tagPending . appendAttributeValue ( replacementChar ) ; break ; case eof : t . eofError ( this ) ; t . transition ( Data ) ; break ; default : t . tagPending . appendAttributeValue ( c ) ; } }
--------------------------------------------------
protected void removeRange ( int fromIndex , int toIndex ) { onContentsChanged ( ) ; super . removeRange ( fromIndex , toIndex ) ; }
--------------------------------------------------
