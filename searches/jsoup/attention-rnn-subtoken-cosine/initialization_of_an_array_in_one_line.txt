public List < TextNode > textNodes ( ) { List < TextNode > textNodes = new ArrayList < > ( ) ; for ( Node node : childNodes ) { if ( node instanceof TextNode ) textNodes . add ( ( TextNode ) node ) ; } return Collections . unmodifiableList ( textNodes ) ; }
--------------------------------------------------
public List < String > eachText ( ) { ArrayList < String > texts = new ArrayList < > ( size ( ) ) ; for ( Element el : this ) { if ( el . hasText ( ) ) texts . add ( el . text ( ) ) ; } return texts ; }
--------------------------------------------------
public String data ( ) { StringBuilder sb = StringUtil . borrowBuilder ( ) ; for ( Node childNode : childNodes ) { if ( childNode instanceof DataNode ) { DataNode data = ( DataNode ) childNode ; sb . append ( data . getWholeData ( ) ) ; } else if ( childNode instanceof Comment ) { Comment comment = ( Comment ) childNode ; sb . append ( comment . getData ( ) ) ; } else if ( childNode instanceof Element ) { Element element = ( Element ) childNode ; String elementData = element . data ( ) ; sb . append ( elementData ) ; } else if ( childNode instanceof CDataNode ) { CDataNode cDataNode = ( CDataNode ) childNode ; sb . append ( cDataNode . getWholeText ( ) ) ; } } return StringUtil . releaseBuilder ( sb ) ; }
--------------------------------------------------
FormElement insertForm ( Token . StartTag startTag , boolean onStack ) { Tag tag = Tag . valueOf ( startTag . name ( ) , settings ) ; FormElement el = new FormElement ( tag , baseUri , startTag . attributes ) ; setFormElement ( el ) ; insertNode ( el ) ; if ( onStack ) stack . add ( el ) ; return el ; }
--------------------------------------------------
public String text ( ) { return getWholeText ( ) ; }
--------------------------------------------------
public Parser setTreeBuilder ( TreeBuilder treeBuilder ) { this . treeBuilder = treeBuilder ; treeBuilder . parser = this ; return this ; }
--------------------------------------------------
public String text ( ) { StringBuilder sb = StringUtil . borrowBuilder ( ) ; for ( Element element : this ) { if ( sb . length ( ) != 0 ) sb . append ( " " ) ; sb . append ( element . text ( ) ) ; } return StringUtil . releaseBuilder ( sb ) ; }
--------------------------------------------------
void outerHtmlHead ( Appendable accum , int depth , Document . OutputSettings out ) throws IOException { accum . append ( "<" ) . append ( isProcessingInstruction ? "!" : "?" ) . append ( coreValue ( ) ) ; getWholeDeclaration ( accum , out ) ; accum . append ( isProcessingInstruction ? "!" : "?" ) . append ( ">" ) ; }
--------------------------------------------------
public static Whitelist simpleText ( ) { return new Whitelist ( ) . addTags ( "b" , "em" , "i" , "strong" , "u" ) ; }
--------------------------------------------------
protected static void html ( String key , String val , Appendable accum , Document . OutputSettings out ) throws IOException { accum . append ( key ) ; if ( ! shouldCollapseAttribute ( key , val , out ) ) { accum . append ( "="" ) ; Entities . escape ( accum , Attributes . checkNotNull ( val ) , out , true , false , false ) ; accum . append ( '"' ) ; } }
--------------------------------------------------
