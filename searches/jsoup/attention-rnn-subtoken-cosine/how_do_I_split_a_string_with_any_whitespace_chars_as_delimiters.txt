public String text ( ) { StringBuilder sb = StringUtil . borrowBuilder ( ) ; for ( Element element : this ) { if ( sb . length ( ) != 0 ) sb . append ( " " ) ; sb . append ( element . text ( ) ) ; } return StringUtil . releaseBuilder ( sb ) ; }
--------------------------------------------------
public List < String > eachText ( ) { ArrayList < String > texts = new ArrayList < > ( size ( ) ) ; for ( Element el : this ) { if ( el . hasText ( ) ) texts . add ( el . text ( ) ) ; } return texts ; }
--------------------------------------------------
public String ownText ( ) { StringBuilder sb = StringUtil . borrowBuilder ( ) ; ownText ( sb ) ; return StringUtil . releaseBuilder ( sb ) . trim ( ) ; }
--------------------------------------------------
Element insertStartTag ( String startTagName ) { Element el = new Element ( Tag . valueOf ( startTagName , settings ) , baseUri ) ; insert ( el ) ; return el ; }
--------------------------------------------------
public Elements getElementsMatchingOwnText ( String regex ) { Pattern pattern ; try { pattern = Pattern . compile ( regex ) ; } catch ( PatternSyntaxException e ) { throw new IllegalArgumentException ( "pattern syntax error: " + regex , e ) ; } return getElementsMatchingOwnText ( pattern ) ; }
--------------------------------------------------
public XmlDeclaration ( String name , boolean isProcessingInstruction ) { Validate . notNull ( name ) ; value = name ; this . isProcessingInstruction = isProcessingInstruction ; }
--------------------------------------------------
public TextNode text ( String text ) { coreValue ( text ) ; return this ; }
--------------------------------------------------
public String outerHtml ( ) { StringBuilder sb = StringUtil . borrowBuilder ( ) ; for ( Element element : this ) { if ( sb . length ( ) != 0 ) sb . append ( "\n" ) ; sb . append ( element . outerHtml ( ) ) ; } return StringUtil . releaseBuilder ( sb ) ; }
--------------------------------------------------
static String mimeBoundary ( ) { final StringBuilder mime = StringUtil . borrowBuilder ( ) ; final Random rand = new Random ( ) ; for ( int i = 0 ; i < boundaryLength ; i ++ ) { mime . append ( mimeBoundaryChars [ rand . nextInt ( mimeBoundaryChars . length ) ] ) ; } return StringUtil . releaseBuilder ( mime ) ; }
--------------------------------------------------
void emit ( final String str ) { if ( charsString == null ) { charsString = str ; } else { if ( charsBuilder . length ( ) == 0 ) { charsBuilder . append ( charsString ) ; } charsBuilder . append ( str ) ; } }
--------------------------------------------------
