private void safeClose ( ) { if ( conn != null ) { conn . disconnect ( ) ; conn = null ; } if ( bodyStream != null ) { try { bodyStream . close ( ) ; } catch ( IOException e ) { } finally { bodyStream = null ; } } }
--------------------------------------------------
public Whitelist addProtocols ( String tag , String attribute , String ... protocols ) { Validate . notEmpty ( tag ) ; Validate . notEmpty ( attribute ) ; Validate . notNull ( protocols ) ; TagName tagName = TagName . valueOf ( tag ) ; AttributeKey attrKey = AttributeKey . valueOf ( attribute ) ; Map < AttributeKey , Set < Protocol >> attrMap ; Set < Protocol > protSet ; if ( this . protocols . containsKey ( tagName ) ) { attrMap = this . protocols . get ( tagName ) ; } else { attrMap = new HashMap < > ( ) ; this . protocols . put ( tagName , attrMap ) ; } if ( attrMap . containsKey ( attrKey ) ) { protSet = attrMap . get ( attrKey ) ; } else { protSet = new HashSet < > ( ) ; attrMap . put ( attrKey , protSet ) ; } for ( String protocol : protocols ) { Validate . notEmpty ( protocol ) ; Protocol prot = Protocol . valueOf ( protocol ) ; protSet . add ( prot ) ; } return this ; }
--------------------------------------------------
void insert ( Element el ) { insertNode ( el ) ; stack . add ( el ) ; }
--------------------------------------------------
void read ( Tokeniser t , CharacterReader r ) { if ( r . isEmpty ( ) ) { t . eofError ( this ) ; t . transition ( Data ) ; return ; } switch ( r . current ( ) ) { case '-' : t . emit ( '-' ) ; t . advanceTransition ( ScriptDataEscapedDash ) ; break ; case '<' : t . advanceTransition ( ScriptDataEscapedLessthanSign ) ; break ; case nullChar : t . error ( this ) ; r . advance ( ) ; t . emit ( replacementChar ) ; break ; default : String data = r . consumeToAny ( '-' , '<' , nullChar ) ; t . emit ( data ) ; } }
--------------------------------------------------
public Elements remove ( ) { for ( Element element : this ) { element . remove ( ) ; } return this ; }
--------------------------------------------------
void read ( Tokeniser t , CharacterReader r ) { char c = r . consume ( ) ; switch ( c ) { case '-' : t . emit ( c ) ; t . transition ( ScriptDataDoubleEscapedDashDash ) ; break ; case '<' : t . emit ( c ) ; t . transition ( ScriptDataDoubleEscapedLessthanSign ) ; break ; case nullChar : t . error ( this ) ; t . emit ( replacementChar ) ; t . transition ( ScriptDataDoubleEscaped ) ; break ; case eof : t . eofError ( this ) ; t . transition ( Data ) ; break ; default : t . emit ( c ) ; t . transition ( ScriptDataDoubleEscaped ) ; } }
--------------------------------------------------
void outerHtmlHead ( final Appendable accum , int depth , final Document . OutputSettings out ) throws IOException { if ( out . prettyPrint ( ) && ( tag . formatAsBlock ( ) || ( parent ( ) != null && parent ( ) . tag ( ) . formatAsBlock ( ) ) || out . outline ( ) ) ) { if ( accum instanceof StringBuilder ) { if ( ( ( StringBuilder ) accum ) . length ( ) > 0 ) indent ( accum , depth , out ) ; } else { indent ( accum , depth , out ) ; } } accum . append ( '<' ) . append ( tagName ( ) ) ; if ( attributes != null ) attributes . html ( accum , out ) ; if ( childNodes . isEmpty ( ) && tag . isSelfClosing ( ) ) { if ( out . syntax ( ) == Document . OutputSettings . Syntax . html && tag . isEmpty ( ) ) accum . append ( '>' ) ; else accum . append ( " />" ) ; } else accum . append ( '>' ) ; }
--------------------------------------------------
void read ( Tokeniser t , CharacterReader r ) { if ( r . matches ( '/' ) ) { t . emit ( '/' ) ; t . createTempBuffer ( ) ; t . advanceTransition ( ScriptDataDoubleEscapeEnd ) ; } else { t . transition ( ScriptDataDoubleEscaped ) ; } }
--------------------------------------------------
void read ( Tokeniser t , CharacterReader r ) { char c = r . consume ( ) ; switch ( c ) { case '\t' : case '\n' : case '\r' : case '\f' : case ' ' : break ; case '"' : t . transition ( DoctypePublicIdentifier_doubleQuoted ) ; break ; case ''' : t . transition ( DoctypePublicIdentifier_singleQuoted ) ; break ; case '>' : t . error ( this ) ; t . doctypePending . forceQuirks = true ; t . emitDoctypePending ( ) ; t . transition ( Data ) ; break ; case eof : t . eofError ( this ) ; t . doctypePending . forceQuirks = true ; t . emitDoctypePending ( ) ; t . transition ( Data ) ; break ; default : t . error ( this ) ; t . doctypePending . forceQuirks = true ; t . transition ( BogusDoctype ) ; } }
--------------------------------------------------
protected int calculatePosition ( Element root , Element element ) { int pos = 0 ; Elements family = element . parent ( ) . children ( ) ; for ( Element el : family ) { if ( el . tag ( ) . equals ( element . tag ( ) ) ) pos ++ ; if ( el == element ) break ; } return pos ; }
--------------------------------------------------
