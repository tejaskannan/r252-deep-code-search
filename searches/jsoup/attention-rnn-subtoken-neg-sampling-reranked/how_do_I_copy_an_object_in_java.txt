public ByteBuffer readToByteBuffer ( int max ) throws IOException { Validate . isTrue ( max >= 0 , "maxsize must be 0 (unlimited) or larger" ) ; final boolean localCapped = max > 0 ; final int bufferSize = localCapped && max < DefaultSize ? max : DefaultSize ; final byte [ ] readBuffer = new byte [ bufferSize ] ; final ByteArrayOutputStream outStream = new ByteArrayOutputStream ( bufferSize ) ; int read ; int remaining = max ; while ( true ) { read = read ( readBuffer ) ; if ( read == - 1 ) break ; if ( localCapped ) { if ( read >= remaining ) { outStream . write ( readBuffer , 0 , remaining ) ; break ; } remaining -= read ; } outStream . write ( readBuffer , 0 , read ) ; } return ByteBuffer . wrap ( outStream . toByteArray ( ) ) ; }
--------------------------------------------------
private void addSiblingHtml ( int index , String html ) { Validate . notNull ( html ) ; Validate . notNull ( parentNode ) ; Element context = parent ( ) instanceof Element ? ( Element ) parent ( ) : null ; List < Node > nodes = NodeUtils . parser ( this ) . parseFragmentInput ( html , context , baseUri ( ) ) ; parentNode . addChildren ( index , nodes . toArray ( new Node [ 0 ] ) ) ; }
--------------------------------------------------
Element insert ( Token . StartTag startTag ) { if ( startTag . isSelfClosing ( ) ) { Element el = insertEmpty ( startTag ) ; stack . add ( el ) ; tokeniser . transition ( TokeniserState . Data ) ; tokeniser . emit ( emptyEnd . reset ( ) . name ( el . tagName ( ) ) ) ; return el ; } Element el = new Element ( Tag . valueOf ( startTag . name ( ) , settings ) , baseUri , settings . normalizeAttributes ( startTag . attributes ) ) ; insert ( el ) ; return el ; }
--------------------------------------------------
public static void traverse ( NodeVisitor visitor , Node root ) { Node node = root ; int depth = 0 ; while ( node != null ) { visitor . head ( node , depth ) ; if ( node . childNodeSize ( ) > 0 ) { node = node . childNode ( 0 ) ; depth ++ ; } else { while ( node . nextSibling ( ) == null && depth > 0 ) { visitor . tail ( node , depth ) ; node = node . parentNode ( ) ; depth -- ; } visitor . tail ( node , depth ) ; if ( node == root ) break ; node = node . nextSibling ( ) ; } } }
--------------------------------------------------
void read ( Tokeniser t , CharacterReader r ) { char c = r . consume ( ) ; switch ( c ) { case '-' : t . transition ( CommentEnd ) ; break ; case nullChar : t . error ( this ) ; t . commentPending . data . append ( '-' ) . append ( replacementChar ) ; t . transition ( Comment ) ; break ; case eof : t . eofError ( this ) ; t . emitCommentPending ( ) ; t . transition ( Data ) ; break ; default : t . commentPending . data . append ( '-' ) . append ( c ) ; t . transition ( Comment ) ; } }
--------------------------------------------------
void read ( Tokeniser t , CharacterReader r ) { char c = r . consume ( ) ; switch ( c ) { case '-' : t . transition ( CommentStartDash ) ; break ; case nullChar : t . error ( this ) ; t . commentPending . data . append ( replacementChar ) ; t . transition ( Comment ) ; break ; case '>' : t . error ( this ) ; t . emitCommentPending ( ) ; t . transition ( Data ) ; break ; case eof : t . eofError ( this ) ; t . emitCommentPending ( ) ; t . transition ( Data ) ; break ; default : t . commentPending . data . append ( c ) ; t . transition ( Comment ) ; } }
--------------------------------------------------
void read ( Tokeniser t , CharacterReader r ) { char c = r . consume ( ) ; switch ( c ) { case '-' : t . transition ( CommentStartDash ) ; break ; case nullChar : t . error ( this ) ; t . commentPending . data . append ( replacementChar ) ; t . transition ( Comment ) ; break ; case '>' : t . error ( this ) ; t . emitCommentPending ( ) ; t . transition ( Data ) ; break ; case eof : t . eofError ( this ) ; t . emitCommentPending ( ) ; t . transition ( Data ) ; break ; default : t . commentPending . data . append ( c ) ; t . transition ( Comment ) ; } }
--------------------------------------------------
void read ( Tokeniser t , CharacterReader r ) { char c = r . consume ( ) ; switch ( c ) { case '-' : t . commentPending . data . append ( "--!" ) ; t . transition ( CommentEndDash ) ; break ; case '>' : t . emitCommentPending ( ) ; t . transition ( Data ) ; break ; case nullChar : t . error ( this ) ; t . commentPending . data . append ( "--!" ) . append ( replacementChar ) ; t . transition ( Comment ) ; break ; case eof : t . eofError ( this ) ; t . emitCommentPending ( ) ; t . transition ( Data ) ; break ; default : t . commentPending . data . append ( "--!" ) . append ( c ) ; t . transition ( Comment ) ; } }
--------------------------------------------------
private Elements nextElementSiblings ( boolean next ) { Elements els = new Elements ( ) ; if ( parentNode == null ) return els ; els . add ( this ) ; return next ? els . nextAll ( ) : els . prevAll ( ) ; }
--------------------------------------------------
public Elements addClass ( String className ) { for ( Element element : this ) { element . addClass ( className ) ; } return this ; }
--------------------------------------------------
