int indexOfKey ( String key ) { Validate . notNull ( key ) ; for ( int i = 0 ; i < size ; i ++ ) { if ( key . equals ( keys [ i ] ) ) return i ; } return NotFound ; }
--------------------------------------------------
public String toString ( ) { return String . format ( "[%s]" , key ) ; }
--------------------------------------------------
public static boolean isInvisibleChar ( int c ) { return Character . getType ( c ) == 16 && ( c == 8203 || c == 8204 || c == 8205 || c == 173 ) ; }
--------------------------------------------------
public Attributes put ( String key , String value ) { int i = indexOfKey ( key ) ; if ( i != NotFound ) vals [ i ] = value ; else add ( key , value ) ; return this ; }
--------------------------------------------------
public Elements getElementsByAttribute ( String key ) { Validate . notEmpty ( key ) ; key = key . trim ( ) ; return Collector . collect ( new Evaluator . Attribute ( key ) , this ) ; }
--------------------------------------------------
Element getActiveFormattingElement ( String nodeName ) { for ( int pos = formattingElements . size ( ) - 1 ; pos >= 0 ; pos -- ) { Element next = formattingElements . get ( pos ) ; if ( next == null ) break ; else if ( next . normalName ( ) . equals ( nodeName ) ) return next ; } return null ; }
--------------------------------------------------
public String toString ( ) { return accum . toString ( ) ; }
--------------------------------------------------
public boolean removeAll ( Collection < ? > c ) { onContentsChanged ( ) ; return super . removeAll ( c ) ; }
--------------------------------------------------
private void findElements ( ) { if ( tq . matchChomp ( "#" ) ) byId ( ) ; else if ( tq . matchChomp ( "." ) ) byClass ( ) ; else if ( tq . matchesWord ( ) || tq . matches ( "*|" ) ) byTag ( ) ; else if ( tq . matches ( "[" ) ) byAttribute ( ) ; else if ( tq . matchChomp ( "*" ) ) allElements ( ) ; else if ( tq . matchChomp ( ":lt(" ) ) indexLessThan ( ) ; else if ( tq . matchChomp ( ":gt(" ) ) indexGreaterThan ( ) ; else if ( tq . matchChomp ( ":eq(" ) ) indexEquals ( ) ; else if ( tq . matches ( ":has(" ) ) has ( ) ; else if ( tq . matches ( ":contains(" ) ) contains ( false ) ; else if ( tq . matches ( ":containsown(" ) ) contains ( true ) ; else if ( tq . matches ( ":containsdata(" ) ) containsData ( ) ; else if ( tq . matches ( ":matches(" ) ) matches ( false ) ; else if ( tq . matches ( ":matchesown(" ) ) matches ( true ) ; else if ( tq . matches ( ":not(" ) ) not ( ) ; else if ( tq . matchChomp ( ":nth-child(" ) ) cssNthChild ( false , false ) ; else if ( tq . matchChomp ( ":nth-last-child(" ) ) cssNthChild ( true , false ) ; else if ( tq . matchChomp ( ":nth-of-type(" ) ) cssNthChild ( false , true ) ; else if ( tq . matchChomp ( ":nth-last-of-type(" ) ) cssNthChild ( true , true ) ; else if ( tq . matchChomp ( ":first-child" ) ) evals . add ( new Evaluator . IsFirstChild ( ) ) ; else if ( tq . matchChomp ( ":last-child" ) ) evals . add ( new Evaluator . IsLastChild ( ) ) ; else if ( tq . matchChomp ( ":first-of-type" ) ) evals . add ( new Evaluator . IsFirstOfType ( ) ) ; else if ( tq . matchChomp ( ":last-of-type" ) ) evals . add ( new Evaluator . IsLastOfType ( ) ) ; else if ( tq . matchChomp ( ":only-child" ) ) evals . add ( new Evaluator . IsOnlyChild ( ) ) ; else if ( tq . matchChomp ( ":only-of-type" ) ) evals . add ( new Evaluator . IsOnlyOfType ( ) ) ; else if ( tq . matchChomp ( ":empty" ) ) evals . add ( new Evaluator . IsEmpty ( ) ) ; else if ( tq . matchChomp ( ":root" ) ) evals . add ( new Evaluator . IsRoot ( ) ) ; else if ( tq . matchChomp ( ":matchtext" ) ) evals . add ( new Evaluator . MatchText ( ) ) ; else throw new Selector . SelectorParseException ( "could not parse query '%s': unexpected token at '%s'" , query , tq . remainder ( ) ) ; }
--------------------------------------------------
public boolean hasHeaderWithValue ( String name , String value ) { Validate . notEmpty ( name ) ; Validate . notEmpty ( value ) ; List < String > values = headers ( name ) ; for ( String candidate : values ) { if ( value . equalsIgnoreCase ( candidate ) ) return true ; } return false ; }
--------------------------------------------------
