public W3CBuilder ( Document doc ) { this . doc = doc ; this . namespacesStack . push ( new HashMap < String , String > ( ) ) ; }
--------------------------------------------------
void updateNumEvaluators ( ) { num = evaluators . size ( ) ; }
--------------------------------------------------
static Response execute ( Connection . Request req , Response previousResponse ) throws IOException { Validate . notNull ( req , "request must not be null" ) ; Validate . notNull ( req . url ( ) , "url must be specified to connect" ) ; String protocol = req . url ( ) . getProtocol ( ) ; if ( ! protocol . equals ( "http" ) && ! protocol . equals ( "https" ) ) throw new MalformedURLException ( "only http & https protocols supported" ) ; final boolean methodHasBody = req . method ( ) . hasBody ( ) ; final boolean hasRequestBody = req . requestBody ( ) != null ; if ( ! methodHasBody ) Validate . isFalse ( hasRequestBody , "cannot set a request body for http method " + req . method ( ) ) ; String mimeBoundary = null ; if ( req . data ( ) . size ( ) > 0 && ( ! methodHasBody || hasRequestBody ) ) serialiseRequestUrl ( req ) ; else if ( methodHasBody ) mimeBoundary = setOutputContentType ( req ) ; long startTime = System . nanoTime ( ) ; HttpURLConnection conn = createConnection ( req ) ; Response res ; try { conn . connect ( ) ; if ( conn . getDoOutput ( ) ) writePost ( req , conn . getOutputStream ( ) , mimeBoundary ) ; int status = conn . getResponseCode ( ) ; res = new Response ( previousResponse ) ; res . setupFromConnection ( conn , previousResponse ) ; res . req = req ; if ( res . hasHeader ( LOCATION ) && req . followRedirects ( ) ) { if ( status != HTTP_TEMP_REDIR ) { req . method ( Method . GET ) ; req . data ( ) . clear ( ) ; req . requestBody ( null ) ; req . removeHeader ( CONTENT_TYPE ) ; } String location = res . header ( LOCATION ) ; if ( location . startsWith ( "http:/" ) && location . charAt ( 6 ) != '/' ) location = location . substring ( 6 ) ; URL redir = StringUtil . resolve ( req . url ( ) , location ) ; req . url ( encodeUrl ( redir ) ) ; for ( Map . Entry < String , String > cookie : res . cookies . entrySet ( ) ) { req . cookie ( cookie . getKey ( ) , cookie . getValue ( ) ) ; } return execute ( req , res ) ; } if ( ( status < 200 || status >= 400 ) && ! req . ignoreHttpErrors ( ) ) throw new HttpStatusException ( "http error fetching url" , status , req . url ( ) . toString ( ) ) ; String contentType = res . contentType ( ) ; if ( contentType != null && ! req . ignoreContentType ( ) && ! contentType . startsWith ( "text/" ) && ! xmlContentTypeRxp . matcher ( contentType ) . matches ( ) ) throw new UnsupportedMimeTypeException ( "unhandled content type. must be text/*, application/xml, or application/xhtml+xml" , contentType , req . url ( ) . toString ( ) ) ; if ( contentType != null && xmlContentTypeRxp . matcher ( contentType ) . matches ( ) ) { if ( req instanceof HttpConnection . Request && ! ( ( Request ) req ) . parserDefined ) { req . parser ( Parser . xmlParser ( ) ) ; } } res . charset = DataUtil . getCharsetFromContentType ( res . contentType ) ; if ( conn . getContentLength ( ) != 0 && req . method ( ) != HEAD ) { res . bodyStream = null ; res . bodyStream = conn . getErrorStream ( ) != null ? conn . getErrorStream ( ) : conn . getInputStream ( ) ; if ( res . hasHeaderWithValue ( CONTENT_ENCODING , "gzip" ) ) { res . bodyStream = new GZIPInputStream ( res . bodyStream ) ; } else if ( res . hasHeaderWithValue ( CONTENT_ENCODING , "deflate" ) ) { res . bodyStream = new InflaterInputStream ( res . bodyStream , new Inflater ( true ) ) ; } res . bodyStream = ConstrainableInputStream . wrap ( res . bodyStream , DataUtil . bufferSize , req . maxBodySize ( ) ) . timeout ( startTime , req . timeout ( ) ) ; } else { res . byteData = DataUtil . emptyByteBuffer ( ) ; } } catch ( IOException e ) { conn . disconnect ( ) ; throw e ; } res . executed = true ; return res ; }
--------------------------------------------------
void eofError ( TokeniserState state ) { if ( errors . canAddError ( ) ) errors . add ( new ParseError ( reader . pos ( ) , "unexpectedly reached end of file (eof) in input state [%s]" , state ) ) ; }
--------------------------------------------------
protected void addChildren ( Node ... children ) { final List < Node > nodes = ensureChildNodes ( ) ; for ( Node child : children ) { reparentChild ( child ) ; nodes . add ( child ) ; child . setSiblingIndex ( nodes . size ( ) - 1 ) ; } }
--------------------------------------------------
void unconsume ( ) { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( "no buffer left to unconsume" ) ) ; bufPos -- ; }
--------------------------------------------------
private void combinator ( char combinator ) { tq . consumeWhitespace ( ) ; String subQuery = consumeSubQuery ( ) ; Evaluator rootEval ; Evaluator currentEval ; Evaluator newEval = parse ( subQuery ) ; boolean replaceRightMost = false ; if ( evals . size ( ) == 1 ) { rootEval = currentEval = evals . get ( 0 ) ; if ( rootEval instanceof CombiningEvaluator . Or && combinator != ',' ) { currentEval = ( ( CombiningEvaluator . Or ) currentEval ) . rightMostEvaluator ( ) ; replaceRightMost = true ; } } else { rootEval = currentEval = new CombiningEvaluator . And ( evals ) ; } evals . clear ( ) ; if ( combinator == '>' ) currentEval = new CombiningEvaluator . And ( newEval , new StructuralEvaluator . ImmediateParent ( currentEval ) ) ; else if ( combinator == ' ' ) currentEval = new CombiningEvaluator . And ( newEval , new StructuralEvaluator . Parent ( currentEval ) ) ; else if ( combinator == '+' ) currentEval = new CombiningEvaluator . And ( newEval , new StructuralEvaluator . ImmediatePreviousSibling ( currentEval ) ) ; else if ( combinator == '~' ) currentEval = new CombiningEvaluator . And ( newEval , new StructuralEvaluator . PreviousSibling ( currentEval ) ) ; else if ( combinator == ',' ) { CombiningEvaluator . Or or ; if ( currentEval instanceof CombiningEvaluator . Or ) { or = ( CombiningEvaluator . Or ) currentEval ; or . add ( newEval ) ; } else { or = new CombiningEvaluator . Or ( ) ; or . add ( currentEval ) ; or . add ( newEval ) ; } currentEval = or ; } else throw new Selector . SelectorParseException ( "unknown combinator: " + combinator ) ; if ( replaceRightMost ) ( ( CombiningEvaluator . Or ) rootEval ) . replaceRightMostEvaluator ( currentEval ) ; else rootEval = currentEval ; evals . add ( rootEval ) ; }
--------------------------------------------------
public void add ( int index , E element ) { onContentsChanged ( ) ; super . add ( index , element ) ; }
--------------------------------------------------
public void add ( Evaluator e ) { evaluators . add ( e ) ; updateNumEvaluators ( ) ; }
--------------------------------------------------
protected List < Node > ensureChildNodes ( ) { return EmptyNodes ; }
--------------------------------------------------
