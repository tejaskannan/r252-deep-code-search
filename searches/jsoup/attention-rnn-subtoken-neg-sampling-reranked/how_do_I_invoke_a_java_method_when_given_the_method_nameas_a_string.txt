void removeFromActiveFormattingElements ( Element el ) { for ( int pos = formattingElements . size ( ) - 1 ; pos >= 0 ; pos -- ) { Element next = formattingElements . get ( pos ) ; if ( next == el ) { formattingElements . remove ( pos ) ; break ; } } }
--------------------------------------------------
public boolean isValidBodyHtml ( String bodyHtml ) { Document clean = Document . createShell ( "" ) ; Document dirty = Document . createShell ( "" ) ; ParseErrorList errorList = ParseErrorList . tracking ( 1 ) ; List < Node > nodes = Parser . parseFragment ( bodyHtml , dirty . body ( ) , "" , errorList ) ; dirty . body ( ) . insertChildren ( 0 , nodes ) ; int numDiscarded = copySafeNodes ( dirty . body ( ) , clean . body ( ) ) ; return numDiscarded == 0 && errorList . size ( ) == 0 ; }
--------------------------------------------------
public boolean matches ( Element root , Element element ) { final Element p = element . parent ( ) ; if ( p == null || p instanceof Document ) return false ; int pos = 0 ; Elements family = p . children ( ) ; for ( Element el : family ) { if ( el . tag ( ) . equals ( element . tag ( ) ) ) pos ++ ; } return pos == 1 ; }
--------------------------------------------------
private static void appendNormalisedText ( StringBuilder accum , TextNode textNode ) { String text = textNode . getWholeText ( ) ; if ( preserveWhitespace ( textNode . parentNode ) || textNode instanceof CDataNode ) accum . append ( text ) ; else StringUtil . appendNormalisedWhitespace ( accum , text , TextNode . lastCharIsWhitespace ( accum ) ) ; }
--------------------------------------------------
public boolean matches ( Element root , Element node ) { for ( int i = 0 ; i < num ; i ++ ) { Evaluator s = evaluators . get ( i ) ; if ( s . matches ( root , node ) ) return true ; } return false ; }
--------------------------------------------------
public boolean matches ( Element root , Element node ) { for ( int i = 0 ; i < num ; i ++ ) { Evaluator s = evaluators . get ( i ) ; if ( ! s . matches ( root , node ) ) return false ; } return true ; }
--------------------------------------------------
public Whitelist removeAttributes ( String tag , String ... attributes ) { Validate . notEmpty ( tag ) ; Validate . notNull ( attributes ) ; Validate . isTrue ( attributes . length > 0 , "no attribute names supplied." ) ; TagName tagName = TagName . valueOf ( tag ) ; Set < AttributeKey > attributeSet = new HashSet < > ( ) ; for ( String key : attributes ) { Validate . notEmpty ( key ) ; attributeSet . add ( AttributeKey . valueOf ( key ) ) ; } if ( tagNames . contains ( tagName ) && this . attributes . containsKey ( tagName ) ) { Set < AttributeKey > currentSet = this . attributes . get ( tagName ) ; currentSet . removeAll ( attributeSet ) ; if ( currentSet . isEmpty ( ) ) this . attributes . remove ( tagName ) ; } if ( tag . equals ( ":all" ) ) for ( TagName name : this . attributes . keySet ( ) ) { Set < AttributeKey > currentSet = this . attributes . get ( name ) ; currentSet . removeAll ( attributeSet ) ; if ( currentSet . isEmpty ( ) ) this . attributes . remove ( name ) ; } return this ; }
--------------------------------------------------
public boolean isValid ( Document dirtyDocument ) { Validate . notNull ( dirtyDocument ) ; Document clean = Document . createShell ( dirtyDocument . baseUri ( ) ) ; int numDiscarded = copySafeNodes ( dirtyDocument . body ( ) , clean . body ( ) ) ; return numDiscarded == 0 && dirtyDocument . head ( ) . childNodes ( ) . size ( ) == 0 ; }
--------------------------------------------------
private static void load ( EscapeMode e , String pointsData , int size ) { e . nameKeys = new String [ size ] ; e . codeVals = new int [ size ] ; e . codeKeys = new int [ size ] ; e . nameVals = new String [ size ] ; int i = 0 ; CharacterReader reader = new CharacterReader ( pointsData ) ; while ( ! reader . isEmpty ( ) ) { final String name = reader . consumeTo ( '=' ) ; reader . advance ( ) ; final int cp1 = Integer . parseInt ( reader . consumeToAny ( codeDelims ) , codepointRadix ) ; final char codeDelim = reader . current ( ) ; reader . advance ( ) ; final int cp2 ; if ( codeDelim == ',' ) { cp2 = Integer . parseInt ( reader . consumeTo ( ';' ) , codepointRadix ) ; reader . advance ( ) ; } else { cp2 = empty ; } final String indexS = reader . consumeTo ( '&' ) ; final int index = Integer . parseInt ( indexS , codepointRadix ) ; reader . advance ( ) ; e . nameKeys [ i ] = name ; e . codeVals [ i ] = cp1 ; e . codeKeys [ index ] = cp1 ; e . nameVals [ index ] = name ; if ( cp2 != empty ) { multipoints . put ( name , new String ( new int [ ] { cp1 , cp2 } , 0 , 2 ) ) ; } i ++ ; } Validate . isTrue ( i == size , "unexpected count of entities loaded" ) ; }
--------------------------------------------------
void emit ( final String str ) { if ( charsString == null ) { charsString = str ; } else { if ( charsBuilder . length ( ) == 0 ) { charsBuilder . append ( charsString ) ; } charsBuilder . append ( str ) ; } }
--------------------------------------------------
