public List < Node > childNodesCopy ( ) { final List < Node > nodes = ensureChildNodes ( ) ; final ArrayList < Node > children = new ArrayList < > ( nodes . size ( ) ) ; for ( Node node : nodes ) { children . add ( node . clone ( ) ) ; } return children ; }
--------------------------------------------------
public FormElement addElement ( Element element ) { elements . add ( element ) ; return this ; }
--------------------------------------------------
public void add ( Evaluator e ) { evaluators . add ( e ) ; updateNumEvaluators ( ) ; }
--------------------------------------------------
boolean process ( Token t , HtmlTreeBuilder tb ) { if ( isWhitespace ( t ) ) { return tb . process ( t , InBody ) ; } else if ( t . isComment ( ) ) { tb . insert ( t . asComment ( ) ) ; } else if ( t . isDoctype ( ) ) { tb . error ( this ) ; return false ; } else if ( t . isStartTag ( ) && t . asStartTag ( ) . normalName ( ) . equals ( "html" ) ) { return tb . process ( t , InBody ) ; } else if ( t . isEndTag ( ) && t . asEndTag ( ) . normalName ( ) . equals ( "html" ) ) { if ( tb . isFragmentParsing ( ) ) { tb . error ( this ) ; return false ; } else { tb . transition ( AfterAfterBody ) ; } } else if ( t . isEOF ( ) ) { } else { tb . error ( this ) ; tb . transition ( InBody ) ; return tb . process ( t ) ; } return true ; }
--------------------------------------------------
protected void addChildren ( int index , Node ... children ) { Validate . noNullElements ( children ) ; final List < Node > nodes = ensureChildNodes ( ) ; for ( Node child : children ) { reparentChild ( child ) ; } nodes . addAll ( index , Arrays . asList ( children ) ) ; reindexChildren ( index ) ; }
--------------------------------------------------
boolean process ( Token t , HtmlTreeBuilder tb ) { if ( isWhitespace ( t ) ) { tb . insert ( t . asCharacter ( ) ) ; } else if ( t . isComment ( ) ) { tb . insert ( t . asComment ( ) ) ; } else if ( t . isDoctype ( ) ) { tb . error ( this ) ; return false ; } else if ( t . isStartTag ( ) ) { Token . StartTag start = t . asStartTag ( ) ; switch ( start . normalName ( ) ) { case "html" : return tb . process ( start , InBody ) ; case "frameset" : tb . insert ( start ) ; break ; case "frame" : tb . insertEmpty ( start ) ; break ; case "noframes" : return tb . process ( start , InHead ) ; default : tb . error ( this ) ; return false ; } } else if ( t . isEndTag ( ) && t . asEndTag ( ) . normalName ( ) . equals ( "frameset" ) ) { if ( tb . currentElement ( ) . normalName ( ) . equals ( "html" ) ) { tb . error ( this ) ; return false ; } else { tb . pop ( ) ; if ( ! tb . isFragmentParsing ( ) && ! tb . currentElement ( ) . normalName ( ) . equals ( "frameset" ) ) { tb . transition ( AfterFrameset ) ; } } } else if ( t . isEOF ( ) ) { if ( ! tb . currentElement ( ) . normalName ( ) . equals ( "html" ) ) { tb . error ( this ) ; return true ; } } else { tb . error ( this ) ; return false ; } return true ; }
--------------------------------------------------
private void combinator ( char combinator ) { tq . consumeWhitespace ( ) ; String subQuery = consumeSubQuery ( ) ; Evaluator rootEval ; Evaluator currentEval ; Evaluator newEval = parse ( subQuery ) ; boolean replaceRightMost = false ; if ( evals . size ( ) == 1 ) { rootEval = currentEval = evals . get ( 0 ) ; if ( rootEval instanceof CombiningEvaluator . Or && combinator != ',' ) { currentEval = ( ( CombiningEvaluator . Or ) currentEval ) . rightMostEvaluator ( ) ; replaceRightMost = true ; } } else { rootEval = currentEval = new CombiningEvaluator . And ( evals ) ; } evals . clear ( ) ; if ( combinator == '>' ) currentEval = new CombiningEvaluator . And ( newEval , new StructuralEvaluator . ImmediateParent ( currentEval ) ) ; else if ( combinator == ' ' ) currentEval = new CombiningEvaluator . And ( newEval , new StructuralEvaluator . Parent ( currentEval ) ) ; else if ( combinator == '+' ) currentEval = new CombiningEvaluator . And ( newEval , new StructuralEvaluator . ImmediatePreviousSibling ( currentEval ) ) ; else if ( combinator == '~' ) currentEval = new CombiningEvaluator . And ( newEval , new StructuralEvaluator . PreviousSibling ( currentEval ) ) ; else if ( combinator == ',' ) { CombiningEvaluator . Or or ; if ( currentEval instanceof CombiningEvaluator . Or ) { or = ( CombiningEvaluator . Or ) currentEval ; or . add ( newEval ) ; } else { or = new CombiningEvaluator . Or ( ) ; or . add ( currentEval ) ; or . add ( newEval ) ; } currentEval = or ; } else throw new Selector . SelectorParseException ( "unknown combinator: " + combinator ) ; if ( replaceRightMost ) ( ( CombiningEvaluator . Or ) rootEval ) . replaceRightMostEvaluator ( currentEval ) ; else rootEval = currentEval ; evals . add ( rootEval ) ; }
--------------------------------------------------
boolean process ( Token t , HtmlTreeBuilder tb ) { if ( t . isStartTag ( ) ) { Token . StartTag startTag = t . asStartTag ( ) ; String name = startTag . normalName ( ) ; if ( name . equals ( "template" ) ) { tb . insert ( startTag ) ; } else if ( StringUtil . in ( name , "th" , "td" ) ) { tb . clearStackToTableRowContext ( ) ; tb . insert ( startTag ) ; tb . transition ( InCell ) ; tb . insertMarkerToFormattingElements ( ) ; } else if ( StringUtil . in ( name , "caption" , "col" , "colgroup" , "tbody" , "tfoot" , "thead" , "tr" ) ) { return handleMissingTr ( t , tb ) ; } else { return anythingElse ( t , tb ) ; } } else if ( t . isEndTag ( ) ) { Token . EndTag endTag = t . asEndTag ( ) ; String name = endTag . normalName ( ) ; if ( name . equals ( "tr" ) ) { if ( ! tb . inTableScope ( name ) ) { tb . error ( this ) ; return false ; } tb . clearStackToTableRowContext ( ) ; tb . pop ( ) ; tb . transition ( InTableBody ) ; } else if ( name . equals ( "table" ) ) { return handleMissingTr ( t , tb ) ; } else if ( StringUtil . in ( name , "tbody" , "tfoot" , "thead" ) ) { if ( ! tb . inTableScope ( name ) ) { tb . error ( this ) ; return false ; } tb . processEndTag ( "tr" ) ; return tb . process ( t ) ; } else if ( StringUtil . in ( name , "body" , "caption" , "col" , "colgroup" , "html" , "td" , "th" ) ) { tb . error ( this ) ; return false ; } else { return anythingElse ( t , tb ) ; } } else { return anythingElse ( t , tb ) ; } return true ; }
--------------------------------------------------
boolean process ( Token t , HtmlTreeBuilder tb ) { if ( t . isComment ( ) ) { tb . insert ( t . asComment ( ) ) ; } else if ( t . isDoctype ( ) || isWhitespace ( t ) || ( t . isStartTag ( ) && t . asStartTag ( ) . normalName ( ) . equals ( "html" ) ) ) { return tb . process ( t , InBody ) ; } else if ( t . isEOF ( ) ) { } else { tb . error ( this ) ; tb . transition ( InBody ) ; return tb . process ( t ) ; } return true ; }
--------------------------------------------------
boolean process ( Token t , HtmlTreeBuilder tb ) { if ( isWhitespace ( t ) ) { return true ; } else if ( t . isComment ( ) ) { tb . insert ( t . asComment ( ) ) ; } else if ( t . isDoctype ( ) ) { tb . error ( this ) ; return false ; } else if ( t . isStartTag ( ) && t . asStartTag ( ) . normalName ( ) . equals ( "html" ) ) { return InBody . process ( t , tb ) ; } else if ( t . isStartTag ( ) && t . asStartTag ( ) . normalName ( ) . equals ( "head" ) ) { Element head = tb . insert ( t . asStartTag ( ) ) ; tb . setHeadElement ( head ) ; tb . transition ( InHead ) ; } else if ( t . isEndTag ( ) && ( StringUtil . in ( t . asEndTag ( ) . normalName ( ) , "head" , "body" , "html" , "br" ) ) ) { tb . processStartTag ( "head" ) ; return tb . process ( t ) ; } else if ( t . isEndTag ( ) ) { tb . error ( this ) ; return false ; } else { tb . processStartTag ( "head" ) ; return tb . process ( t ) ; } return true ; }
--------------------------------------------------
