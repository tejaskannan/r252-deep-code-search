private Elements nextElementSiblings ( boolean next ) { Elements els = new Elements ( ) ; if ( parentNode == null ) return els ; els . add ( this ) ; return next ? els . nextAll ( ) : els . prevAll ( ) ; }
--------------------------------------------------
void insert ( Token . Character token ) { final String data = token . getData ( ) ; insertNode ( token . isCData ( ) ? new CDataNode ( data ) : new TextNode ( data ) ) ; }
--------------------------------------------------
public static void traverse ( NodeVisitor visitor , Node root ) { Node node = root ; int depth = 0 ; while ( node != null ) { visitor . head ( node , depth ) ; if ( node . childNodeSize ( ) > 0 ) { node = node . childNode ( 0 ) ; depth ++ ; } else { while ( node . nextSibling ( ) == null && depth > 0 ) { visitor . tail ( node , depth ) ; node = node . parentNode ( ) ; depth -- ; } visitor . tail ( node , depth ) ; if ( node == root ) break ; node = node . nextSibling ( ) ; } } }
--------------------------------------------------
private void addSiblingHtml ( int index , String html ) { Validate . notNull ( html ) ; Validate . notNull ( parentNode ) ; Element context = parent ( ) instanceof Element ? ( Element ) parent ( ) : null ; List < Node > nodes = NodeUtils . parser ( this ) . parseFragmentInput ( html , context , baseUri ( ) ) ; parentNode . addChildren ( index , nodes . toArray ( new Node [ 0 ] ) ) ; }
--------------------------------------------------
void insertOnStackAfter ( Element after , Element in ) { int i = stack . lastIndexOf ( after ) ; Validate . isTrue ( i != - 1 ) ; stack . add ( i + 1 , in ) ; }
--------------------------------------------------
void read ( Tokeniser t , CharacterReader r ) { char c = r . consume ( ) ; switch ( c ) { case '-' : t . commentPending . data . append ( "--!" ) ; t . transition ( CommentEndDash ) ; break ; case '>' : t . emitCommentPending ( ) ; t . transition ( Data ) ; break ; case nullChar : t . error ( this ) ; t . commentPending . data . append ( "--!" ) . append ( replacementChar ) ; t . transition ( Comment ) ; break ; case eof : t . eofError ( this ) ; t . emitCommentPending ( ) ; t . transition ( Data ) ; break ; default : t . commentPending . data . append ( "--!" ) . append ( c ) ; t . transition ( Comment ) ; } }
--------------------------------------------------
public ByteBuffer readToByteBuffer ( int max ) throws IOException { Validate . isTrue ( max >= 0 , "maxsize must be 0 (unlimited) or larger" ) ; final boolean localCapped = max > 0 ; final int bufferSize = localCapped && max < DefaultSize ? max : DefaultSize ; final byte [ ] readBuffer = new byte [ bufferSize ] ; final ByteArrayOutputStream outStream = new ByteArrayOutputStream ( bufferSize ) ; int read ; int remaining = max ; while ( true ) { read = read ( readBuffer ) ; if ( read == - 1 ) break ; if ( localCapped ) { if ( read >= remaining ) { outStream . write ( readBuffer , 0 , remaining ) ; break ; } remaining -= read ; } outStream . write ( readBuffer , 0 , read ) ; } return ByteBuffer . wrap ( outStream . toByteArray ( ) ) ; }
--------------------------------------------------
void read ( Tokeniser t , CharacterReader r ) { char c = r . consume ( ) ; switch ( c ) { case '\t' : case '\n' : case '\r' : case '\f' : case ' ' : break ; case '>' : t . emitDoctypePending ( ) ; t . transition ( Data ) ; break ; case eof : t . eofError ( this ) ; t . doctypePending . forceQuirks = true ; t . emitDoctypePending ( ) ; t . transition ( Data ) ; break ; default : t . error ( this ) ; t . transition ( BogusDoctype ) ; } }
--------------------------------------------------
void read ( Tokeniser t , CharacterReader r ) { if ( r . isEmpty ( ) ) { t . eofError ( this ) ; t . transition ( Data ) ; return ; } char c = r . consume ( ) ; switch ( c ) { case '-' : t . emit ( c ) ; t . transition ( ScriptDataEscapedDashDash ) ; break ; case '<' : t . transition ( ScriptDataEscapedLessthanSign ) ; break ; case nullChar : t . error ( this ) ; t . emit ( replacementChar ) ; t . transition ( ScriptDataEscaped ) ; break ; default : t . emit ( c ) ; t . transition ( ScriptDataEscaped ) ; } }
--------------------------------------------------
boolean process ( Token t , HtmlTreeBuilder tb ) { if ( t . isDoctype ( ) ) { tb . error ( this ) ; } else if ( t . isStartTag ( ) && t . asStartTag ( ) . normalName ( ) . equals ( "html" ) ) { return tb . process ( t , InBody ) ; } else if ( t . isEndTag ( ) && t . asEndTag ( ) . normalName ( ) . equals ( "noscript" ) ) { tb . pop ( ) ; tb . transition ( InHead ) ; } else if ( isWhitespace ( t ) || t . isComment ( ) || ( t . isStartTag ( ) && StringUtil . in ( t . asStartTag ( ) . normalName ( ) , "basefont" , "bgsound" , "link" , "meta" , "noframes" , "style" ) ) ) { return tb . process ( t , InHead ) ; } else if ( t . isEndTag ( ) && t . asEndTag ( ) . normalName ( ) . equals ( "br" ) ) { return anythingElse ( t , tb ) ; } else if ( ( t . isStartTag ( ) && StringUtil . in ( t . asStartTag ( ) . normalName ( ) , "head" , "noscript" ) ) || t . isEndTag ( ) ) { tb . error ( this ) ; return false ; } else { return anythingElse ( t , tb ) ; } return true ; }
--------------------------------------------------
