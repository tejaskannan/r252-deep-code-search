private static String [ ] copyOf ( String [ ] orig , int size ) { final String [ ] copy = new String [ size ] ; System . arraycopy ( orig , 0 , copy , 0 , Math . min ( orig . length , size ) ) ; return copy ; }
--------------------------------------------------
protected boolean processStartTag ( String name ) { if ( currentToken == start ) { return process ( new Token . StartTag ( ) . name ( name ) ) ; } return process ( start . reset ( ) . name ( name ) ) ; }
--------------------------------------------------
protected void removeChild ( Node out ) { Validate . isTrue ( out . parentNode == this ) ; final int index = out . siblingIndex ; ensureChildNodes ( ) . remove ( index ) ; reindexChildren ( index ) ; out . parentNode = null ; }
--------------------------------------------------
void read ( Tokeniser t , CharacterReader r ) { if ( r . isEmpty ( ) ) { t . eofError ( this ) ; t . doctypePending . forceQuirks = true ; t . emitDoctypePending ( ) ; t . transition ( Data ) ; return ; } if ( r . matchesAny ( '\t' , '\n' , '\r' , '\f' , ' ' ) ) r . advance ( ) ; else if ( r . matches ( '>' ) ) { t . emitDoctypePending ( ) ; t . advanceTransition ( Data ) ; } else if ( r . matchConsumeIgnoreCase ( DocumentType . PUBLIC_KEY ) ) { t . doctypePending . pubSysKey = DocumentType . PUBLIC_KEY ; t . transition ( AfterDoctypePublicKeyword ) ; } else if ( r . matchConsumeIgnoreCase ( DocumentType . SYSTEM_KEY ) ) { t . doctypePending . pubSysKey = DocumentType . SYSTEM_KEY ; t . transition ( AfterDoctypeSystemKeyword ) ; } else { t . error ( this ) ; t . doctypePending . forceQuirks = true ; t . advanceTransition ( BogusDoctype ) ; } }
--------------------------------------------------
void read ( Tokeniser t , CharacterReader r ) { switch ( r . current ( ) ) { case '&' : t . advanceTransition ( CharacterReferenceInRcdata ) ; break ; case '<' : t . advanceTransition ( RcdataLessthanSign ) ; break ; case nullChar : t . error ( this ) ; r . advance ( ) ; t . emit ( replacementChar ) ; break ; case eof : t . emit ( new Token . EOF ( ) ) ; break ; default : String data = r . consumeToAny ( '&' , '<' , nullChar ) ; t . emit ( data ) ; break ; } }
--------------------------------------------------
private String updateNamespaces ( org . jsoup . nodes . Element el ) { Attributes attributes = el . attributes ( ) ; for ( Attribute attr : attributes ) { String key = attr . getKey ( ) ; String prefix ; if ( key . equals ( xmlnsKey ) ) { prefix = "" ; } else if ( key . startsWith ( xmlnsPrefix ) ) { prefix = key . substring ( xmlnsPrefix . length ( ) ) ; } else { continue ; } namespacesStack . peek ( ) . put ( prefix , attr . getValue ( ) ) ; } int pos = el . tagName ( ) . indexOf ( ":" ) ; return pos > 0 ? el . tagName ( ) . substring ( 0 , pos ) : "" ; }
--------------------------------------------------
void read ( Tokeniser t , CharacterReader r ) { if ( r . isEmpty ( ) ) { t . eofError ( this ) ; t . emit ( "</" ) ; t . transition ( Data ) ; } else if ( r . matchesLetter ( ) ) { t . createTagPending ( false ) ; t . transition ( TagName ) ; } else if ( r . matches ( '>' ) ) { t . error ( this ) ; t . advanceTransition ( Data ) ; } else { t . error ( this ) ; t . advanceTransition ( BogusComment ) ; } }
--------------------------------------------------
public static void main ( String [ ] args ) throws IOException { Document doc = Jsoup . connect ( "http://en.wikipedia.org/" ) . get ( ) ; log ( doc . title ( ) ) ; Elements newsHeadlines = doc . select ( "#mp-itn b a" ) ; for ( Element headline : newsHeadlines ) { log ( "%s
	%s" , headline . attr ( "title" ) , headline . absUrl ( "href" ) ) ; } }
--------------------------------------------------
static Document parseInputStream ( InputStream input , String charsetName , String baseUri , Parser parser ) throws IOException { if ( input == null ) return new Document ( baseUri ) ; input = ConstrainableInputStream . wrap ( input , bufferSize , 0 ) ; Document doc = null ; boolean fullyRead = false ; input . mark ( bufferSize ) ; ByteBuffer firstBytes = readToByteBuffer ( input , firstReadBufferSize - 1 ) ; fullyRead = input . read ( ) == - 1 ; input . reset ( ) ; BomCharset bomCharset = detectCharsetFromBom ( firstBytes ) ; if ( bomCharset != null ) charsetName = bomCharset . charset ; if ( charsetName == null ) { String docData = Charset . forName ( defaultCharset ) . decode ( firstBytes ) . toString ( ) ; doc = parser . parseInput ( docData , baseUri ) ; Elements metaElements = doc . select ( "meta[http-equiv=content-type], meta[charset]" ) ; String foundCharset = null ; for ( Element meta : metaElements ) { if ( meta . hasAttr ( "http-equiv" ) ) foundCharset = getCharsetFromContentType ( meta . attr ( "content" ) ) ; if ( foundCharset == null && meta . hasAttr ( "charset" ) ) foundCharset = meta . attr ( "charset" ) ; if ( foundCharset != null ) break ; } if ( foundCharset == null && doc . childNodeSize ( ) > 0 ) { Node first = doc . childNode ( 0 ) ; XmlDeclaration decl = null ; if ( first instanceof XmlDeclaration ) decl = ( XmlDeclaration ) first ; else if ( first instanceof Comment ) { Comment comment = ( Comment ) first ; if ( comment . isXmlDeclaration ( ) ) decl = comment . asXmlDeclaration ( ) ; } if ( decl != null ) { if ( decl . name ( ) . equalsIgnoreCase ( "xml" ) ) foundCharset = decl . attr ( "encoding" ) ; } } foundCharset = validateCharset ( foundCharset ) ; if ( foundCharset != null && ! foundCharset . equalsIgnoreCase ( defaultCharset ) ) { foundCharset = foundCharset . trim ( ) . replaceAll ( "["']" , "" ) ; charsetName = foundCharset ; doc = null ; } else if ( ! fullyRead ) { doc = null ; } } else { Validate . notEmpty ( charsetName , "must set charset arg to character set of file to parse. set to null to attempt to detect from html" ) ; } if ( doc == null ) { if ( charsetName == null ) charsetName = defaultCharset ; BufferedReader reader = new BufferedReader ( new InputStreamReader ( input , charsetName ) , bufferSize ) ; if ( bomCharset != null && bomCharset . offset ) reader . skip ( 1 ) ; try { doc = parser . parseInput ( reader , baseUri ) ; } catch ( UncheckedIOException e ) { throw e . ioException ( ) ; } Charset charset = Charset . forName ( charsetName ) ; doc . outputSettings ( ) . charset ( charset ) ; if ( ! charset . canEncode ( ) ) { doc . charset ( Charset . forName ( defaultCharset ) ) ; } } input . close ( ) ; return doc ; }
--------------------------------------------------
void read ( Tokeniser t , CharacterReader r ) { switch ( r . current ( ) ) { case '!' : t . advanceTransition ( MarkupDeclarationOpen ) ; break ; case '/' : t . advanceTransition ( EndTagOpen ) ; break ; case '?' : t . advanceTransition ( BogusComment ) ; break ; default : if ( r . matchesLetter ( ) ) { t . createTagPending ( true ) ; t . transition ( TagName ) ; } else { t . error ( this ) ; t . emit ( '<' ) ; t . transition ( Data ) ; } break ; } }
--------------------------------------------------
