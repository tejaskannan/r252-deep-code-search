private static void readData ( Tokeniser t , CharacterReader r , TokeniserState current , TokeniserState advance ) { switch ( r . current ( ) ) { case '<' : t . advanceTransition ( advance ) ; break ; case nullChar : t . error ( current ) ; r . advance ( ) ; t . emit ( replacementChar ) ; break ; case eof : t . emit ( new Token . EOF ( ) ) ; break ; default : String data = r . consumeToAny ( '<' , nullChar ) ; t . emit ( data ) ; break ; } }
--------------------------------------------------
void read ( Tokeniser t , CharacterReader r ) { if ( r . matchConsume ( "--" ) ) { t . createCommentPending ( ) ; t . transition ( CommentStart ) ; } else if ( r . matchConsumeIgnoreCase ( "doctype" ) ) { t . transition ( Doctype ) ; } else if ( r . matchConsume ( "[cdata[" ) ) { t . createTempBuffer ( ) ; t . transition ( CdataSection ) ; } else { t . error ( this ) ; t . advanceTransition ( BogusComment ) ; } }
--------------------------------------------------
void read ( Tokeniser t , CharacterReader r ) { if ( r . matchesLetter ( ) ) { t . createTempBuffer ( ) ; t . dataBuffer . append ( r . current ( ) ) ; t . emit ( "<" + r . current ( ) ) ; t . advanceTransition ( ScriptDataDoubleEscapeStart ) ; } else if ( r . matches ( '/' ) ) { t . createTempBuffer ( ) ; t . advanceTransition ( ScriptDataEscapedEndTagOpen ) ; } else { t . emit ( '<' ) ; t . transition ( ScriptDataEscaped ) ; } }
--------------------------------------------------
boolean anyOtherEndTag ( Token t , HtmlTreeBuilder tb ) { String name = t . asEndTag ( ) . normalName ; ArrayList < Element > stack = tb . getStack ( ) ; for ( int pos = stack . size ( ) - 1 ; pos >= 0 ; pos -- ) { Element node = stack . get ( pos ) ; if ( node . normalName ( ) . equals ( name ) ) { tb . generateImpliedEndTags ( name ) ; if ( ! name . equals ( tb . currentElement ( ) . normalName ( ) ) ) tb . error ( this ) ; tb . popStackToClose ( name ) ; break ; } else { if ( tb . isSpecial ( node ) ) { tb . error ( this ) ; return false ; } } } return true ; }
--------------------------------------------------
void read ( Tokeniser t , CharacterReader r ) { switch ( r . current ( ) ) { case '&' : t . advanceTransition ( CharacterReferenceInData ) ; break ; case '<' : t . advanceTransition ( TagOpen ) ; break ; case nullChar : t . error ( this ) ; t . emit ( r . consume ( ) ) ; break ; case eof : t . emit ( new Token . EOF ( ) ) ; break ; default : String data = r . consumeData ( ) ; t . emit ( data ) ; break ; } }
--------------------------------------------------
public boolean processStartTag ( String name , Attributes attrs ) { if ( currentToken == start ) { return process ( new Token . StartTag ( ) . nameAttr ( name , attrs ) ) ; } start . reset ( ) ; start . nameAttr ( name , attrs ) ; return process ( start ) ; }
--------------------------------------------------
void read ( Tokeniser t , CharacterReader r ) { if ( r . matches ( '-' ) ) { t . emit ( '-' ) ; t . advanceTransition ( ScriptDataEscapeStartDash ) ; } else { t . transition ( ScriptData ) ; } }
--------------------------------------------------
public void remove ( ) { Validate . notNull ( parentNode ) ; parentNode . removeChild ( this ) ; }
--------------------------------------------------
void read ( Tokeniser t , CharacterReader r ) { char c = r . consume ( ) ; switch ( c ) { case '>' : t . emitDoctypePending ( ) ; t . transition ( Data ) ; break ; case eof : t . emitDoctypePending ( ) ; t . transition ( Data ) ; break ; default : break ; } }
--------------------------------------------------
static boolean preserveWhitespace ( Node node ) { if ( node instanceof Element ) { Element el = ( Element ) node ; int i = 0 ; do { if ( el . tag . preserveWhitespace ( ) ) return true ; el = el . parent ( ) ; i ++ ; } while ( i < 6 && el != null ) ; } return false ; }
--------------------------------------------------
