void pushActiveFormattingElements ( Element in ) { int numSeen = 0 ; for ( int pos = formattingElements . size ( ) - 1 ; pos >= 0 ; pos -- ) { Element el = formattingElements . get ( pos ) ; if ( el == null ) break ; if ( isSameFormattingElement ( in , el ) ) numSeen ++ ; if ( numSeen == 3 ) { formattingElements . remove ( pos ) ; break ; } } formattingElements . add ( in ) ; }
--------------------------------------------------
public Whitelist addEnforcedAttribute ( String tag , String attribute , String value ) { Validate . notEmpty ( tag ) ; Validate . notEmpty ( attribute ) ; Validate . notEmpty ( value ) ; TagName tagName = TagName . valueOf ( tag ) ; tagNames . add ( tagName ) ; AttributeKey attrKey = AttributeKey . valueOf ( attribute ) ; AttributeValue attrVal = AttributeValue . valueOf ( value ) ; if ( enforcedAttributes . containsKey ( tagName ) ) { enforcedAttributes . get ( tagName ) . put ( attrKey , attrVal ) ; } else { Map < AttributeKey , AttributeValue > attrMap = new HashMap < > ( ) ; attrMap . put ( attrKey , attrVal ) ; enforcedAttributes . put ( tagName , attrMap ) ; } return this ; }
--------------------------------------------------
private static void appendEncoded ( Appendable accum , EscapeMode escapeMode , int codePoint ) throws IOException { final String name = escapeMode . nameForCodepoint ( codePoint ) ; if ( name != emptyName ) accum . append ( '&' ) . append ( name ) . append ( ';' ) ; else accum . append ( "&#x" ) . append ( Integer . toHexString ( codePoint ) ) . append ( ';' ) ; }
--------------------------------------------------
public T removeCookie ( String name ) { Validate . notEmpty ( name , "cookie name must not be empty" ) ; cookies . remove ( name ) ; return ( T ) this ; }
--------------------------------------------------
void processResponseHeaders ( Map < String , List < String >> resHeaders ) { for ( Map . Entry < String , List < String >> entry : resHeaders . entrySet ( ) ) { String name = entry . getKey ( ) ; if ( name == null ) continue ; List < String > values = entry . getValue ( ) ; if ( name . equalsIgnoreCase ( "set-cookie" ) ) { for ( String value : values ) { if ( value == null ) continue ; TokenQueue cd = new TokenQueue ( value ) ; String cookieName = cd . chompTo ( "=" ) . trim ( ) ; String cookieVal = cd . consumeTo ( ";" ) . trim ( ) ; if ( cookieName . length ( ) > 0 ) cookie ( cookieName , cookieVal ) ; } } for ( String value : values ) { addHeader ( name , value ) ; } } }
--------------------------------------------------
public void remove ( String key ) { int i = indexOfKey ( key ) ; if ( i != NotFound ) remove ( i ) ; }
--------------------------------------------------
void read ( Tokeniser t , CharacterReader r ) { if ( r . matchesLetter ( ) ) { String name = r . consumeLetterSequence ( ) ; t . tagPending . appendTagName ( name ) ; t . dataBuffer . append ( name ) ; return ; } char c = r . consume ( ) ; switch ( c ) { case '\t' : case '\n' : case '\r' : case '\f' : case ' ' : if ( t . isAppropriateEndTagToken ( ) ) t . transition ( BeforeAttributeName ) ; else anythingElse ( t , r ) ; break ; case '/' : if ( t . isAppropriateEndTagToken ( ) ) t . transition ( SelfClosingStartTag ) ; else anythingElse ( t , r ) ; break ; case '>' : if ( t . isAppropriateEndTagToken ( ) ) { t . emitTagPending ( ) ; t . transition ( Data ) ; } else anythingElse ( t , r ) ; break ; default : anythingElse ( t , r ) ; } }
--------------------------------------------------
private void remove ( int index ) { Validate . isFalse ( index >= size ) ; int shifted = size - index - 1 ; if ( shifted > 0 ) { System . arraycopy ( keys , index + 1 , keys , index , shifted ) ; System . arraycopy ( vals , index + 1 , vals , index , shifted ) ; } size -- ; keys [ size ] = null ; vals [ size ] = null ; }
--------------------------------------------------
public boolean matches ( Element root , Element element ) { final Element p = element . parent ( ) ; return p != null && ! ( p instanceof Document ) && element . elementSiblingIndex ( ) == p . children ( ) . size ( ) - 1 ; }
--------------------------------------------------
void read ( Tokeniser t , CharacterReader r ) { if ( r . matches ( '/' ) ) { t . createTempBuffer ( ) ; t . advanceTransition ( RCDATAEndTagOpen ) ; } else if ( r . matchesLetter ( ) && t . appropriateEndTagName ( ) != null && ! r . containsIgnoreCase ( "</" + t . appropriateEndTagName ( ) ) ) { t . tagPending = t . createTagPending ( false ) . name ( t . appropriateEndTagName ( ) ) ; t . emitTagPending ( ) ; r . unconsume ( ) ; t . transition ( Data ) ; } else { t . emit ( "<" ) ; t . transition ( Rcdata ) ; } }
--------------------------------------------------
