boolean removeFromStack ( Element el ) { for ( int pos = stack . size ( ) - 1 ; pos >= 0 ; pos -- ) { Element next = stack . get ( pos ) ; if ( next == el ) { stack . remove ( pos ) ; return true ; } } return false ; }
--------------------------------------------------
void read ( Tokeniser t , CharacterReader r ) { String data = r . consumeTo ( "]]>" ) ; t . dataBuffer . append ( data ) ; if ( r . matchConsume ( "]]>" ) || r . isEmpty ( ) ) { t . emit ( new Token . CData ( t . dataBuffer . toString ( ) ) ) ; t . transition ( Data ) ; } }
--------------------------------------------------
void read ( Tokeniser t , CharacterReader r ) { char c = r . consume ( ) ; switch ( c ) { case '\t' : case '\n' : case '\r' : case '\f' : case ' ' : break ; case '/' : t . transition ( SelfClosingStartTag ) ; break ; case '<' : t . error ( this ) ; r . unconsume ( ) ; case '>' : t . emitTagPending ( ) ; t . transition ( Data ) ; break ; case nullChar : t . error ( this ) ; t . tagPending . newAttribute ( ) ; r . unconsume ( ) ; t . transition ( AttributeName ) ; break ; case eof : t . eofError ( this ) ; t . transition ( Data ) ; break ; case '"' : case ''' : case '=' : t . error ( this ) ; t . tagPending . newAttribute ( ) ; t . tagPending . appendAttributeName ( c ) ; t . transition ( AttributeName ) ; break ; default : t . tagPending . newAttribute ( ) ; r . unconsume ( ) ; t . transition ( AttributeName ) ; } }
--------------------------------------------------
private void setupFromConnection ( HttpURLConnection conn , HttpConnection . Response previousResponse ) throws IOException { this . conn = conn ; method = Method . valueOf ( conn . getRequestMethod ( ) ) ; url = conn . getURL ( ) ; statusCode = conn . getResponseCode ( ) ; statusMessage = conn . getResponseMessage ( ) ; contentType = conn . getContentType ( ) ; Map < String , List < String >> resHeaders = createHeaderMap ( conn ) ; processResponseHeaders ( resHeaders ) ; if ( previousResponse != null ) { for ( Map . Entry < String , String > prevCookie : previousResponse . cookies ( ) . entrySet ( ) ) { if ( ! hasCookie ( prevCookie . getKey ( ) ) ) cookie ( prevCookie . getKey ( ) , prevCookie . getValue ( ) ) ; } previousResponse . safeClose ( ) ; } }
--------------------------------------------------
public boolean matches ( Element root , Element element ) { final Element p = element . parent ( ) ; return p != null && ! ( p instanceof Document ) && element . elementSiblingIndex ( ) == 0 ; }
--------------------------------------------------
void read ( Tokeniser t , CharacterReader r ) { switch ( r . current ( ) ) { case nullChar : t . error ( this ) ; r . advance ( ) ; t . emit ( replacementChar ) ; break ; case eof : t . emit ( new Token . EOF ( ) ) ; break ; default : String data = r . consumeTo ( nullChar ) ; t . emit ( data ) ; break ; } }
--------------------------------------------------
void read ( Tokeniser t , CharacterReader r ) { char c = r . consume ( ) ; switch ( c ) { case '\t' : case '\n' : case '\r' : case '\f' : case ' ' : break ; case '"' : t . transition ( AttributeValue_doubleQuoted ) ; break ; case '&' : r . unconsume ( ) ; t . transition ( AttributeValue_unquoted ) ; break ; case ''' : t . transition ( AttributeValue_singleQuoted ) ; break ; case nullChar : t . error ( this ) ; t . tagPending . appendAttributeValue ( replacementChar ) ; t . transition ( AttributeValue_unquoted ) ; break ; case eof : t . eofError ( this ) ; t . emitTagPending ( ) ; t . transition ( Data ) ; break ; case '>' : t . error ( this ) ; t . emitTagPending ( ) ; t . transition ( Data ) ; break ; case '<' : case '=' : case '`' : t . error ( this ) ; t . tagPending . appendAttributeValue ( c ) ; t . transition ( AttributeValue_unquoted ) ; break ; default : r . unconsume ( ) ; t . transition ( AttributeValue_unquoted ) ; } }
--------------------------------------------------
void read ( Tokeniser t , CharacterReader r ) { if ( r . matchesLetter ( ) ) { t . createTagPending ( false ) ; t . tagPending . appendTagName ( r . current ( ) ) ; t . dataBuffer . append ( r . current ( ) ) ; t . advanceTransition ( RCDATAEndTagName ) ; } else { t . emit ( "</" ) ; t . transition ( Rcdata ) ; } }
--------------------------------------------------
String consumeToAnySorted ( final char ... chars ) { bufferUp ( ) ; int pos = bufPos ; final int start = pos ; final int remaining = bufLength ; final char [ ] val = charBuf ; while ( pos < remaining ) { if ( Arrays . binarySearch ( chars , val [ pos ] ) >= 0 ) break ; pos ++ ; } bufPos = pos ; return bufPos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : "" ; }
--------------------------------------------------
public boolean matchesStartTag ( ) { return ( remainingLength ( ) >= 2 && queue . charAt ( pos ) == '<' && Character . isLetter ( queue . charAt ( pos + 1 ) ) ) ; }
--------------------------------------------------
