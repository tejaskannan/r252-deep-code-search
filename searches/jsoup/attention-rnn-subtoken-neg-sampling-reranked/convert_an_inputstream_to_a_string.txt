String unescapeEntities ( boolean inAttribute ) { StringBuilder builder = StringUtil . borrowBuilder ( ) ; while ( ! reader . isEmpty ( ) ) { builder . append ( reader . consumeTo ( '&' ) ) ; if ( reader . matches ( '&' ) ) { reader . consume ( ) ; int [ ] c = consumeCharacterReference ( null , inAttribute ) ; if ( c == null || c . length == 0 ) builder . append ( '&' ) ; else { builder . appendCodePoint ( c [ 0 ] ) ; if ( c . length == 2 ) builder . appendCodePoint ( c [ 1 ] ) ; } } } return StringUtil . releaseBuilder ( builder ) ; }
--------------------------------------------------
private Element findFirstElementByTagName ( String tag , Node node ) { if ( node . nodeName ( ) . equals ( tag ) ) return ( Element ) node ; else { int size = node . childNodeSize ( ) ; for ( int i = 0 ; i < size ; i ++ ) { Element found = findFirstElementByTagName ( tag , node . childNode ( i ) ) ; if ( found != null ) return found ; } } return null ; }
--------------------------------------------------
public boolean matches ( Element root , Element element ) { return ! value . equalsIgnoreCase ( element . attr ( key ) ) ; }
--------------------------------------------------
public boolean matches ( Element root , Element element ) { return ( element . tagName ( ) . equalsIgnoreCase ( tagName ) ) ; }
--------------------------------------------------
public void convert ( org . jsoup . nodes . Document in , Document out ) { if ( ! StringUtil . isBlank ( in . location ( ) ) ) out . setDocumentURI ( in . location ( ) ) ; org . jsoup . nodes . Element rootEl = in . child ( 0 ) ; NodeTraversor . traverse ( new W3CBuilder ( out ) , rootEl ) ; }
--------------------------------------------------
public boolean hasSameValue ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; return this . outerHtml ( ) . equals ( ( ( Node ) o ) . outerHtml ( ) ) ; }
--------------------------------------------------
public static void appendNormalisedWhitespace ( StringBuilder accum , String string , boolean stripLeading ) { boolean lastWasWhite = false ; boolean reachedNonWhite = false ; int len = string . length ( ) ; int c ; for ( int i = 0 ; i < len ; i += Character . charCount ( c ) ) { c = string . codePointAt ( i ) ; if ( isActuallyWhitespace ( c ) ) { if ( ( stripLeading && ! reachedNonWhite ) || lastWasWhite ) continue ; accum . append ( ' ' ) ; lastWasWhite = true ; } else if ( ! isInvisibleChar ( c ) ) { accum . appendCodePoint ( c ) ; lastWasWhite = false ; reachedNonWhite = true ; } } }
--------------------------------------------------
public boolean matches ( Element root , Element element ) { return lowerCase ( element . data ( ) ) . contains ( searchText ) ; }
--------------------------------------------------
private void append ( String text ) { if ( text . startsWith ( "\n" ) ) width = 0 ; if ( text . equals ( " " ) && ( accum . length ( ) == 0 || StringUtil . in ( accum . substring ( accum . length ( ) - 1 ) , " " , "\n" ) ) ) return ; if ( text . length ( ) + width > maxWidth ) { String words [ ] = text . split ( "\s+" ) ; for ( int i = 0 ; i < words . length ; i ++ ) { String word = words [ i ] ; boolean last = i == words . length - 1 ; if ( ! last ) word = word + " " ; if ( word . length ( ) + width > maxWidth ) { accum . append ( "\n" ) . append ( word ) ; width = word . length ( ) ; } else { accum . append ( word ) ; width += word . length ( ) ; } } } else { accum . append ( text ) ; width += text . length ( ) ; } }
--------------------------------------------------
boolean currentNodeInHtmlNS ( ) { return true ; }
--------------------------------------------------
