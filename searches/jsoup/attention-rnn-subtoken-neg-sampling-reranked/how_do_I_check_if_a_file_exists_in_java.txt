private Map . Entry < String , List < String >> scanHeaders ( String name ) { String lc = lowerCase ( name ) ; for ( Map . Entry < String , List < String >> entry : headers . entrySet ( ) ) { if ( lowerCase ( entry . getKey ( ) ) . equals ( lc ) ) return entry ; } return null ; }
--------------------------------------------------
public boolean matches ( Element root , Element element ) { return ( id . equals ( element . id ( ) ) ) ; }
--------------------------------------------------
public boolean matches ( Element root , Element element ) { if ( root == element ) return false ; Element parent = element . parent ( ) ; while ( true ) { if ( evaluator . matches ( root , parent ) ) return true ; if ( parent == root ) break ; parent = parent . parent ( ) ; } return false ; }
--------------------------------------------------
public static Evaluator parse ( String query ) { try { QueryParser p = new QueryParser ( query ) ; return p . parse ( ) ; } catch ( IllegalArgumentException e ) { throw new Selector . SelectorParseException ( e . getMessage ( ) ) ; } }
--------------------------------------------------
boolean matchConsumeIgnoreCase ( String seq ) { if ( matchesIgnoreCase ( seq ) ) { bufPos += seq . length ( ) ; return true ; } else { return false ; } }
--------------------------------------------------
final void finaliseTag ( ) { if ( pendingAttributeName != null ) { newAttribute ( ) ; } }
--------------------------------------------------
public static void main ( String [ ] args ) throws IOException { Validate . isTrue ( args . length == 1 , "usage: supply url to fetch" ) ; String url = args [ 0 ] ; print ( "fetching %s..." , url ) ; Document doc = Jsoup . connect ( url ) . get ( ) ; Elements links = doc . select ( "a[href]" ) ; Elements media = doc . select ( "[src]" ) ; Elements imports = doc . select ( "link[href]" ) ; print ( "
media: (%d)" , media . size ( ) ) ; for ( Element src : media ) { if ( src . tagName ( ) . equals ( "img" ) ) print ( " * %s: <%s> %sx%s (%s)" , src . tagName ( ) , src . attr ( "abs:src" ) , src . attr ( "width" ) , src . attr ( "height" ) , trim ( src . attr ( "alt" ) , 20 ) ) ; else print ( " * %s: <%s>" , src . tagName ( ) , src . attr ( "abs:src" ) ) ; } print ( "
imports: (%d)" , imports . size ( ) ) ; for ( Element link : imports ) { print ( " * %s <%s> (%s)" , link . tagName ( ) , link . attr ( "abs:href" ) , link . attr ( "rel" ) ) ; } print ( "
links: (%d)" , links . size ( ) ) ; for ( Element link : links ) { print ( " * a: <%s>  (%s)" , link . attr ( "abs:href" ) , trim ( link . text ( ) , 35 ) ) ; } }
--------------------------------------------------
void clearFormattingElementsToLastMarker ( ) { while ( ! formattingElements . isEmpty ( ) ) { Element el = removeLastFormattingElement ( ) ; if ( el == null ) break ; } }
--------------------------------------------------
public String consumeToAny ( String ... seq ) { int start = pos ; while ( ! isEmpty ( ) && ! matchesAny ( seq ) ) { pos ++ ; } return queue . substring ( start , pos ) ; }
--------------------------------------------------
public T removeCookie ( String name ) { Validate . notEmpty ( name , "cookie name must not be empty" ) ; cookies . remove ( name ) ; return ( T ) this ; }
--------------------------------------------------
