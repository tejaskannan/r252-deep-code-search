public void removeIgnoreCase ( String key ) { int i = indexOfKeyIgnoreCase ( key ) ; if ( i != NotFound ) remove ( i ) ; }
--------------------------------------------------
public T addHeader ( String name , String value ) { Validate . notEmpty ( name ) ; value = value == null ? "" : value ; List < String > values = headers ( name ) ; if ( values . isEmpty ( ) ) { values = new ArrayList < > ( ) ; headers . put ( name , values ) ; } values . add ( fixHeaderEncoding ( value ) ) ; return ( T ) this ; }
--------------------------------------------------
void insert ( Token . Comment commentToken ) { Comment comment = new Comment ( commentToken . getData ( ) ) ; Node insert = comment ; if ( commentToken . bogus && comment . isXmlDeclaration ( ) ) { XmlDeclaration decl = comment . asXmlDeclaration ( ) ; if ( decl != null ) insert = decl ; } insertNode ( insert ) ; }
--------------------------------------------------
private static void handleDataEndTag ( Tokeniser t , CharacterReader r , TokeniserState elseTransition ) { if ( r . matchesLetter ( ) ) { String name = r . consumeLetterSequence ( ) ; t . tagPending . appendTagName ( name ) ; t . dataBuffer . append ( name ) ; return ; } boolean needsExitTransition = false ; if ( t . isAppropriateEndTagToken ( ) && ! r . isEmpty ( ) ) { char c = r . consume ( ) ; switch ( c ) { case '\t' : case '\n' : case '\r' : case '\f' : case ' ' : t . transition ( BeforeAttributeName ) ; break ; case '/' : t . transition ( SelfClosingStartTag ) ; break ; case '>' : t . emitTagPending ( ) ; t . transition ( Data ) ; break ; default : t . dataBuffer . append ( c ) ; needsExitTransition = true ; } } else { needsExitTransition = true ; } if ( needsExitTransition ) { t . emit ( "</" + t . dataBuffer . toString ( ) ) ; t . transition ( elseTransition ) ; } }
--------------------------------------------------
void read ( Tokeniser t , CharacterReader r ) { char c = r . consume ( ) ; switch ( c ) { case '>' : t . tagPending . selfClosing = true ; t . emitTagPending ( ) ; t . transition ( Data ) ; break ; case eof : t . eofError ( this ) ; t . transition ( Data ) ; break ; default : t . error ( this ) ; r . unconsume ( ) ; t . transition ( BeforeAttributeName ) ; } }
--------------------------------------------------
public void remove ( ) { Validate . notNull ( parentNode ) ; parentNode . removeChild ( this ) ; }
--------------------------------------------------
public Node wrap ( String html ) { Validate . notEmpty ( html ) ; Element context = parent ( ) instanceof Element ? ( Element ) parent ( ) : null ; List < Node > wrapChildren = NodeUtils . parser ( this ) . parseFragmentInput ( html , context , baseUri ( ) ) ; Node wrapNode = wrapChildren . get ( 0 ) ; if ( ! ( wrapNode instanceof Element ) ) return null ; Element wrap = ( Element ) wrapNode ; Element deepest = getDeepChild ( wrap ) ; parentNode . replaceChild ( this , wrap ) ; deepest . addChildren ( this ) ; if ( wrapChildren . size ( ) > 0 ) { for ( int i = 0 ; i < wrapChildren . size ( ) ; i ++ ) { Node remainder = wrapChildren . get ( i ) ; remainder . parentNode . removeChild ( remainder ) ; wrap . appendChild ( remainder ) ; } } return this ; }
--------------------------------------------------
void read ( Tokeniser t , CharacterReader r ) { char c = r . consume ( ) ; switch ( c ) { case '\t' : case '\n' : case '\r' : case '\f' : case ' ' : t . transition ( BeforeAttributeName ) ; break ; case '/' : t . transition ( SelfClosingStartTag ) ; break ; case '>' : t . emitTagPending ( ) ; t . transition ( Data ) ; break ; case eof : t . eofError ( this ) ; t . transition ( Data ) ; break ; default : t . error ( this ) ; r . unconsume ( ) ; t . transition ( BeforeAttributeName ) ; } }
--------------------------------------------------
void read ( Tokeniser t , CharacterReader r ) { if ( r . matches ( '/' ) ) { t . createTempBuffer ( ) ; t . advanceTransition ( RawtextEndTagOpen ) ; } else { t . emit ( '<' ) ; t . transition ( Rawtext ) ; } }
--------------------------------------------------
void read ( Tokeniser t , CharacterReader r ) { char c = r . current ( ) ; switch ( c ) { case '-' : t . advanceTransition ( CommentEndDash ) ; break ; case nullChar : t . error ( this ) ; r . advance ( ) ; t . commentPending . data . append ( replacementChar ) ; break ; case eof : t . eofError ( this ) ; t . emitCommentPending ( ) ; t . transition ( Data ) ; break ; default : t . commentPending . data . append ( r . consumeToAny ( '-' , nullChar ) ) ; } }
--------------------------------------------------
