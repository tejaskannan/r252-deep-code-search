protected List < Node > ensureChildNodes ( ) { if ( childNodes == EMPTY_NODES ) { childNodes = new NodeList ( this , 4 ) ; } return childNodes ; }
--------------------------------------------------
private static void handleRawtext ( Token . StartTag startTag , HtmlTreeBuilder tb ) { tb . tokeniser . transition ( TokeniserState . Rawtext ) ; tb . markInsertionMode ( ) ; tb . transition ( Text ) ; tb . insert ( startTag ) ; }
--------------------------------------------------
boolean process ( Token t , HtmlTreeBuilder tb ) { if ( t . isStartTag ( ) && StringUtil . in ( t . asStartTag ( ) . normalName ( ) , "caption" , "table" , "tbody" , "tfoot" , "thead" , "tr" , "td" , "th" ) ) { tb . error ( this ) ; tb . processEndTag ( "select" ) ; return tb . process ( t ) ; } else if ( t . isEndTag ( ) && StringUtil . in ( t . asEndTag ( ) . normalName ( ) , "caption" , "table" , "tbody" , "tfoot" , "thead" , "tr" , "td" , "th" ) ) { tb . error ( this ) ; if ( tb . inTableScope ( t . asEndTag ( ) . normalName ( ) ) ) { tb . processEndTag ( "select" ) ; return ( tb . process ( t ) ) ; } else return false ; } else { return tb . process ( t , InSelect ) ; } }
--------------------------------------------------
void insert ( Token . Character token ) { final String data = token . getData ( ) ; insertNode ( token . isCData ( ) ? new CDataNode ( data ) : new TextNode ( data ) ) ; }
--------------------------------------------------
public static void main ( String ... args ) throws IOException { Validate . isTrue ( args . length == 1 || args . length == 2 , "usage: java -cp jsoup.jar org.jsoup.examples.htmltoplaintext url [selector]" ) ; final String url = args [ 0 ] ; final String selector = args . length == 2 ? args [ 1 ] : null ; Document doc = Jsoup . connect ( url ) . userAgent ( userAgent ) . timeout ( timeout ) . get ( ) ; HtmlToPlainText formatter = new HtmlToPlainText ( ) ; if ( selector != null ) { Elements elements = doc . select ( selector ) ; for ( Element element : elements ) { String plainText = formatter . getPlainText ( element ) ; System . out . println ( plainText ) ; } } else { String plainText = formatter . getPlainText ( doc ) ; System . out . println ( plainText ) ; } }
--------------------------------------------------
boolean process ( Token t , HtmlTreeBuilder tb ) { if ( t . isDoctype ( ) ) { tb . error ( this ) ; } else if ( t . isStartTag ( ) && t . asStartTag ( ) . normalName ( ) . equals ( "html" ) ) { return tb . process ( t , InBody ) ; } else if ( t . isEndTag ( ) && t . asEndTag ( ) . normalName ( ) . equals ( "noscript" ) ) { tb . pop ( ) ; tb . transition ( InHead ) ; } else if ( isWhitespace ( t ) || t . isComment ( ) || ( t . isStartTag ( ) && StringUtil . in ( t . asStartTag ( ) . normalName ( ) , "basefont" , "bgsound" , "link" , "meta" , "noframes" , "style" ) ) ) { return tb . process ( t , InHead ) ; } else if ( t . isEndTag ( ) && t . asEndTag ( ) . normalName ( ) . equals ( "br" ) ) { return anythingElse ( t , tb ) ; } else if ( ( t . isStartTag ( ) && StringUtil . in ( t . asStartTag ( ) . normalName ( ) , "head" , "noscript" ) ) || t . isEndTag ( ) ) { tb . error ( this ) ; return false ; } else { return anythingElse ( t , tb ) ; } return true ; }
--------------------------------------------------
private Elements nextElementSiblings ( boolean next ) { Elements els = new Elements ( ) ; if ( parentNode == null ) return els ; els . add ( this ) ; return next ? els . nextAll ( ) : els . prevAll ( ) ; }
--------------------------------------------------
void read ( Tokeniser t , CharacterReader r ) { char c = r . consume ( ) ; switch ( c ) { case '\t' : case '\n' : case '\r' : case '\f' : case ' ' : break ; case '>' : t . emitDoctypePending ( ) ; t . transition ( Data ) ; break ; case eof : t . eofError ( this ) ; t . doctypePending . forceQuirks = true ; t . emitDoctypePending ( ) ; t . transition ( Data ) ; break ; default : t . error ( this ) ; t . transition ( BogusDoctype ) ; } }
--------------------------------------------------
public void add ( int index , E element ) { onContentsChanged ( ) ; super . add ( index , element ) ; }
--------------------------------------------------
void read ( Tokeniser t , CharacterReader r ) { if ( r . isEmpty ( ) ) { t . eofError ( this ) ; t . transition ( Data ) ; return ; } char c = r . consume ( ) ; switch ( c ) { case '-' : t . emit ( c ) ; t . transition ( ScriptDataEscapedDashDash ) ; break ; case '<' : t . transition ( ScriptDataEscapedLessthanSign ) ; break ; case nullChar : t . error ( this ) ; t . emit ( replacementChar ) ; t . transition ( ScriptDataEscaped ) ; break ; default : t . emit ( c ) ; t . transition ( ScriptDataEscaped ) ; } }
--------------------------------------------------
