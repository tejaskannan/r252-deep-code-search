void read ( Tokeniser t , CharacterReader r ) { if ( r . matchesLetter ( ) ) { t . createTagPending ( false ) ; t . tagPending . appendTagName ( r . current ( ) ) ; t . dataBuffer . append ( r . current ( ) ) ; t . advanceTransition ( ScriptDataEscapedEndTagName ) ; } else { t . emit ( "</" ) ; t . transition ( ScriptDataEscaped ) ; } }
--------------------------------------------------
public boolean matches ( Element root , Element element ) { final Element p = element . parent ( ) ; return p != null && ! ( p instanceof Document ) && element . siblingElements ( ) . size ( ) == 0 ; }
--------------------------------------------------
private void setupFromConnection ( HttpURLConnection conn , HttpConnection . Response previousResponse ) throws IOException { this . conn = conn ; method = Method . valueOf ( conn . getRequestMethod ( ) ) ; url = conn . getURL ( ) ; statusCode = conn . getResponseCode ( ) ; statusMessage = conn . getResponseMessage ( ) ; contentType = conn . getContentType ( ) ; Map < String , List < String >> resHeaders = createHeaderMap ( conn ) ; processResponseHeaders ( resHeaders ) ; if ( previousResponse != null ) { for ( Map . Entry < String , String > prevCookie : previousResponse . cookies ( ) . entrySet ( ) ) { if ( ! hasCookie ( prevCookie . getKey ( ) ) ) cookie ( prevCookie . getKey ( ) , prevCookie . getValue ( ) ) ; } previousResponse . safeClose ( ) ; } }
--------------------------------------------------
void read ( Tokeniser t , CharacterReader r ) { String value = r . consumeToAny ( attributeDoubleValueCharsSorted ) ; if ( value . length ( ) > 0 ) t . tagPending . appendAttributeValue ( value ) ; else t . tagPending . setEmptyAttributeValue ( ) ; char c = r . consume ( ) ; switch ( c ) { case '"' : t . transition ( AfterAttributeValue_quoted ) ; break ; case '&' : int [ ] ref = t . consumeCharacterReference ( '"' , true ) ; if ( ref != null ) t . tagPending . appendAttributeValue ( ref ) ; else t . tagPending . appendAttributeValue ( '&' ) ; break ; case nullChar : t . error ( this ) ; t . tagPending . appendAttributeValue ( replacementChar ) ; break ; case eof : t . eofError ( this ) ; t . transition ( Data ) ; break ; default : t . tagPending . appendAttributeValue ( c ) ; } }
--------------------------------------------------
static Document parseInputStream ( InputStream input , String charsetName , String baseUri , Parser parser ) throws IOException { if ( input == null ) return new Document ( baseUri ) ; input = ConstrainableInputStream . wrap ( input , bufferSize , 0 ) ; Document doc = null ; boolean fullyRead = false ; input . mark ( bufferSize ) ; ByteBuffer firstBytes = readToByteBuffer ( input , firstReadBufferSize - 1 ) ; fullyRead = input . read ( ) == - 1 ; input . reset ( ) ; BomCharset bomCharset = detectCharsetFromBom ( firstBytes ) ; if ( bomCharset != null ) charsetName = bomCharset . charset ; if ( charsetName == null ) { String docData = Charset . forName ( defaultCharset ) . decode ( firstBytes ) . toString ( ) ; doc = parser . parseInput ( docData , baseUri ) ; Elements metaElements = doc . select ( "meta[http-equiv=content-type], meta[charset]" ) ; String foundCharset = null ; for ( Element meta : metaElements ) { if ( meta . hasAttr ( "http-equiv" ) ) foundCharset = getCharsetFromContentType ( meta . attr ( "content" ) ) ; if ( foundCharset == null && meta . hasAttr ( "charset" ) ) foundCharset = meta . attr ( "charset" ) ; if ( foundCharset != null ) break ; } if ( foundCharset == null && doc . childNodeSize ( ) > 0 ) { Node first = doc . childNode ( 0 ) ; XmlDeclaration decl = null ; if ( first instanceof XmlDeclaration ) decl = ( XmlDeclaration ) first ; else if ( first instanceof Comment ) { Comment comment = ( Comment ) first ; if ( comment . isXmlDeclaration ( ) ) decl = comment . asXmlDeclaration ( ) ; } if ( decl != null ) { if ( decl . name ( ) . equalsIgnoreCase ( "xml" ) ) foundCharset = decl . attr ( "encoding" ) ; } } foundCharset = validateCharset ( foundCharset ) ; if ( foundCharset != null && ! foundCharset . equalsIgnoreCase ( defaultCharset ) ) { foundCharset = foundCharset . trim ( ) . replaceAll ( "["']" , "" ) ; charsetName = foundCharset ; doc = null ; } else if ( ! fullyRead ) { doc = null ; } } else { Validate . notEmpty ( charsetName , "must set charset arg to character set of file to parse. set to null to attempt to detect from html" ) ; } if ( doc == null ) { if ( charsetName == null ) charsetName = defaultCharset ; BufferedReader reader = new BufferedReader ( new InputStreamReader ( input , charsetName ) , bufferSize ) ; if ( bomCharset != null && bomCharset . offset ) reader . skip ( 1 ) ; try { doc = parser . parseInput ( reader , baseUri ) ; } catch ( UncheckedIOException e ) { throw e . ioException ( ) ; } Charset charset = Charset . forName ( charsetName ) ; doc . outputSettings ( ) . charset ( charset ) ; if ( ! charset . canEncode ( ) ) { doc . charset ( Charset . forName ( defaultCharset ) ) ; } } input . close ( ) ; return doc ; }
--------------------------------------------------
void read ( Tokeniser t , CharacterReader r ) { String value = r . consumeToAny ( attributeSingleValueCharsSorted ) ; if ( value . length ( ) > 0 ) t . tagPending . appendAttributeValue ( value ) ; else t . tagPending . setEmptyAttributeValue ( ) ; char c = r . consume ( ) ; switch ( c ) { case ''' : t . transition ( AfterAttributeValue_quoted ) ; break ; case '&' : int [ ] ref = t . consumeCharacterReference ( ''' , true ) ; if ( ref != null ) t . tagPending . appendAttributeValue ( ref ) ; else t . tagPending . appendAttributeValue ( '&' ) ; break ; case nullChar : t . error ( this ) ; t . tagPending . appendAttributeValue ( replacementChar ) ; break ; case eof : t . eofError ( this ) ; t . transition ( Data ) ; break ; default : t . tagPending . appendAttributeValue ( c ) ; } }
--------------------------------------------------
void read ( Tokeniser t , CharacterReader r ) { r . unconsume ( ) ; Token . Comment comment = new Token . Comment ( ) ; comment . bogus = true ; comment . data . append ( r . consumeTo ( '>' ) ) ; t . emit ( comment ) ; t . advanceTransition ( Data ) ; }
--------------------------------------------------
void read ( Tokeniser t , CharacterReader r ) { switch ( r . current ( ) ) { case nullChar : t . error ( this ) ; r . advance ( ) ; t . emit ( replacementChar ) ; break ; case eof : t . emit ( new Token . EOF ( ) ) ; break ; default : String data = r . consumeTo ( nullChar ) ; t . emit ( data ) ; break ; } }
--------------------------------------------------
private int copySafeNodes ( Element source , Element dest ) { CleaningVisitor cleaningVisitor = new CleaningVisitor ( source , dest ) ; NodeTraversor . traverse ( cleaningVisitor , source ) ; return cleaningVisitor . numDiscarded ; }
--------------------------------------------------
boolean removeFromStack ( Element el ) { for ( int pos = stack . size ( ) - 1 ; pos >= 0 ; pos -- ) { Element next = stack . get ( pos ) ; if ( next == el ) { stack . remove ( pos ) ; return true ; } } return false ; }
--------------------------------------------------
