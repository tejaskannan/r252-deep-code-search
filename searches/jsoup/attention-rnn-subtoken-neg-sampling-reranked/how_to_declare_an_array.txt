public static void filter ( NodeFilter filter , Elements elements ) { Validate . notNull ( filter ) ; Validate . notNull ( elements ) ; for ( Element el : elements ) if ( filter ( filter , el ) == FilterResult . STOP ) break ; }
--------------------------------------------------
public void head ( org . jsoup . nodes . Node source , int depth ) { namespacesStack . push ( new HashMap < > ( namespacesStack . peek ( ) ) ) ; if ( source instanceof org . jsoup . nodes . Element ) { org . jsoup . nodes . Element sourceEl = ( org . jsoup . nodes . Element ) source ; String prefix = updateNamespaces ( sourceEl ) ; String namespace = namespacesStack . peek ( ) . get ( prefix ) ; String tagName = sourceEl . tagName ( ) ; Element el = namespace == null && tagName . contains ( ":" ) ? doc . createElementNS ( "" , tagName ) : doc . createElementNS ( namespace , tagName ) ; copyAttributes ( sourceEl , el ) ; if ( dest == null ) { doc . appendChild ( el ) ; } else { dest . appendChild ( el ) ; } dest = el ; } else if ( source instanceof org . jsoup . nodes . TextNode ) { org . jsoup . nodes . TextNode sourceText = ( org . jsoup . nodes . TextNode ) source ; Text text = doc . createTextNode ( sourceText . getWholeText ( ) ) ; dest . appendChild ( text ) ; } else if ( source instanceof org . jsoup . nodes . Comment ) { org . jsoup . nodes . Comment sourceComment = ( org . jsoup . nodes . Comment ) source ; Comment comment = doc . createComment ( sourceComment . getData ( ) ) ; dest . appendChild ( comment ) ; } else if ( source instanceof org . jsoup . nodes . DataNode ) { org . jsoup . nodes . DataNode sourceData = ( org . jsoup . nodes . DataNode ) source ; Text node = doc . createTextNode ( sourceData . getWholeData ( ) ) ; dest . appendChild ( node ) ; } else { } }
--------------------------------------------------
Tag setSelfClosing ( ) { selfClosing = true ; return this ; }
--------------------------------------------------
public Element shallowClone ( ) { return new Element ( tag , baseUri , attributes ) ; }
--------------------------------------------------
public Connection request ( Connection . Request request ) { req = request ; return this ; }
--------------------------------------------------
public Connection . Request postDataCharset ( String charset ) { Validate . notNull ( charset , "charset must not be null" ) ; if ( ! Charset . isSupported ( charset ) ) throw new IllegalCharsetNameException ( charset ) ; this . postDataCharset = charset ; return this ; }
--------------------------------------------------
private static void serialiseRequestUrl ( Connection . Request req ) throws IOException { URL in = req . url ( ) ; StringBuilder url = StringUtil . borrowBuilder ( ) ; boolean first = true ; url . append ( in . getProtocol ( ) ) . append ( "://" ) . append ( in . getAuthority ( ) ) . append ( in . getPath ( ) ) . append ( "?" ) ; if ( in . getQuery ( ) != null ) { url . append ( in . getQuery ( ) ) ; first = false ; } for ( Connection . KeyVal keyVal : req . data ( ) ) { Validate . isFalse ( keyVal . hasInputStream ( ) , "inputstream data not supported in url query string." ) ; if ( ! first ) url . append ( '&' ) ; else first = false ; url . append ( URLEncoder . encode ( keyVal . key ( ) , DataUtil . defaultCharset ) ) . append ( '=' ) . append ( URLEncoder . encode ( keyVal . value ( ) , DataUtil . defaultCharset ) ) ; } req . url ( new URL ( StringUtil . releaseBuilder ( url ) ) ) ; req . data ( ) . clear ( ) ; }
--------------------------------------------------
CharsetEncoder encoder ( ) { CharsetEncoder encoder = encoderThreadLocal . get ( ) ; return encoder != null ? encoder : prepareEncoder ( ) ; }
--------------------------------------------------
public String body ( ) { prepareByteData ( ) ; String body ; if ( charset == null ) body = Charset . forName ( DataUtil . defaultCharset ) . decode ( byteData ) . toString ( ) ; else body = Charset . forName ( charset ) . decode ( byteData ) . toString ( ) ; ( ( Buffer ) byteData ) . rewind ( ) ; return body ; }
--------------------------------------------------
protected void setParentNode ( Node parentNode ) { Validate . notNull ( parentNode ) ; if ( this . parentNode != null ) this . parentNode . removeChild ( this ) ; this . parentNode = parentNode ; }
--------------------------------------------------
