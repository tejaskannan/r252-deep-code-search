public static void main ( String ... args ) throws IOException { Validate . isTrue ( args . length == 1 || args . length == 2 , "usage: java -cp jsoup.jar org.jsoup.examples.htmltoplaintext url [selector]" ) ; final String url = args [ 0 ] ; final String selector = args . length == 2 ? args [ 1 ] : null ; Document doc = Jsoup . connect ( url ) . userAgent ( userAgent ) . timeout ( timeout ) . get ( ) ; HtmlToPlainText formatter = new HtmlToPlainText ( ) ; if ( selector != null ) { Elements elements = doc . select ( selector ) ; for ( Element element : elements ) { String plainText = formatter . getPlainText ( element ) ; System . out . println ( plainText ) ; } } else { String plainText = formatter . getPlainText ( doc ) ; System . out . println ( plainText ) ; } }
--------------------------------------------------
public void add ( int index , E element ) { onContentsChanged ( ) ; super . add ( index , element ) ; }
--------------------------------------------------
public W3CBuilder ( Document doc ) { this . doc = doc ; this . namespacesStack . push ( new HashMap < String , String > ( ) ) ; }
--------------------------------------------------
boolean process ( Token t , HtmlTreeBuilder tb ) { switch ( t . type ) { case Character : Token . Character c = t . asCharacter ( ) ; if ( c . getData ( ) . equals ( nullString ) ) { tb . error ( this ) ; return false ; } else { tb . insert ( c ) ; } break ; case Comment : tb . insert ( t . asComment ( ) ) ; break ; case Doctype : tb . error ( this ) ; return false ; case StartTag : Token . StartTag start = t . asStartTag ( ) ; String name = start . normalName ( ) ; if ( name . equals ( "html" ) ) return tb . process ( start , InBody ) ; else if ( name . equals ( "option" ) ) { if ( tb . currentElement ( ) . normalName ( ) . equals ( "option" ) ) tb . processEndTag ( "option" ) ; tb . insert ( start ) ; } else if ( name . equals ( "optgroup" ) ) { if ( tb . currentElement ( ) . normalName ( ) . equals ( "option" ) ) tb . processEndTag ( "option" ) ; else if ( tb . currentElement ( ) . normalName ( ) . equals ( "optgroup" ) ) tb . processEndTag ( "optgroup" ) ; tb . insert ( start ) ; } else if ( name . equals ( "select" ) ) { tb . error ( this ) ; return tb . processEndTag ( "select" ) ; } else if ( StringUtil . in ( name , "input" , "keygen" , "textarea" ) ) { tb . error ( this ) ; if ( ! tb . inSelectScope ( "select" ) ) return false ; tb . processEndTag ( "select" ) ; return tb . process ( start ) ; } else if ( name . equals ( "script" ) ) { return tb . process ( t , InHead ) ; } else { return anythingElse ( t , tb ) ; } break ; case EndTag : Token . EndTag end = t . asEndTag ( ) ; name = end . normalName ( ) ; switch ( name ) { case "optgroup" : if ( tb . currentElement ( ) . normalName ( ) . equals ( "option" ) && tb . aboveOnStack ( tb . currentElement ( ) ) != null && tb . aboveOnStack ( tb . currentElement ( ) ) . normalName ( ) . equals ( "optgroup" ) ) tb . processEndTag ( "option" ) ; if ( tb . currentElement ( ) . normalName ( ) . equals ( "optgroup" ) ) tb . pop ( ) ; else tb . error ( this ) ; break ; case "option" : if ( tb . currentElement ( ) . normalName ( ) . equals ( "option" ) ) tb . pop ( ) ; else tb . error ( this ) ; break ; case "select" : if ( ! tb . inSelectScope ( name ) ) { tb . error ( this ) ; return false ; } else { tb . popStackToClose ( name ) ; tb . resetInsertionMode ( ) ; } break ; default : return anythingElse ( t , tb ) ; } break ; case EOF : if ( ! tb . currentElement ( ) . normalName ( ) . equals ( "html" ) ) tb . error ( this ) ; break ; default : return anythingElse ( t , tb ) ; } return true ; }
--------------------------------------------------
boolean process ( Token t , HtmlTreeBuilder tb ) { if ( t . isStartTag ( ) && StringUtil . in ( t . asStartTag ( ) . normalName ( ) , "caption" , "table" , "tbody" , "tfoot" , "thead" , "tr" , "td" , "th" ) ) { tb . error ( this ) ; tb . processEndTag ( "select" ) ; return tb . process ( t ) ; } else if ( t . isEndTag ( ) && StringUtil . in ( t . asEndTag ( ) . normalName ( ) , "caption" , "table" , "tbody" , "tfoot" , "thead" , "tr" , "td" , "th" ) ) { tb . error ( this ) ; if ( tb . inTableScope ( t . asEndTag ( ) . normalName ( ) ) ) { tb . processEndTag ( "select" ) ; return ( tb . process ( t ) ) ; } else return false ; } else { return tb . process ( t , InSelect ) ; } }
--------------------------------------------------
private void insertNode ( Node node ) { if ( stack . size ( ) == 0 ) doc . appendChild ( node ) ; else if ( isFosterInserts ( ) ) insertInFosterParent ( node ) ; else currentElement ( ) . appendChild ( node ) ; if ( node instanceof Element && ( ( Element ) node ) . tag ( ) . isFormListed ( ) ) { if ( formElement != null ) formElement . addElement ( ( Element ) node ) ; } }
--------------------------------------------------
static Response execute ( Connection . Request req , Response previousResponse ) throws IOException { Validate . notNull ( req , "request must not be null" ) ; Validate . notNull ( req . url ( ) , "url must be specified to connect" ) ; String protocol = req . url ( ) . getProtocol ( ) ; if ( ! protocol . equals ( "http" ) && ! protocol . equals ( "https" ) ) throw new MalformedURLException ( "only http & https protocols supported" ) ; final boolean methodHasBody = req . method ( ) . hasBody ( ) ; final boolean hasRequestBody = req . requestBody ( ) != null ; if ( ! methodHasBody ) Validate . isFalse ( hasRequestBody , "cannot set a request body for http method " + req . method ( ) ) ; String mimeBoundary = null ; if ( req . data ( ) . size ( ) > 0 && ( ! methodHasBody || hasRequestBody ) ) serialiseRequestUrl ( req ) ; else if ( methodHasBody ) mimeBoundary = setOutputContentType ( req ) ; long startTime = System . nanoTime ( ) ; HttpURLConnection conn = createConnection ( req ) ; Response res ; try { conn . connect ( ) ; if ( conn . getDoOutput ( ) ) writePost ( req , conn . getOutputStream ( ) , mimeBoundary ) ; int status = conn . getResponseCode ( ) ; res = new Response ( previousResponse ) ; res . setupFromConnection ( conn , previousResponse ) ; res . req = req ; if ( res . hasHeader ( LOCATION ) && req . followRedirects ( ) ) { if ( status != HTTP_TEMP_REDIR ) { req . method ( Method . GET ) ; req . data ( ) . clear ( ) ; req . requestBody ( null ) ; req . removeHeader ( CONTENT_TYPE ) ; } String location = res . header ( LOCATION ) ; if ( location . startsWith ( "http:/" ) && location . charAt ( 6 ) != '/' ) location = location . substring ( 6 ) ; URL redir = StringUtil . resolve ( req . url ( ) , location ) ; req . url ( encodeUrl ( redir ) ) ; for ( Map . Entry < String , String > cookie : res . cookies . entrySet ( ) ) { req . cookie ( cookie . getKey ( ) , cookie . getValue ( ) ) ; } return execute ( req , res ) ; } if ( ( status < 200 || status >= 400 ) && ! req . ignoreHttpErrors ( ) ) throw new HttpStatusException ( "http error fetching url" , status , req . url ( ) . toString ( ) ) ; String contentType = res . contentType ( ) ; if ( contentType != null && ! req . ignoreContentType ( ) && ! contentType . startsWith ( "text/" ) && ! xmlContentTypeRxp . matcher ( contentType ) . matches ( ) ) throw new UnsupportedMimeTypeException ( "unhandled content type. must be text/*, application/xml, or application/xhtml+xml" , contentType , req . url ( ) . toString ( ) ) ; if ( contentType != null && xmlContentTypeRxp . matcher ( contentType ) . matches ( ) ) { if ( req instanceof HttpConnection . Request && ! ( ( Request ) req ) . parserDefined ) { req . parser ( Parser . xmlParser ( ) ) ; } } res . charset = DataUtil . getCharsetFromContentType ( res . contentType ) ; if ( conn . getContentLength ( ) != 0 && req . method ( ) != HEAD ) { res . bodyStream = null ; res . bodyStream = conn . getErrorStream ( ) != null ? conn . getErrorStream ( ) : conn . getInputStream ( ) ; if ( res . hasHeaderWithValue ( CONTENT_ENCODING , "gzip" ) ) { res . bodyStream = new GZIPInputStream ( res . bodyStream ) ; } else if ( res . hasHeaderWithValue ( CONTENT_ENCODING , "deflate" ) ) { res . bodyStream = new InflaterInputStream ( res . bodyStream , new Inflater ( true ) ) ; } res . bodyStream = ConstrainableInputStream . wrap ( res . bodyStream , DataUtil . bufferSize , req . maxBodySize ( ) ) . timeout ( startTime , req . timeout ( ) ) ; } else { res . byteData = DataUtil . emptyByteBuffer ( ) ; } } catch ( IOException e ) { conn . disconnect ( ) ; throw e ; } res . executed = true ; return res ; }
--------------------------------------------------
protected boolean process ( Token token ) { currentToken = token ; return this . state . process ( token , this ) ; }
--------------------------------------------------
protected List < Node > ensureChildNodes ( ) { if ( childNodes == EMPTY_NODES ) { childNodes = new NodeList ( this , 4 ) ; } return childNodes ; }
--------------------------------------------------
void eofError ( TokeniserState state ) { if ( errors . canAddError ( ) ) errors . add ( new ParseError ( reader . pos ( ) , "unexpectedly reached end of file (eof) in input state [%s]" , state ) ) ; }
--------------------------------------------------
