static Response execute ( Connection . Request req , Response previousResponse ) throws IOException { Validate . notNull ( req , "request must not be null" ) ; Validate . notNull ( req . url ( ) , "url must be specified to connect" ) ; String protocol = req . url ( ) . getProtocol ( ) ; if ( ! protocol . equals ( "http" ) && ! protocol . equals ( "https" ) ) throw new MalformedURLException ( "only http & https protocols supported" ) ; final boolean methodHasBody = req . method ( ) . hasBody ( ) ; final boolean hasRequestBody = req . requestBody ( ) != null ; if ( ! methodHasBody ) Validate . isFalse ( hasRequestBody , "cannot set a request body for http method " + req . method ( ) ) ; String mimeBoundary = null ; if ( req . data ( ) . size ( ) > 0 && ( ! methodHasBody || hasRequestBody ) ) serialiseRequestUrl ( req ) ; else if ( methodHasBody ) mimeBoundary = setOutputContentType ( req ) ; long startTime = System . nanoTime ( ) ; HttpURLConnection conn = createConnection ( req ) ; Response res ; try { conn . connect ( ) ; if ( conn . getDoOutput ( ) ) writePost ( req , conn . getOutputStream ( ) , mimeBoundary ) ; int status = conn . getResponseCode ( ) ; res = new Response ( previousResponse ) ; res . setupFromConnection ( conn , previousResponse ) ; res . req = req ; if ( res . hasHeader ( LOCATION ) && req . followRedirects ( ) ) { if ( status != HTTP_TEMP_REDIR ) { req . method ( Method . GET ) ; req . data ( ) . clear ( ) ; req . requestBody ( null ) ; req . removeHeader ( CONTENT_TYPE ) ; } String location = res . header ( LOCATION ) ; if ( location . startsWith ( "http:/" ) && location . charAt ( 6 ) != '/' ) location = location . substring ( 6 ) ; URL redir = StringUtil . resolve ( req . url ( ) , location ) ; req . url ( encodeUrl ( redir ) ) ; for ( Map . Entry < String , String > cookie : res . cookies . entrySet ( ) ) { req . cookie ( cookie . getKey ( ) , cookie . getValue ( ) ) ; } return execute ( req , res ) ; } if ( ( status < 200 || status >= 400 ) && ! req . ignoreHttpErrors ( ) ) throw new HttpStatusException ( "http error fetching url" , status , req . url ( ) . toString ( ) ) ; String contentType = res . contentType ( ) ; if ( contentType != null && ! req . ignoreContentType ( ) && ! contentType . startsWith ( "text/" ) && ! xmlContentTypeRxp . matcher ( contentType ) . matches ( ) ) throw new UnsupportedMimeTypeException ( "unhandled content type. must be text/*, application/xml, or application/xhtml+xml" , contentType , req . url ( ) . toString ( ) ) ; if ( contentType != null && xmlContentTypeRxp . matcher ( contentType ) . matches ( ) ) { if ( req instanceof HttpConnection . Request && ! ( ( Request ) req ) . parserDefined ) { req . parser ( Parser . xmlParser ( ) ) ; } } res . charset = DataUtil . getCharsetFromContentType ( res . contentType ) ; if ( conn . getContentLength ( ) != 0 && req . method ( ) != HEAD ) { res . bodyStream = null ; res . bodyStream = conn . getErrorStream ( ) != null ? conn . getErrorStream ( ) : conn . getInputStream ( ) ; if ( res . hasHeaderWithValue ( CONTENT_ENCODING , "gzip" ) ) { res . bodyStream = new GZIPInputStream ( res . bodyStream ) ; } else if ( res . hasHeaderWithValue ( CONTENT_ENCODING , "deflate" ) ) { res . bodyStream = new InflaterInputStream ( res . bodyStream , new Inflater ( true ) ) ; } res . bodyStream = ConstrainableInputStream . wrap ( res . bodyStream , DataUtil . bufferSize , req . maxBodySize ( ) ) . timeout ( startTime , req . timeout ( ) ) ; } else { res . byteData = DataUtil . emptyByteBuffer ( ) ; } } catch ( IOException e ) { conn . disconnect ( ) ; throw e ; } res . executed = true ; return res ; }
--------------------------------------------------
protected void addChildren ( Node ... children ) { final List < Node > nodes = ensureChildNodes ( ) ; for ( Node child : children ) { reparentChild ( child ) ; nodes . add ( child ) ; child . setSiblingIndex ( nodes . size ( ) - 1 ) ; } }
--------------------------------------------------
protected boolean process ( Token token ) { currentToken = token ; return this . state . process ( token , this ) ; }
--------------------------------------------------
void unconsume ( ) { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( "no buffer left to unconsume" ) ) ; bufPos -- ; }
--------------------------------------------------
void updateNumEvaluators ( ) { num = evaluators . size ( ) ; }
--------------------------------------------------
boolean process ( Token t , HtmlTreeBuilder tb ) { if ( t . isDoctype ( ) ) { tb . error ( this ) ; return false ; } else if ( t . isComment ( ) ) { tb . insert ( t . asComment ( ) ) ; } else if ( isWhitespace ( t ) ) { return true ; } else if ( t . isStartTag ( ) && t . asStartTag ( ) . normalName ( ) . equals ( "html" ) ) { tb . insert ( t . asStartTag ( ) ) ; tb . transition ( BeforeHead ) ; } else if ( t . isEndTag ( ) && ( StringUtil . in ( t . asEndTag ( ) . normalName ( ) , "head" , "body" , "html" , "br" ) ) ) { return anythingElse ( t , tb ) ; } else if ( t . isEndTag ( ) ) { tb . error ( this ) ; return false ; } else { return anythingElse ( t , tb ) ; } return true ; }
--------------------------------------------------
boolean process ( Token t , HtmlTreeBuilder tb ) { switch ( t . type ) { case Character : Token . Character c = t . asCharacter ( ) ; if ( c . getData ( ) . equals ( nullString ) ) { tb . error ( this ) ; return false ; } else { tb . insert ( c ) ; } break ; case Comment : tb . insert ( t . asComment ( ) ) ; break ; case Doctype : tb . error ( this ) ; return false ; case StartTag : Token . StartTag start = t . asStartTag ( ) ; String name = start . normalName ( ) ; if ( name . equals ( "html" ) ) return tb . process ( start , InBody ) ; else if ( name . equals ( "option" ) ) { if ( tb . currentElement ( ) . normalName ( ) . equals ( "option" ) ) tb . processEndTag ( "option" ) ; tb . insert ( start ) ; } else if ( name . equals ( "optgroup" ) ) { if ( tb . currentElement ( ) . normalName ( ) . equals ( "option" ) ) tb . processEndTag ( "option" ) ; else if ( tb . currentElement ( ) . normalName ( ) . equals ( "optgroup" ) ) tb . processEndTag ( "optgroup" ) ; tb . insert ( start ) ; } else if ( name . equals ( "select" ) ) { tb . error ( this ) ; return tb . processEndTag ( "select" ) ; } else if ( StringUtil . in ( name , "input" , "keygen" , "textarea" ) ) { tb . error ( this ) ; if ( ! tb . inSelectScope ( "select" ) ) return false ; tb . processEndTag ( "select" ) ; return tb . process ( start ) ; } else if ( name . equals ( "script" ) ) { return tb . process ( t , InHead ) ; } else { return anythingElse ( t , tb ) ; } break ; case EndTag : Token . EndTag end = t . asEndTag ( ) ; name = end . normalName ( ) ; switch ( name ) { case "optgroup" : if ( tb . currentElement ( ) . normalName ( ) . equals ( "option" ) && tb . aboveOnStack ( tb . currentElement ( ) ) != null && tb . aboveOnStack ( tb . currentElement ( ) ) . normalName ( ) . equals ( "optgroup" ) ) tb . processEndTag ( "option" ) ; if ( tb . currentElement ( ) . normalName ( ) . equals ( "optgroup" ) ) tb . pop ( ) ; else tb . error ( this ) ; break ; case "option" : if ( tb . currentElement ( ) . normalName ( ) . equals ( "option" ) ) tb . pop ( ) ; else tb . error ( this ) ; break ; case "select" : if ( ! tb . inSelectScope ( name ) ) { tb . error ( this ) ; return false ; } else { tb . popStackToClose ( name ) ; tb . resetInsertionMode ( ) ; } break ; default : return anythingElse ( t , tb ) ; } break ; case EOF : if ( ! tb . currentElement ( ) . normalName ( ) . equals ( "html" ) ) tb . error ( this ) ; break ; default : return anythingElse ( t , tb ) ; } return true ; }
--------------------------------------------------
public W3CBuilder ( Document doc ) { this . doc = doc ; this . namespacesStack . push ( new HashMap < String , String > ( ) ) ; }
--------------------------------------------------
public void add ( int index , E element ) { onContentsChanged ( ) ; super . add ( index , element ) ; }
--------------------------------------------------
protected List < Node > ensureChildNodes ( ) { return EmptyNodes ; }
--------------------------------------------------
