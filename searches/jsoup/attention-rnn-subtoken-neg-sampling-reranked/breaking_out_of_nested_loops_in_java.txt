public Request proxy ( String host , int port ) { this . proxy = new Proxy ( Proxy . Type . HTTP , InetSocketAddress . createUnresolved ( host , port ) ) ; return this ; }
--------------------------------------------------
public static StringBuilder borrowBuilder ( ) { synchronized ( builders ) { return builders . empty ( ) ? new StringBuilder ( MaxCachedBuilderSize ) : builders . pop ( ) ; } }
--------------------------------------------------
public Connection ignoreContentType ( boolean ignoreContentType ) { req . ignoreContentType ( ignoreContentType ) ; return this ; }
--------------------------------------------------
public E set ( int index , E element ) { onContentsChanged ( ) ; return super . set ( index , element ) ; }
--------------------------------------------------
public void clear ( ) { onContentsChanged ( ) ; super . clear ( ) ; }
--------------------------------------------------
public String attr ( String attributeKey ) { for ( Element element : this ) { if ( element . hasAttr ( attributeKey ) ) return element . attr ( attributeKey ) ; } return "" ; }
--------------------------------------------------
public static String padding ( int width ) { if ( width < 0 ) throw new IllegalArgumentException ( "width must be > 0" ) ; if ( width < padding . length ) return padding [ width ] ; char [ ] out = new char [ width ] ; for ( int i = 0 ; i < width ; i ++ ) out [ i ] = ' ' ; return String . valueOf ( out ) ; }
--------------------------------------------------
public Document ( String baseUri ) { super ( Tag . valueOf ( "#root" , ParseSettings . htmlDefault ) , baseUri ) ; this . location = baseUri ; }
--------------------------------------------------
private static LinkedHashMap < String , List < String >> createHeaderMap ( HttpURLConnection conn ) { final LinkedHashMap < String , List < String >> headers = new LinkedHashMap < > ( ) ; int i = 0 ; while ( true ) { final String key = conn . getHeaderFieldKey ( i ) ; final String val = conn . getHeaderField ( i ) ; if ( key == null && val == null ) break ; i ++ ; if ( key == null || val == null ) continue ; if ( headers . containsKey ( key ) ) headers . get ( key ) . add ( val ) ; else { final ArrayList < String > vals = new ArrayList < > ( ) ; vals . add ( val ) ; headers . put ( key , vals ) ; } } return headers ; }
--------------------------------------------------
public Element text ( String text ) { body ( ) . text ( text ) ; return this ; }
--------------------------------------------------
