private static HttpURLConnection createConnection ( Connection . Request req ) throws IOException { final HttpURLConnection conn = ( HttpURLConnection ) ( req . proxy ( ) == null ? req . url ( ) . openConnection ( ) : req . url ( ) . openConnection ( req . proxy ( ) ) ) ; conn . setRequestMethod ( req . method ( ) . name ( ) ) ; conn . setInstanceFollowRedirects ( false ) ; conn . setConnectTimeout ( req . timeout ( ) ) ; conn . setReadTimeout ( req . timeout ( ) / 2 ) ; if ( req . sslSocketFactory ( ) != null && conn instanceof HttpsURLConnection ) ( ( HttpsURLConnection ) conn ) . setSSLSocketFactory ( req . sslSocketFactory ( ) ) ; if ( req . method ( ) . hasBody ( ) ) conn . setDoOutput ( true ) ; if ( req . cookies ( ) . size ( ) > 0 ) conn . addRequestProperty ( "cookie" , getRequestCookieString ( req ) ) ; for ( Map . Entry < String , List < String >> header : req . multiHeaders ( ) . entrySet ( ) ) { for ( String value : header . getValue ( ) ) { conn . addRequestProperty ( header . getKey ( ) , value ) ; } } return conn ; }
--------------------------------------------------
public Connection requestBody ( String body ) { req . requestBody ( body ) ; return this ; }
--------------------------------------------------
public Document outputSettings ( OutputSettings outputSettings ) { Validate . notNull ( outputSettings ) ; this . outputSettings = outputSettings ; return this ; }
--------------------------------------------------
public CharacterReader ( Reader input , int sz ) { Validate . notNull ( input ) ; Validate . isTrue ( input . markSupported ( ) ) ; reader = input ; charBuf = new char [ sz > maxBufferLen ? maxBufferLen : sz ] ; bufferUp ( ) ; }
--------------------------------------------------
public Parser setTreeBuilder ( TreeBuilder treeBuilder ) { this . treeBuilder = treeBuilder ; treeBuilder . parser = this ; return this ; }
--------------------------------------------------
private static String cacheString ( final char [ ] charBuf , final String [ ] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; if ( count < 1 ) return "" ; int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ; String cached = stringCache [ index ] ; if ( cached == null ) { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } else { if ( rangeEquals ( charBuf , start , count , cached ) ) { return cached ; } else { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } } return cached ; }
--------------------------------------------------
public static Document createShell ( String baseUri ) { Validate . notNull ( baseUri ) ; Document doc = new Document ( baseUri ) ; doc . parser = doc . parser ( ) ; Element html = doc . appendElement ( "html" ) ; html . appendElement ( "head" ) ; html . appendElement ( "body" ) ; return doc ; }
--------------------------------------------------
@ Override Token reset ( ) { data = null ; return this ; }
--------------------------------------------------
public Connection . Request requestBody ( String body ) { this . body = body ; return this ; }
--------------------------------------------------
public Parser settings ( ParseSettings settings ) { this . settings = settings ; return this ; }
--------------------------------------------------
