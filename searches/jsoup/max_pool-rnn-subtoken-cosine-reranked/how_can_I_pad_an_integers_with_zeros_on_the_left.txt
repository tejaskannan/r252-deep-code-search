public CharacterReader ( Reader input , int sz ) { Validate . notNull ( input ) ; Validate . isTrue ( input . markSupported ( ) ) ; reader = input ; charBuf = new char [ sz > maxBufferLen ? maxBufferLen : sz ] ; bufferUp ( ) ; }
--------------------------------------------------
String consumeLetterThenDigitSequence ( ) { bufferUp ( ) ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ; if ( ( c >= 'a' && c <= 'z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; else break ; } while ( ! isEmptyNoBufferUp ( ) ) { char c = charBuf [ bufPos ] ; if ( c >= '0' && c <= '9' ) bufPos ++ ; else break ; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; }
--------------------------------------------------
Element aboveOnStack ( Element el ) { assert onStack ( el ) ; for ( int pos = stack . size ( ) - 1 ; pos >= 0 ; pos -- ) { Element next = stack . get ( pos ) ; if ( next == el ) { return stack . get ( pos - 1 ) ; } } return null ; }
--------------------------------------------------
private static void appendWhitespaceIfBr ( Element element , StringBuilder accum ) { if ( element . tag . getName ( ) . equals ( "br" ) && ! TextNode . lastCharIsWhitespace ( accum ) ) accum . append ( " " ) ; }
--------------------------------------------------
void outerHtmlHead ( Appendable accum , int depth , Document . OutputSettings out ) throws IOException { if ( out . prettyPrint ( ) ) indent ( accum , depth , out ) ; accum . append ( "<!--" ) . append ( getData ( ) ) . append ( "-->" ) ; }
--------------------------------------------------
void outerHtmlHead ( final Appendable accum , int depth , final Document . OutputSettings out ) throws IOException { if ( out . prettyPrint ( ) && ( tag . formatAsBlock ( ) || ( parent ( ) != null && parent ( ) . tag ( ) . formatAsBlock ( ) ) || out . outline ( ) ) ) { if ( accum instanceof StringBuilder ) { if ( ( ( StringBuilder ) accum ) . length ( ) > 0 ) indent ( accum , depth , out ) ; } else { indent ( accum , depth , out ) ; } } accum . append ( '<' ) . append ( tagName ( ) ) ; if ( attributes != null ) attributes . html ( accum , out ) ; if ( childNodes . isEmpty ( ) && tag . isSelfClosing ( ) ) { if ( out . syntax ( ) == Document . OutputSettings . Syntax . html && tag . isEmpty ( ) ) accum . append ( '>' ) ; else accum . append ( " />" ) ; } else accum . append ( '>' ) ; }
--------------------------------------------------
int nextIndexOf ( CharSequence seq ) { bufferUp ( ) ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { if ( startChar != charBuf [ offset ] ) while ( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length ( ) - 1 ; if ( offset < bufLength && last <= bufLength ) { for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) return offset - bufPos ; } } return - 1 ; }
--------------------------------------------------
public Document clean ( Document dirtyDocument ) { Validate . notNull ( dirtyDocument ) ; Document clean = Document . createShell ( dirtyDocument . baseUri ( ) ) ; if ( dirtyDocument . body ( ) != null ) copySafeNodes ( dirtyDocument . body ( ) , clean . body ( ) ) ; return clean ; }
--------------------------------------------------
int [ ] consumeCharacterReference ( Character additionalAllowedCharacter , boolean inAttribute ) { if ( reader . isEmpty ( ) ) return null ; if ( additionalAllowedCharacter != null && additionalAllowedCharacter == reader . current ( ) ) return null ; if ( reader . matchesAnySorted ( notCharRefCharsSorted ) ) return null ; final int [ ] codeRef = codepointHolder ; reader . mark ( ) ; if ( reader . matchConsume ( "#" ) ) { boolean isHexMode = reader . matchConsumeIgnoreCase ( "x" ) ; String numRef = isHexMode ? reader . consumeHexSequence ( ) : reader . consumeDigitSequence ( ) ; if ( numRef . length ( ) == 0 ) { characterReferenceError ( "numeric reference with no numerals" ) ; reader . rewindToMark ( ) ; return null ; } if ( ! reader . matchConsume ( ";" ) ) characterReferenceError ( "missing semicolon" ) ; int charval = - 1 ; try { int base = isHexMode ? 16 : 10 ; charval = Integer . valueOf ( numRef , base ) ; } catch ( NumberFormatException ignored ) { } if ( charval == - 1 || ( charval >= d800 && charval <= dfff ) || charval > 10ffff ) { characterReferenceError ( "character outside of valid range" ) ; codeRef [ 0 ] = replacementChar ; return codeRef ; } else { if ( charval >= win1252ExtensionsStart && charval < win1252ExtensionsStart + win1252Extensions . length ) { characterReferenceError ( "character is not a valid unicode code point" ) ; charval = win1252Extensions [ charval - win1252ExtensionsStart ] ; } codeRef [ 0 ] = charval ; return codeRef ; } } else { String nameRef = reader . consumeLetterThenDigitSequence ( ) ; boolean looksLegit = reader . matches ( ';' ) ; boolean found = ( Entities . isBaseNamedEntity ( nameRef ) || ( Entities . isNamedEntity ( nameRef ) && looksLegit ) ) ; if ( ! found ) { reader . rewindToMark ( ) ; if ( looksLegit ) characterReferenceError ( String . format ( "invalid named reference '%s'" , nameRef ) ) ; return null ; } if ( inAttribute && ( reader . matchesLetter ( ) || reader . matchesDigit ( ) || reader . matchesAny ( '=' , '-' , '_' ) ) ) { reader . rewindToMark ( ) ; return null ; } if ( ! reader . matchConsume ( ";" ) ) characterReferenceError ( "missing semicolon" ) ; int numChars = Entities . codepointsForName ( nameRef , multipointHolder ) ; if ( numChars == 1 ) { codeRef [ 0 ] = multipointHolder [ 0 ] ; return codeRef ; } else if ( numChars == 2 ) { return multipointHolder ; } else { Validate . fail ( "unexpected characters returned for " + nameRef ) ; return multipointHolder ; } } }
--------------------------------------------------
private void ownText ( StringBuilder accum ) { for ( Node child : childNodes ) { if ( child instanceof TextNode ) { TextNode textNode = ( TextNode ) child ; appendNormalisedText ( accum , textNode ) ; } else if ( child instanceof Element ) { appendWhitespaceIfBr ( ( Element ) child , accum ) ; } } }
--------------------------------------------------
