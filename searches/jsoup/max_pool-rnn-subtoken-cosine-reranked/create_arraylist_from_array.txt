public static Document createShell ( String baseUri ) { Validate . notNull ( baseUri ) ; Document doc = new Document ( baseUri ) ; doc . parser = doc . parser ( ) ; Element html = doc . appendElement ( "html" ) ; html . appendElement ( "head" ) ; html . appendElement ( "body" ) ; return doc ; }
--------------------------------------------------
. Tag createTagPending ( boolean start ) { tagPending = start ? startPending . reset ( ) : endPending . reset ( ) ; return tagPending ; }
--------------------------------------------------
public static Attribute createFromEncoded ( String unencodedKey , String encodedValue ) { String value = Entities . unescape ( encodedValue , true ) ; return new Attribute ( unencodedKey , value , null ) ; }
--------------------------------------------------
int [ ] consumeCharacterReference ( Character additionalAllowedCharacter , boolean inAttribute ) { if ( reader . isEmpty ( ) ) return null ; if ( additionalAllowedCharacter != null && additionalAllowedCharacter == reader . current ( ) ) return null ; if ( reader . matchesAnySorted ( notCharRefCharsSorted ) ) return null ; final int [ ] codeRef = codepointHolder ; reader . mark ( ) ; if ( reader . matchConsume ( "#" ) ) { boolean isHexMode = reader . matchConsumeIgnoreCase ( "x" ) ; String numRef = isHexMode ? reader . consumeHexSequence ( ) : reader . consumeDigitSequence ( ) ; if ( numRef . length ( ) == 0 ) { characterReferenceError ( "numeric reference with no numerals" ) ; reader . rewindToMark ( ) ; return null ; } if ( ! reader . matchConsume ( ";" ) ) characterReferenceError ( "missing semicolon" ) ; int charval = - 1 ; try { int base = isHexMode ? 16 : 10 ; charval = Integer . valueOf ( numRef , base ) ; } catch ( NumberFormatException ignored ) { } if ( charval == - 1 || ( charval >= d800 && charval <= dfff ) || charval > 10ffff ) { characterReferenceError ( "character outside of valid range" ) ; codeRef [ 0 ] = replacementChar ; return codeRef ; } else { if ( charval >= win1252ExtensionsStart && charval < win1252ExtensionsStart + win1252Extensions . length ) { characterReferenceError ( "character is not a valid unicode code point" ) ; charval = win1252Extensions [ charval - win1252ExtensionsStart ] ; } codeRef [ 0 ] = charval ; return codeRef ; } } else { String nameRef = reader . consumeLetterThenDigitSequence ( ) ; boolean looksLegit = reader . matches ( ';' ) ; boolean found = ( Entities . isBaseNamedEntity ( nameRef ) || ( Entities . isNamedEntity ( nameRef ) && looksLegit ) ) ; if ( ! found ) { reader . rewindToMark ( ) ; if ( looksLegit ) characterReferenceError ( String . format ( "invalid named reference '%s'" , nameRef ) ) ; return null ; } if ( inAttribute && ( reader . matchesLetter ( ) || reader . matchesDigit ( ) || reader . matchesAny ( '=' , '-' , '_' ) ) ) { reader . rewindToMark ( ) ; return null ; } if ( ! reader . matchConsume ( ";" ) ) characterReferenceError ( "missing semicolon" ) ; int numChars = Entities . codepointsForName ( nameRef , multipointHolder ) ; if ( numChars == 1 ) { codeRef [ 0 ] = multipointHolder [ 0 ] ; return codeRef ; } else if ( numChars == 2 ) { return multipointHolder ; } else { Validate . fail ( "unexpected characters returned for " + nameRef ) ; return multipointHolder ; } } }
--------------------------------------------------
public CharacterReader ( Reader input , int sz ) { Validate . notNull ( input ) ; Validate . isTrue ( input . markSupported ( ) ) ; reader = input ; charBuf = new char [ sz > maxBufferLen ? maxBufferLen : sz ] ; bufferUp ( ) ; }
--------------------------------------------------
static String mimeBoundary ( ) { final StringBuilder mime = StringUtil . borrowBuilder ( ) ; final Random rand = new Random ( ) ; for ( int i = 0 ; i < boundaryLength ; i ++ ) { mime . append ( mimeBoundaryChars [ rand . nextInt ( mimeBoundaryChars . length ) ] ) ; } return StringUtil . releaseBuilder ( mime ) ; }
--------------------------------------------------
private static String [ ] copyOf ( String [ ] orig , int size ) { final String [ ] copy = new String [ size ] ; System . arraycopy ( orig , 0 , copy , 0 , Math . min ( orig . length , size ) ) ; return copy ; }
--------------------------------------------------
private boolean anythingElse ( Token t , HtmlTreeBuilder tb ) { tb . error ( this ) ; tb . insert ( new Token . Character ( ) . data ( t . toString ( ) ) ) ; return true ; }
--------------------------------------------------
public int hashCode ( ) { int result = key != null ? key . hashCode ( ) : 0 ; result = 31 * result + ( val != null ? val . hashCode ( ) : 0 ) ; return result ; }
--------------------------------------------------
private static String fixHeaderEncoding ( String val ) { try { byte [ ] bytes = val . getBytes ( "iso-8859-1" ) ; if ( ! looksLikeUtf8 ( bytes ) ) return val ; return new String ( bytes , "utf-8" ) ; } catch ( UnsupportedEncodingException e ) { return val ; } }
--------------------------------------------------
