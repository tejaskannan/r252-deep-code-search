public Element previousElementSibling ( ) { if ( parentNode == null ) return null ; List < Element > siblings = parent ( ) . childElementsList ( ) ; Integer index = indexInList ( this , siblings ) ; Validate . notNull ( index ) ; if ( index > 0 ) return siblings . get ( index - 1 ) ; else return null ; }
--------------------------------------------------
private void combinator ( char combinator ) { tq . consumeWhitespace ( ) ; String subQuery = consumeSubQuery ( ) ; Evaluator rootEval ; Evaluator currentEval ; Evaluator newEval = parse ( subQuery ) ; boolean replaceRightMost = false ; if ( evals . size ( ) == 1 ) { rootEval = currentEval = evals . get ( 0 ) ; if ( rootEval instanceof CombiningEvaluator . Or && combinator != ',' ) { currentEval = ( ( CombiningEvaluator . Or ) currentEval ) . rightMostEvaluator ( ) ; replaceRightMost = true ; } } else { rootEval = currentEval = new CombiningEvaluator . And ( evals ) ; } evals . clear ( ) ; if ( combinator == '>' ) currentEval = new CombiningEvaluator . And ( newEval , new StructuralEvaluator . ImmediateParent ( currentEval ) ) ; else if ( combinator == ' ' ) currentEval = new CombiningEvaluator . And ( newEval , new StructuralEvaluator . Parent ( currentEval ) ) ; else if ( combinator == '+' ) currentEval = new CombiningEvaluator . And ( newEval , new StructuralEvaluator . ImmediatePreviousSibling ( currentEval ) ) ; else if ( combinator == '~' ) currentEval = new CombiningEvaluator . And ( newEval , new StructuralEvaluator . PreviousSibling ( currentEval ) ) ; else if ( combinator == ',' ) { CombiningEvaluator . Or or ; if ( currentEval instanceof CombiningEvaluator . Or ) { or = ( CombiningEvaluator . Or ) currentEval ; or . add ( newEval ) ; } else { or = new CombiningEvaluator . Or ( ) ; or . add ( currentEval ) ; or . add ( newEval ) ; } currentEval = or ; } else throw new Selector . SelectorParseException ( "unknown combinator: " + combinator ) ; if ( replaceRightMost ) ( ( CombiningEvaluator . Or ) rootEval ) . replaceRightMostEvaluator ( currentEval ) ; else rootEval = currentEval ; evals . add ( rootEval ) ; }
--------------------------------------------------
boolean anyOtherEndTag ( Token t , HtmlTreeBuilder tb ) { String name = t . asEndTag ( ) . normalName ; ArrayList < Element > stack = tb . getStack ( ) ; for ( int pos = stack . size ( ) - 1 ; pos >= 0 ; pos -- ) { Element node = stack . get ( pos ) ; if ( node . normalName ( ) . equals ( name ) ) { tb . generateImpliedEndTags ( name ) ; if ( ! name . equals ( tb . currentElement ( ) . normalName ( ) ) ) tb . error ( this ) ; tb . popStackToClose ( name ) ; break ; } else { if ( tb . isSpecial ( node ) ) { tb . error ( this ) ; return false ; } } } return true ; }
--------------------------------------------------
public String getPlainText ( Element element ) { FormattingVisitor formatter = new FormattingVisitor ( ) ; NodeTraversor . traverse ( formatter , element ) ; return formatter . toString ( ) ; }
--------------------------------------------------
private void findElements ( ) { if ( tq . matchChomp ( "#" ) ) byId ( ) ; else if ( tq . matchChomp ( "." ) ) byClass ( ) ; else if ( tq . matchesWord ( ) || tq . matches ( "*|" ) ) byTag ( ) ; else if ( tq . matches ( "[" ) ) byAttribute ( ) ; else if ( tq . matchChomp ( "*" ) ) allElements ( ) ; else if ( tq . matchChomp ( ":lt(" ) ) indexLessThan ( ) ; else if ( tq . matchChomp ( ":gt(" ) ) indexGreaterThan ( ) ; else if ( tq . matchChomp ( ":eq(" ) ) indexEquals ( ) ; else if ( tq . matches ( ":has(" ) ) has ( ) ; else if ( tq . matches ( ":contains(" ) ) contains ( false ) ; else if ( tq . matches ( ":containsown(" ) ) contains ( true ) ; else if ( tq . matches ( ":containsdata(" ) ) containsData ( ) ; else if ( tq . matches ( ":matches(" ) ) matches ( false ) ; else if ( tq . matches ( ":matchesown(" ) ) matches ( true ) ; else if ( tq . matches ( ":not(" ) ) not ( ) ; else if ( tq . matchChomp ( ":nth-child(" ) ) cssNthChild ( false , false ) ; else if ( tq . matchChomp ( ":nth-last-child(" ) ) cssNthChild ( true , false ) ; else if ( tq . matchChomp ( ":nth-of-type(" ) ) cssNthChild ( false , true ) ; else if ( tq . matchChomp ( ":nth-last-of-type(" ) ) cssNthChild ( true , true ) ; else if ( tq . matchChomp ( ":first-child" ) ) evals . add ( new Evaluator . IsFirstChild ( ) ) ; else if ( tq . matchChomp ( ":last-child" ) ) evals . add ( new Evaluator . IsLastChild ( ) ) ; else if ( tq . matchChomp ( ":first-of-type" ) ) evals . add ( new Evaluator . IsFirstOfType ( ) ) ; else if ( tq . matchChomp ( ":last-of-type" ) ) evals . add ( new Evaluator . IsLastOfType ( ) ) ; else if ( tq . matchChomp ( ":only-child" ) ) evals . add ( new Evaluator . IsOnlyChild ( ) ) ; else if ( tq . matchChomp ( ":only-of-type" ) ) evals . add ( new Evaluator . IsOnlyOfType ( ) ) ; else if ( tq . matchChomp ( ":empty" ) ) evals . add ( new Evaluator . IsEmpty ( ) ) ; else if ( tq . matchChomp ( ":root" ) ) evals . add ( new Evaluator . IsRoot ( ) ) ; else if ( tq . matchChomp ( ":matchtext" ) ) evals . add ( new Evaluator . MatchText ( ) ) ; else throw new Selector . SelectorParseException ( "could not parse query '%s': unexpected token at '%s'" , query , tq . remainder ( ) ) ; }
--------------------------------------------------
private boolean exitTableBody ( Token t , HtmlTreeBuilder tb ) { if ( ! ( tb . inTableScope ( "tbody" ) || tb . inTableScope ( "thead" ) || tb . inScope ( "tfoot" ) ) ) { tb . error ( this ) ; return false ; } tb . clearStackToTableBodyContext ( ) ; tb . processEndTag ( tb . currentElement ( ) . normalName ( ) ) ; return tb . process ( t ) ; }
--------------------------------------------------
private static BomCharset detectCharsetFromBom ( final ByteBuffer byteData ) { final Buffer buffer = byteData ; buffer . mark ( ) ; byte [ ] bom = new byte [ 4 ] ; if ( byteData . remaining ( ) >= bom . length ) { byteData . get ( bom ) ; buffer . rewind ( ) ; } if ( bom [ 0 ] == 00 && bom [ 1 ] == 00 && bom [ 2 ] == ( byte ) fe && bom [ 3 ] == ( byte ) ff || bom [ 0 ] == ( byte ) ff && bom [ 1 ] == ( byte ) fe && bom [ 2 ] == 00 && bom [ 3 ] == 00 ) { return new BomCharset ( "utf-32" , false ) ; } else if ( bom [ 0 ] == ( byte ) fe && bom [ 1 ] == ( byte ) ff || bom [ 0 ] == ( byte ) ff && bom [ 1 ] == ( byte ) fe ) { return new BomCharset ( "utf-16" , false ) ; } else if ( bom [ 0 ] == ( byte ) ef && bom [ 1 ] == ( byte ) bb && bom [ 2 ] == ( byte ) bf ) { return new BomCharset ( "utf-8" , true ) ; } return null ; }
--------------------------------------------------
private boolean anythingElse ( Token t , TreeBuilder tb ) { boolean processed = tb . processEndTag ( "colgroup" ) ; if ( processed ) return tb . process ( t ) ; return true ; }
--------------------------------------------------
public Parser ( TreeBuilder treeBuilder ) { this . treeBuilder = treeBuilder ; settings = treeBuilder . defaultSettings ( ) ; errors = ParseErrorList . noTracking ( ) ; }
--------------------------------------------------
boolean anythingElse ( Token t , HtmlTreeBuilder tb ) { tb . error ( this ) ; boolean processed ; if ( StringUtil . in ( tb . currentElement ( ) . normalName ( ) , "table" , "tbody" , "tfoot" , "thead" , "tr" ) ) { tb . setFosterInserts ( true ) ; processed = tb . process ( t , InBody ) ; tb . setFosterInserts ( false ) ; } else { processed = tb . process ( t , InBody ) ; } return processed ; }
--------------------------------------------------
