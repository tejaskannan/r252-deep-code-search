private static void appendWhitespaceIfBr ( Element element , StringBuilder accum ) { if ( element . tag . getName ( ) . equals ( "br" ) && ! TextNode . lastCharIsWhitespace ( accum ) ) accum . append ( " " ) ; }
--------------------------------------------------
String unescapeEntities ( boolean inAttribute ) { StringBuilder builder = StringUtil . borrowBuilder ( ) ; while ( ! reader . isEmpty ( ) ) { builder . append ( reader . consumeTo ( '&' ) ) ; if ( reader . matches ( '&' ) ) { reader . consume ( ) ; int [ ] c = consumeCharacterReference ( null , inAttribute ) ; if ( c == null || c . length == 0 ) builder . append ( '&' ) ; else { builder . appendCodePoint ( c [ 0 ] ) ; if ( c . length == 2 ) builder . appendCodePoint ( c [ 1 ] ) ; } } } return StringUtil . releaseBuilder ( builder ) ; }
--------------------------------------------------
void outerHtmlHead ( final Appendable accum , int depth , final Document . OutputSettings out ) throws IOException { if ( out . prettyPrint ( ) && ( tag . formatAsBlock ( ) || ( parent ( ) != null && parent ( ) . tag ( ) . formatAsBlock ( ) ) || out . outline ( ) ) ) { if ( accum instanceof StringBuilder ) { if ( ( ( StringBuilder ) accum ) . length ( ) > 0 ) indent ( accum , depth , out ) ; } else { indent ( accum , depth , out ) ; } } accum . append ( '<' ) . append ( tagName ( ) ) ; if ( attributes != null ) attributes . html ( accum , out ) ; if ( childNodes . isEmpty ( ) && tag . isSelfClosing ( ) ) { if ( out . syntax ( ) == Document . OutputSettings . Syntax . html && tag . isEmpty ( ) ) accum . append ( '>' ) ; else accum . append ( " />" ) ; } else accum . append ( '>' ) ; }
--------------------------------------------------
static String mimeBoundary ( ) { final StringBuilder mime = StringUtil . borrowBuilder ( ) ; final Random rand = new Random ( ) ; for ( int i = 0 ; i < boundaryLength ; i ++ ) { mime . append ( mimeBoundaryChars [ rand . nextInt ( mimeBoundaryChars . length ) ] ) ; } return StringUtil . releaseBuilder ( mime ) ; }
--------------------------------------------------
void insertInFosterParent ( Node in ) { Element fosterParent ; Element lastTable = getFromStack ( "table" ) ; boolean isLastTableParent = false ; if ( lastTable != null ) { if ( lastTable . parent ( ) != null ) { fosterParent = lastTable . parent ( ) ; isLastTableParent = true ; } else fosterParent = aboveOnStack ( lastTable ) ; } else { fosterParent = stack . get ( 0 ) ; } if ( isLastTableParent ) { Validate . notNull ( lastTable ) ; lastTable . before ( in ) ; } else fosterParent . appendChild ( in ) ; }
--------------------------------------------------
String consumeLetterThenDigitSequence ( ) { bufferUp ( ) ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ; if ( ( c >= 'a' && c <= 'z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; else break ; } while ( ! isEmptyNoBufferUp ( ) ) { char c = charBuf [ bufPos ] ; if ( c >= '0' && c <= '9' ) bufPos ++ ; else break ; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; }
--------------------------------------------------
private static BomCharset detectCharsetFromBom ( final ByteBuffer byteData ) { final Buffer buffer = byteData ; buffer . mark ( ) ; byte [ ] bom = new byte [ 4 ] ; if ( byteData . remaining ( ) >= bom . length ) { byteData . get ( bom ) ; buffer . rewind ( ) ; } if ( bom [ 0 ] == 00 && bom [ 1 ] == 00 && bom [ 2 ] == ( byte ) fe && bom [ 3 ] == ( byte ) ff || bom [ 0 ] == ( byte ) ff && bom [ 1 ] == ( byte ) fe && bom [ 2 ] == 00 && bom [ 3 ] == 00 ) { return new BomCharset ( "utf-32" , false ) ; } else if ( bom [ 0 ] == ( byte ) fe && bom [ 1 ] == ( byte ) ff || bom [ 0 ] == ( byte ) ff && bom [ 1 ] == ( byte ) fe ) { return new BomCharset ( "utf-16" , false ) ; } else if ( bom [ 0 ] == ( byte ) ef && bom [ 1 ] == ( byte ) bb && bom [ 2 ] == ( byte ) bf ) { return new BomCharset ( "utf-8" , true ) ; } return null ; }
--------------------------------------------------
void resetInsertionMode ( ) { boolean last = false ; for ( int pos = stack . size ( ) - 1 ; pos >= 0 ; pos -- ) { Element node = stack . get ( pos ) ; if ( pos == 0 ) { last = true ; node = contextElement ; } String name = node . normalName ( ) ; if ( "select" . equals ( name ) ) { transition ( HtmlTreeBuilderState . InSelect ) ; break ; } else if ( ( "td" . equals ( name ) || "th" . equals ( name ) && ! last ) ) { transition ( HtmlTreeBuilderState . InCell ) ; break ; } else if ( "tr" . equals ( name ) ) { transition ( HtmlTreeBuilderState . InRow ) ; break ; } else if ( "tbody" . equals ( name ) || "thead" . equals ( name ) || "tfoot" . equals ( name ) ) { transition ( HtmlTreeBuilderState . InTableBody ) ; break ; } else if ( "caption" . equals ( name ) ) { transition ( HtmlTreeBuilderState . InCaption ) ; break ; } else if ( "colgroup" . equals ( name ) ) { transition ( HtmlTreeBuilderState . InColumnGroup ) ; break ; } else if ( "table" . equals ( name ) ) { transition ( HtmlTreeBuilderState . InTable ) ; break ; } else if ( "head" . equals ( name ) ) { transition ( HtmlTreeBuilderState . InBody ) ; break ; } else if ( "body" . equals ( name ) ) { transition ( HtmlTreeBuilderState . InBody ) ; break ; } else if ( "frameset" . equals ( name ) ) { transition ( HtmlTreeBuilderState . InFrameset ) ; break ; } else if ( "html" . equals ( name ) ) { transition ( HtmlTreeBuilderState . BeforeHead ) ; break ; } else if ( last ) { transition ( HtmlTreeBuilderState . InBody ) ; break ; } } }
--------------------------------------------------
private boolean exitTableBody ( Token t , HtmlTreeBuilder tb ) { if ( ! ( tb . inTableScope ( "tbody" ) || tb . inTableScope ( "thead" ) || tb . inScope ( "tfoot" ) ) ) { tb . error ( this ) ; return false ; } tb . clearStackToTableBodyContext ( ) ; tb . processEndTag ( tb . currentElement ( ) . normalName ( ) ) ; return tb . process ( t ) ; }
--------------------------------------------------
private boolean inSpecificScope ( String [ ] targetNames , String [ ] baseTypes , String [ ] extraTypes ) { final int bottom = stack . size ( ) - 1 ; final int top = bottom > MaxScopeSearchDepth ? bottom - MaxScopeSearchDepth : 0 ; for ( int pos = bottom ; pos >= top ; pos -- ) { final String elName = stack . get ( pos ) . normalName ( ) ; if ( inSorted ( elName , targetNames ) ) return true ; if ( inSorted ( elName , baseTypes ) ) return false ; if ( extraTypes != null && inSorted ( elName , extraTypes ) ) return false ; } return false ; }
--------------------------------------------------
