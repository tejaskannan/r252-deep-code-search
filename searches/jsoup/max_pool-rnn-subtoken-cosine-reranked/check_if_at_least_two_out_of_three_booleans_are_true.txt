boolean anyOtherEndTag ( Token t , HtmlTreeBuilder tb ) { String name = t . asEndTag ( ) . normalName ; ArrayList < Element > stack = tb . getStack ( ) ; for ( int pos = stack . size ( ) - 1 ; pos >= 0 ; pos -- ) { Element node = stack . get ( pos ) ; if ( node . normalName ( ) . equals ( name ) ) { tb . generateImpliedEndTags ( name ) ; if ( ! name . equals ( tb . currentElement ( ) . normalName ( ) ) ) tb . error ( this ) ; tb . popStackToClose ( name ) ; break ; } else { if ( tb . isSpecial ( node ) ) { tb . error ( this ) ; return false ; } } } return true ; }
--------------------------------------------------
private static void handleDataEndTag ( Tokeniser t , CharacterReader r , TokeniserState elseTransition ) { if ( r . matchesLetter ( ) ) { String name = r . consumeLetterSequence ( ) ; t . tagPending . appendTagName ( name ) ; t . dataBuffer . append ( name ) ; return ; } boolean needsExitTransition = false ; if ( t . isAppropriateEndTagToken ( ) && ! r . isEmpty ( ) ) { char c = r . consume ( ) ; switch ( c ) { case '\t' : case '\n' : case '\r' : case '\f' : case ' ' : t . transition ( BeforeAttributeName ) ; break ; case '/' : t . transition ( SelfClosingStartTag ) ; break ; case '>' : t . emitTagPending ( ) ; t . transition ( Data ) ; break ; default : t . dataBuffer . append ( c ) ; needsExitTransition = true ; } } else { needsExitTransition = true ; } if ( needsExitTransition ) { t . emit ( "</" + t . dataBuffer . toString ( ) ) ; t . transition ( elseTransition ) ; } }
--------------------------------------------------
private int consumeIndex ( ) { String indexS = tq . chompTo ( ")" ) . trim ( ) ; Validate . isTrue ( StringUtil . isNumeric ( indexS ) , "index must be numeric" ) ; return Integer . parseInt ( indexS ) ; }
--------------------------------------------------
public CharacterReader ( Reader input , int sz ) { Validate . notNull ( input ) ; Validate . isTrue ( input . markSupported ( ) ) ; reader = input ; charBuf = new char [ sz > maxBufferLen ? maxBufferLen : sz ] ; bufferUp ( ) ; }
--------------------------------------------------
Element insertEmpty ( Token . StartTag startTag ) { Tag tag = Tag . valueOf ( startTag . name ( ) , settings ) ; Element el = new Element ( tag , baseUri , startTag . attributes ) ; insertNode ( el ) ; if ( startTag . isSelfClosing ( ) ) { if ( tag . isKnownTag ( ) ) { if ( ! tag . isEmpty ( ) ) tokeniser . error ( "tag cannot be self closing; not a void tag" ) ; } else tag . setSelfClosing ( ) ; } return el ; }
--------------------------------------------------
int nextIndexOf ( CharSequence seq ) { bufferUp ( ) ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { if ( startChar != charBuf [ offset ] ) while ( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length ( ) - 1 ; if ( offset < bufLength && last <= bufLength ) { for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) return offset - bufPos ; } } return - 1 ; }
--------------------------------------------------
private static void handleDataDoubleEscapeTag ( Tokeniser t , CharacterReader r , TokeniserState primary , TokeniserState fallback ) { if ( r . matchesLetter ( ) ) { String name = r . consumeLetterSequence ( ) ; t . dataBuffer . append ( name ) ; t . emit ( name ) ; return ; } char c = r . consume ( ) ; switch ( c ) { case '\t' : case '\n' : case '\r' : case '\f' : case ' ' : case '/' : case '>' : if ( t . dataBuffer . toString ( ) . equals ( "script" ) ) t . transition ( primary ) ; else t . transition ( fallback ) ; t . emit ( c ) ; break ; default : r . unconsume ( ) ; t . transition ( fallback ) ; } }
--------------------------------------------------
public boolean hasNext ( ) { while ( attrIter . hasNext ( ) ) { attr = attrIter . next ( ) ; if ( attr . isDataAttribute ( ) ) return true ; } return false ; }
--------------------------------------------------
private boolean anythingElse ( Token t , TreeBuilder tb ) { boolean processed = tb . processEndTag ( "colgroup" ) ; if ( processed ) return tb . process ( t ) ; return true ; }
--------------------------------------------------
void clearFormattingElementsToLastMarker ( ) { while ( ! formattingElements . isEmpty ( ) ) { Element el = removeLastFormattingElement ( ) ; if ( el == null ) break ; } }
--------------------------------------------------
