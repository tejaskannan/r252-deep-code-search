private void getWholeDeclaration ( Appendable accum , Document . OutputSettings out ) throws IOException { for ( Attribute attribute : attributes ( ) ) { if ( ! attribute . getKey ( ) . equals ( nodeName ( ) ) ) { accum . append ( ' ' ) ; attribute . html ( accum , out ) ; } } }
--------------------------------------------------
private void setupFromConnection ( HttpURLConnection conn , HttpConnection . Response previousResponse ) throws IOException { this . conn = conn ; method = Method . valueOf ( conn . getRequestMethod ( ) ) ; url = conn . getURL ( ) ; statusCode = conn . getResponseCode ( ) ; statusMessage = conn . getResponseMessage ( ) ; contentType = conn . getContentType ( ) ; Map < String , List < String >> resHeaders = createHeaderMap ( conn ) ; processResponseHeaders ( resHeaders ) ; if ( previousResponse != null ) { for ( Map . Entry < String , String > prevCookie : previousResponse . cookies ( ) . entrySet ( ) ) { if ( ! hasCookie ( prevCookie . getKey ( ) ) ) cookie ( prevCookie . getKey ( ) , prevCookie . getValue ( ) ) ; } previousResponse . safeClose ( ) ; } }
--------------------------------------------------
void popStackToClose ( String ... elNames ) { for ( int pos = stack . size ( ) - 1 ; pos >= 0 ; pos -- ) { Element next = stack . get ( pos ) ; stack . remove ( pos ) ; if ( inSorted ( next . normalName ( ) , elNames ) ) break ; } }
--------------------------------------------------
private boolean exitTableBody ( Token t , HtmlTreeBuilder tb ) { if ( ! ( tb . inTableScope ( "tbody" ) || tb . inTableScope ( "thead" ) || tb . inScope ( "tfoot" ) ) ) { tb . error ( this ) ; return false ; } tb . clearStackToTableBodyContext ( ) ; tb . processEndTag ( tb . currentElement ( ) . normalName ( ) ) ; return tb . process ( t ) ; }
--------------------------------------------------
private static BomCharset detectCharsetFromBom ( final ByteBuffer byteData ) { final Buffer buffer = byteData ; buffer . mark ( ) ; byte [ ] bom = new byte [ 4 ] ; if ( byteData . remaining ( ) >= bom . length ) { byteData . get ( bom ) ; buffer . rewind ( ) ; } if ( bom [ 0 ] == 00 && bom [ 1 ] == 00 && bom [ 2 ] == ( byte ) fe && bom [ 3 ] == ( byte ) ff || bom [ 0 ] == ( byte ) ff && bom [ 1 ] == ( byte ) fe && bom [ 2 ] == 00 && bom [ 3 ] == 00 ) { return new BomCharset ( "utf-32" , false ) ; } else if ( bom [ 0 ] == ( byte ) fe && bom [ 1 ] == ( byte ) ff || bom [ 0 ] == ( byte ) ff && bom [ 1 ] == ( byte ) fe ) { return new BomCharset ( "utf-16" , false ) ; } else if ( bom [ 0 ] == ( byte ) ef && bom [ 1 ] == ( byte ) bb && bom [ 2 ] == ( byte ) bf ) { return new BomCharset ( "utf-8" , true ) ; } return null ; }
--------------------------------------------------
String consumeLetterThenDigitSequence ( ) { bufferUp ( ) ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ; if ( ( c >= 'a' && c <= 'z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; else break ; } while ( ! isEmptyNoBufferUp ( ) ) { char c = charBuf [ bufPos ] ; if ( c >= '0' && c <= '9' ) bufPos ++ ; else break ; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; }
--------------------------------------------------
private Element getDeepChild ( Element el ) { List < Element > children = el . children ( ) ; if ( children . size ( ) > 0 ) return getDeepChild ( children . get ( 0 ) ) ; else return el ; }
--------------------------------------------------
public UnsupportedMimeTypeException ( String message , String mimeType , String url ) { super ( message ) ; this . mimeType = mimeType ; this . url = url ; }
--------------------------------------------------
private boolean inSpecificScope ( String [ ] targetNames , String [ ] baseTypes , String [ ] extraTypes ) { final int bottom = stack . size ( ) - 1 ; final int top = bottom > MaxScopeSearchDepth ? bottom - MaxScopeSearchDepth : 0 ; for ( int pos = bottom ; pos >= top ; pos -- ) { final String elName = stack . get ( pos ) . normalName ( ) ; if ( inSorted ( elName , targetNames ) ) return true ; if ( inSorted ( elName , baseTypes ) ) return false ; if ( extraTypes != null && inSorted ( elName , extraTypes ) ) return false ; } return false ; }
--------------------------------------------------
String consumeLetterSequence ( ) { bufferUp ( ) ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ; if ( ( c >= 'a' && c <= 'z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; else break ; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; }
--------------------------------------------------
