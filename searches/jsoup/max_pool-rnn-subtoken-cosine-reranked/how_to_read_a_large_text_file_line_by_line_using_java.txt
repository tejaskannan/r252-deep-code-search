private static BomCharset detectCharsetFromBom ( final ByteBuffer byteData ) { final Buffer buffer = byteData ; buffer . mark ( ) ; byte [ ] bom = new byte [ 4 ] ; if ( byteData . remaining ( ) >= bom . length ) { byteData . get ( bom ) ; buffer . rewind ( ) ; } if ( bom [ 0 ] == 00 && bom [ 1 ] == 00 && bom [ 2 ] == ( byte ) fe && bom [ 3 ] == ( byte ) ff || bom [ 0 ] == ( byte ) ff && bom [ 1 ] == ( byte ) fe && bom [ 2 ] == 00 && bom [ 3 ] == 00 ) { return new BomCharset ( "utf-32" , false ) ; } else if ( bom [ 0 ] == ( byte ) fe && bom [ 1 ] == ( byte ) ff || bom [ 0 ] == ( byte ) ff && bom [ 1 ] == ( byte ) fe ) { return new BomCharset ( "utf-16" , false ) ; } else if ( bom [ 0 ] == ( byte ) ef && bom [ 1 ] == ( byte ) bb && bom [ 2 ] == ( byte ) bf ) { return new BomCharset ( "utf-8" , true ) ; } return null ; }
--------------------------------------------------
private boolean exitTableBody ( Token t , HtmlTreeBuilder tb ) { if ( ! ( tb . inTableScope ( "tbody" ) || tb . inTableScope ( "thead" ) || tb . inScope ( "tfoot" ) ) ) { tb . error ( this ) ; return false ; } tb . clearStackToTableBodyContext ( ) ; tb . processEndTag ( tb . currentElement ( ) . normalName ( ) ) ; return tb . process ( t ) ; }
--------------------------------------------------
boolean anythingElse ( Token t , HtmlTreeBuilder tb ) { tb . error ( this ) ; boolean processed ; if ( StringUtil . in ( tb . currentElement ( ) . normalName ( ) , "table" , "tbody" , "tfoot" , "thead" , "tr" ) ) { tb . setFosterInserts ( true ) ; processed = tb . process ( t , InBody ) ; tb . setFosterInserts ( false ) ; } else { processed = tb . process ( t , InBody ) ; } return processed ; }
--------------------------------------------------
static Document parseInputStream ( InputStream input , String charsetName , String baseUri , Parser parser ) throws IOException { if ( input == null ) return new Document ( baseUri ) ; input = ConstrainableInputStream . wrap ( input , bufferSize , 0 ) ; Document doc = null ; boolean fullyRead = false ; input . mark ( bufferSize ) ; ByteBuffer firstBytes = readToByteBuffer ( input , firstReadBufferSize - 1 ) ; fullyRead = input . read ( ) == - 1 ; input . reset ( ) ; BomCharset bomCharset = detectCharsetFromBom ( firstBytes ) ; if ( bomCharset != null ) charsetName = bomCharset . charset ; if ( charsetName == null ) { String docData = Charset . forName ( defaultCharset ) . decode ( firstBytes ) . toString ( ) ; doc = parser . parseInput ( docData , baseUri ) ; Elements metaElements = doc . select ( "meta[http-equiv=content-type], meta[charset]" ) ; String foundCharset = null ; for ( Element meta : metaElements ) { if ( meta . hasAttr ( "http-equiv" ) ) foundCharset = getCharsetFromContentType ( meta . attr ( "content" ) ) ; if ( foundCharset == null && meta . hasAttr ( "charset" ) ) foundCharset = meta . attr ( "charset" ) ; if ( foundCharset != null ) break ; } if ( foundCharset == null && doc . childNodeSize ( ) > 0 ) { Node first = doc . childNode ( 0 ) ; XmlDeclaration decl = null ; if ( first instanceof XmlDeclaration ) decl = ( XmlDeclaration ) first ; else if ( first instanceof Comment ) { Comment comment = ( Comment ) first ; if ( comment . isXmlDeclaration ( ) ) decl = comment . asXmlDeclaration ( ) ; } if ( decl != null ) { if ( decl . name ( ) . equalsIgnoreCase ( "xml" ) ) foundCharset = decl . attr ( "encoding" ) ; } } foundCharset = validateCharset ( foundCharset ) ; if ( foundCharset != null && ! foundCharset . equalsIgnoreCase ( defaultCharset ) ) { foundCharset = foundCharset . trim ( ) . replaceAll ( "["']" , "" ) ; charsetName = foundCharset ; doc = null ; } else if ( ! fullyRead ) { doc = null ; } } else { Validate . notEmpty ( charsetName , "must set charset arg to character set of file to parse. set to null to attempt to detect from html" ) ; } if ( doc == null ) { if ( charsetName == null ) charsetName = defaultCharset ; BufferedReader reader = new BufferedReader ( new InputStreamReader ( input , charsetName ) , bufferSize ) ; if ( bomCharset != null && bomCharset . offset ) reader . skip ( 1 ) ; try { doc = parser . parseInput ( reader , baseUri ) ; } catch ( UncheckedIOException e ) { throw e . ioException ( ) ; } Charset charset = Charset . forName ( charsetName ) ; doc . outputSettings ( ) . charset ( charset ) ; if ( ! charset . canEncode ( ) ) { doc . charset ( Charset . forName ( defaultCharset ) ) ; } } input . close ( ) ; return doc ; }
--------------------------------------------------
private boolean anythingElse ( Token t , TreeBuilder tb ) { boolean processed = tb . processEndTag ( "colgroup" ) ; if ( processed ) return tb . process ( t ) ; return true ; }
--------------------------------------------------
public static List < Node > parseFragment ( String fragmentHtml , Element context , String baseUri , ParseErrorList errorList ) { HtmlTreeBuilder treeBuilder = new HtmlTreeBuilder ( ) ; Parser parser = new Parser ( treeBuilder ) ; parser . errors = errorList ; return treeBuilder . parseFragment ( fragmentHtml , context , baseUri , parser ) ; }
--------------------------------------------------
private void findElements ( ) { if ( tq . matchChomp ( "#" ) ) byId ( ) ; else if ( tq . matchChomp ( "." ) ) byClass ( ) ; else if ( tq . matchesWord ( ) || tq . matches ( "*|" ) ) byTag ( ) ; else if ( tq . matches ( "[" ) ) byAttribute ( ) ; else if ( tq . matchChomp ( "*" ) ) allElements ( ) ; else if ( tq . matchChomp ( ":lt(" ) ) indexLessThan ( ) ; else if ( tq . matchChomp ( ":gt(" ) ) indexGreaterThan ( ) ; else if ( tq . matchChomp ( ":eq(" ) ) indexEquals ( ) ; else if ( tq . matches ( ":has(" ) ) has ( ) ; else if ( tq . matches ( ":contains(" ) ) contains ( false ) ; else if ( tq . matches ( ":containsown(" ) ) contains ( true ) ; else if ( tq . matches ( ":containsdata(" ) ) containsData ( ) ; else if ( tq . matches ( ":matches(" ) ) matches ( false ) ; else if ( tq . matches ( ":matchesown(" ) ) matches ( true ) ; else if ( tq . matches ( ":not(" ) ) not ( ) ; else if ( tq . matchChomp ( ":nth-child(" ) ) cssNthChild ( false , false ) ; else if ( tq . matchChomp ( ":nth-last-child(" ) ) cssNthChild ( true , false ) ; else if ( tq . matchChomp ( ":nth-of-type(" ) ) cssNthChild ( false , true ) ; else if ( tq . matchChomp ( ":nth-last-of-type(" ) ) cssNthChild ( true , true ) ; else if ( tq . matchChomp ( ":first-child" ) ) evals . add ( new Evaluator . IsFirstChild ( ) ) ; else if ( tq . matchChomp ( ":last-child" ) ) evals . add ( new Evaluator . IsLastChild ( ) ) ; else if ( tq . matchChomp ( ":first-of-type" ) ) evals . add ( new Evaluator . IsFirstOfType ( ) ) ; else if ( tq . matchChomp ( ":last-of-type" ) ) evals . add ( new Evaluator . IsLastOfType ( ) ) ; else if ( tq . matchChomp ( ":only-child" ) ) evals . add ( new Evaluator . IsOnlyChild ( ) ) ; else if ( tq . matchChomp ( ":only-of-type" ) ) evals . add ( new Evaluator . IsOnlyOfType ( ) ) ; else if ( tq . matchChomp ( ":empty" ) ) evals . add ( new Evaluator . IsEmpty ( ) ) ; else if ( tq . matchChomp ( ":root" ) ) evals . add ( new Evaluator . IsRoot ( ) ) ; else if ( tq . matchChomp ( ":matchtext" ) ) evals . add ( new Evaluator . MatchText ( ) ) ; else throw new Selector . SelectorParseException ( "could not parse query '%s': unexpected token at '%s'" , query , tq . remainder ( ) ) ; }
--------------------------------------------------
> parseFragment ( String inputFragment , Element context , String baseUri , Parser parser ) { state = HtmlTreeBuilderState . Initial ; initialiseParse ( new StringReader ( inputFragment ) , baseUri , parser ) ; contextElement = context ; fragmentParsing = true ; Element root = null ; if ( context != null ) { if ( context . ownerDocument ( ) != null ) doc . quirksMode ( context . ownerDocument ( ) . quirksMode ( ) ) ; String contextTag = context . tagName ( ) ; if ( StringUtil . in ( contextTag , "title" , "textarea" ) ) tokeniser . transition ( TokeniserState . Rcdata ) ; else if ( StringUtil . in ( contextTag , "iframe" , "noembed" , "noframes" , "style" , "xmp" ) ) tokeniser . transition ( TokeniserState . Rawtext ) ; else if ( contextTag . equals ( "script" ) ) tokeniser . transition ( TokeniserState . ScriptData ) ; else if ( contextTag . equals ( ( "noscript" ) ) ) tokeniser . transition ( TokeniserState . Data ) ; else if ( contextTag . equals ( "plaintext" ) ) tokeniser . transition ( TokeniserState . Data ) ; else tokeniser . transition ( TokeniserState . Data ) ; root = new Element ( Tag . valueOf ( "html" , settings ) , baseUri ) ; doc . appendChild ( root ) ; stack . add ( root ) ; resetInsertionMode ( ) ; Elements contextChain = context . parents ( ) ; contextChain . add ( 0 , context ) ; for ( Element parent : contextChain ) { if ( parent instanceof FormElement ) { formElement = ( FormElement ) parent ; break ; } } } runParser ( ) ; if ( context != null ) return root . childNodes ( ) ; else return doc . childNodes ( ) ; }
--------------------------------------------------
private boolean anythingElse ( Token t , HtmlTreeBuilder tb ) { tb . insertStartTag ( "html" ) ; tb . transition ( BeforeHead ) ; return tb . process ( t ) ; }
--------------------------------------------------
String consumeLetterThenDigitSequence ( ) { bufferUp ( ) ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ; if ( ( c >= 'a' && c <= 'z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; else break ; } while ( ! isEmptyNoBufferUp ( ) ) { char c = charBuf [ bufPos ] ; if ( c >= '0' && c <= '9' ) bufPos ++ ; else break ; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; }
--------------------------------------------------
