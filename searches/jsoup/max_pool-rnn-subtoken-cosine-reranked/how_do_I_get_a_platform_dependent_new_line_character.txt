int [ ] consumeCharacterReference ( Character additionalAllowedCharacter , boolean inAttribute ) { if ( reader . isEmpty ( ) ) return null ; if ( additionalAllowedCharacter != null && additionalAllowedCharacter == reader . current ( ) ) return null ; if ( reader . matchesAnySorted ( notCharRefCharsSorted ) ) return null ; final int [ ] codeRef = codepointHolder ; reader . mark ( ) ; if ( reader . matchConsume ( "#" ) ) { boolean isHexMode = reader . matchConsumeIgnoreCase ( "x" ) ; String numRef = isHexMode ? reader . consumeHexSequence ( ) : reader . consumeDigitSequence ( ) ; if ( numRef . length ( ) == 0 ) { characterReferenceError ( "numeric reference with no numerals" ) ; reader . rewindToMark ( ) ; return null ; } if ( ! reader . matchConsume ( ";" ) ) characterReferenceError ( "missing semicolon" ) ; int charval = - 1 ; try { int base = isHexMode ? 16 : 10 ; charval = Integer . valueOf ( numRef , base ) ; } catch ( NumberFormatException ignored ) { } if ( charval == - 1 || ( charval >= d800 && charval <= dfff ) || charval > 10ffff ) { characterReferenceError ( "character outside of valid range" ) ; codeRef [ 0 ] = replacementChar ; return codeRef ; } else { if ( charval >= win1252ExtensionsStart && charval < win1252ExtensionsStart + win1252Extensions . length ) { characterReferenceError ( "character is not a valid unicode code point" ) ; charval = win1252Extensions [ charval - win1252ExtensionsStart ] ; } codeRef [ 0 ] = charval ; return codeRef ; } } else { String nameRef = reader . consumeLetterThenDigitSequence ( ) ; boolean looksLegit = reader . matches ( ';' ) ; boolean found = ( Entities . isBaseNamedEntity ( nameRef ) || ( Entities . isNamedEntity ( nameRef ) && looksLegit ) ) ; if ( ! found ) { reader . rewindToMark ( ) ; if ( looksLegit ) characterReferenceError ( String . format ( "invalid named reference '%s'" , nameRef ) ) ; return null ; } if ( inAttribute && ( reader . matchesLetter ( ) || reader . matchesDigit ( ) || reader . matchesAny ( '=' , '-' , '_' ) ) ) { reader . rewindToMark ( ) ; return null ; } if ( ! reader . matchConsume ( ";" ) ) characterReferenceError ( "missing semicolon" ) ; int numChars = Entities . codepointsForName ( nameRef , multipointHolder ) ; if ( numChars == 1 ) { codeRef [ 0 ] = multipointHolder [ 0 ] ; return codeRef ; } else if ( numChars == 2 ) { return multipointHolder ; } else { Validate . fail ( "unexpected characters returned for " + nameRef ) ; return multipointHolder ; } } }
--------------------------------------------------
private void getWholeDeclaration ( Appendable accum , Document . OutputSettings out ) throws IOException { for ( Attribute attribute : attributes ( ) ) { if ( ! attribute . getKey ( ) . equals ( nodeName ( ) ) ) { accum . append ( ' ' ) ; attribute . html ( accum , out ) ; } } }
--------------------------------------------------
public String getWholeDeclaration ( ) { StringBuilder sb = StringUtil . borrowBuilder ( ) ; try { getWholeDeclaration ( sb , new Document . OutputSettings ( ) ) ; } catch ( IOException e ) { throw new SerializationException ( e ) ; } return StringUtil . releaseBuilder ( sb ) . trim ( ) ; }
--------------------------------------------------
private static BomCharset detectCharsetFromBom ( final ByteBuffer byteData ) { final Buffer buffer = byteData ; buffer . mark ( ) ; byte [ ] bom = new byte [ 4 ] ; if ( byteData . remaining ( ) >= bom . length ) { byteData . get ( bom ) ; buffer . rewind ( ) ; } if ( bom [ 0 ] == 00 && bom [ 1 ] == 00 && bom [ 2 ] == ( byte ) fe && bom [ 3 ] == ( byte ) ff || bom [ 0 ] == ( byte ) ff && bom [ 1 ] == ( byte ) fe && bom [ 2 ] == 00 && bom [ 3 ] == 00 ) { return new BomCharset ( "utf-32" , false ) ; } else if ( bom [ 0 ] == ( byte ) fe && bom [ 1 ] == ( byte ) ff || bom [ 0 ] == ( byte ) ff && bom [ 1 ] == ( byte ) fe ) { return new BomCharset ( "utf-16" , false ) ; } else if ( bom [ 0 ] == ( byte ) ef && bom [ 1 ] == ( byte ) bb && bom [ 2 ] == ( byte ) bf ) { return new BomCharset ( "utf-8" , true ) ; } return null ; }
--------------------------------------------------
public String getPlainText ( Element element ) { FormattingVisitor formatter = new FormattingVisitor ( ) ; NodeTraversor . traverse ( formatter , element ) ; return formatter . toString ( ) ; }
--------------------------------------------------
public Elements getElementsMatchingOwnText ( String regex ) { Pattern pattern ; try { pattern = Pattern . compile ( regex ) ; } catch ( PatternSyntaxException e ) { throw new IllegalArgumentException ( "pattern syntax error: " + regex , e ) ; } return getElementsMatchingOwnText ( pattern ) ; }
--------------------------------------------------
String unescapeEntities ( boolean inAttribute ) { StringBuilder builder = StringUtil . borrowBuilder ( ) ; while ( ! reader . isEmpty ( ) ) { builder . append ( reader . consumeTo ( '&' ) ) ; if ( reader . matches ( '&' ) ) { reader . consume ( ) ; int [ ] c = consumeCharacterReference ( null , inAttribute ) ; if ( c == null || c . length == 0 ) builder . append ( '&' ) ; else { builder . appendCodePoint ( c [ 0 ] ) ; if ( c . length == 2 ) builder . appendCodePoint ( c [ 1 ] ) ; } } } return StringUtil . releaseBuilder ( builder ) ; }
--------------------------------------------------
private void setupFromConnection ( HttpURLConnection conn , HttpConnection . Response previousResponse ) throws IOException { this . conn = conn ; method = Method . valueOf ( conn . getRequestMethod ( ) ) ; url = conn . getURL ( ) ; statusCode = conn . getResponseCode ( ) ; statusMessage = conn . getResponseMessage ( ) ; contentType = conn . getContentType ( ) ; Map < String , List < String >> resHeaders = createHeaderMap ( conn ) ; processResponseHeaders ( resHeaders ) ; if ( previousResponse != null ) { for ( Map . Entry < String , String > prevCookie : previousResponse . cookies ( ) . entrySet ( ) ) { if ( ! hasCookie ( prevCookie . getKey ( ) ) ) cookie ( prevCookie . getKey ( ) , prevCookie . getValue ( ) ) ; } previousResponse . safeClose ( ) ; } }
--------------------------------------------------
public XmlDeclaration asXmlDeclaration ( ) { String data = getData ( ) ; Document doc = Jsoup . parse ( "<" + data . substring ( 1 , data . length ( ) - 1 ) + ">" , baseUri ( ) , Parser . xmlParser ( ) ) ; XmlDeclaration decl = null ; if ( doc . children ( ) . size ( ) > 0 ) { Element el = doc . child ( 0 ) ; decl = new XmlDeclaration ( NodeUtils . parser ( doc ) . settings ( ) . normalizeTag ( el . tagName ( ) ) , data . startsWith ( "!" ) ) ; decl . attributes ( ) . addAll ( el . attributes ( ) ) ; } return decl ; }
--------------------------------------------------
private boolean exitTableBody ( Token t , HtmlTreeBuilder tb ) { if ( ! ( tb . inTableScope ( "tbody" ) || tb . inTableScope ( "thead" ) || tb . inScope ( "tfoot" ) ) ) { tb . error ( this ) ; return false ; } tb . clearStackToTableBodyContext ( ) ; tb . processEndTag ( tb . currentElement ( ) . normalName ( ) ) ; return tb . process ( t ) ; }
--------------------------------------------------
