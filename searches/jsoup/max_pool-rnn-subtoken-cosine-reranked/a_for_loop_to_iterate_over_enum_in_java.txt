private boolean exitTableBody ( Token t , HtmlTreeBuilder tb ) { if ( ! ( tb . inTableScope ( "tbody" ) || tb . inTableScope ( "thead" ) || tb . inScope ( "tfoot" ) ) ) { tb . error ( this ) ; return false ; } tb . clearStackToTableBodyContext ( ) ; tb . processEndTag ( tb . currentElement ( ) . normalName ( ) ) ; return tb . process ( t ) ; }
--------------------------------------------------
String consumeLetterThenDigitSequence ( ) { bufferUp ( ) ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ; if ( ( c >= 'a' && c <= 'z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; else break ; } while ( ! isEmptyNoBufferUp ( ) ) { char c = charBuf [ bufPos ] ; if ( c >= '0' && c <= '9' ) bufPos ++ ; else break ; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; }
--------------------------------------------------
public Connection timeout ( int millis ) { req . timeout ( millis ) ; return this ; }
--------------------------------------------------
private static BomCharset detectCharsetFromBom ( final ByteBuffer byteData ) { final Buffer buffer = byteData ; buffer . mark ( ) ; byte [ ] bom = new byte [ 4 ] ; if ( byteData . remaining ( ) >= bom . length ) { byteData . get ( bom ) ; buffer . rewind ( ) ; } if ( bom [ 0 ] == 00 && bom [ 1 ] == 00 && bom [ 2 ] == ( byte ) fe && bom [ 3 ] == ( byte ) ff || bom [ 0 ] == ( byte ) ff && bom [ 1 ] == ( byte ) fe && bom [ 2 ] == 00 && bom [ 3 ] == 00 ) { return new BomCharset ( "utf-32" , false ) ; } else if ( bom [ 0 ] == ( byte ) fe && bom [ 1 ] == ( byte ) ff || bom [ 0 ] == ( byte ) ff && bom [ 1 ] == ( byte ) fe ) { return new BomCharset ( "utf-16" , false ) ; } else if ( bom [ 0 ] == ( byte ) ef && bom [ 1 ] == ( byte ) bb && bom [ 2 ] == ( byte ) bf ) { return new BomCharset ( "utf-8" , true ) ; } return null ; }
--------------------------------------------------
int [ ] consumeCharacterReference ( Character additionalAllowedCharacter , boolean inAttribute ) { if ( reader . isEmpty ( ) ) return null ; if ( additionalAllowedCharacter != null && additionalAllowedCharacter == reader . current ( ) ) return null ; if ( reader . matchesAnySorted ( notCharRefCharsSorted ) ) return null ; final int [ ] codeRef = codepointHolder ; reader . mark ( ) ; if ( reader . matchConsume ( "#" ) ) { boolean isHexMode = reader . matchConsumeIgnoreCase ( "x" ) ; String numRef = isHexMode ? reader . consumeHexSequence ( ) : reader . consumeDigitSequence ( ) ; if ( numRef . length ( ) == 0 ) { characterReferenceError ( "numeric reference with no numerals" ) ; reader . rewindToMark ( ) ; return null ; } if ( ! reader . matchConsume ( ";" ) ) characterReferenceError ( "missing semicolon" ) ; int charval = - 1 ; try { int base = isHexMode ? 16 : 10 ; charval = Integer . valueOf ( numRef , base ) ; } catch ( NumberFormatException ignored ) { } if ( charval == - 1 || ( charval >= d800 && charval <= dfff ) || charval > 10ffff ) { characterReferenceError ( "character outside of valid range" ) ; codeRef [ 0 ] = replacementChar ; return codeRef ; } else { if ( charval >= win1252ExtensionsStart && charval < win1252ExtensionsStart + win1252Extensions . length ) { characterReferenceError ( "character is not a valid unicode code point" ) ; charval = win1252Extensions [ charval - win1252ExtensionsStart ] ; } codeRef [ 0 ] = charval ; return codeRef ; } } else { String nameRef = reader . consumeLetterThenDigitSequence ( ) ; boolean looksLegit = reader . matches ( ';' ) ; boolean found = ( Entities . isBaseNamedEntity ( nameRef ) || ( Entities . isNamedEntity ( nameRef ) && looksLegit ) ) ; if ( ! found ) { reader . rewindToMark ( ) ; if ( looksLegit ) characterReferenceError ( String . format ( "invalid named reference '%s'" , nameRef ) ) ; return null ; } if ( inAttribute && ( reader . matchesLetter ( ) || reader . matchesDigit ( ) || reader . matchesAny ( '=' , '-' , '_' ) ) ) { reader . rewindToMark ( ) ; return null ; } if ( ! reader . matchConsume ( ";" ) ) characterReferenceError ( "missing semicolon" ) ; int numChars = Entities . codepointsForName ( nameRef , multipointHolder ) ; if ( numChars == 1 ) { codeRef [ 0 ] = multipointHolder [ 0 ] ; return codeRef ; } else if ( numChars == 2 ) { return multipointHolder ; } else { Validate . fail ( "unexpected characters returned for " + nameRef ) ; return multipointHolder ; } } }
--------------------------------------------------
private boolean inSpecificScope ( String [ ] targetNames , String [ ] baseTypes , String [ ] extraTypes ) { final int bottom = stack . size ( ) - 1 ; final int top = bottom > MaxScopeSearchDepth ? bottom - MaxScopeSearchDepth : 0 ; for ( int pos = bottom ; pos >= top ; pos -- ) { final String elName = stack . get ( pos ) . normalName ( ) ; if ( inSorted ( elName , targetNames ) ) return true ; if ( inSorted ( elName , baseTypes ) ) return false ; if ( extraTypes != null && inSorted ( elName , extraTypes ) ) return false ; } return false ; }
--------------------------------------------------
public String consumeToAny ( final char ... chars ) { bufferUp ( ) ; int pos = bufPos ; final int start = pos ; final int remaining = bufLength ; final char [ ] val = charBuf ; final int charLen = chars . length ; int i ; OUTER : while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) break OUTER ; } pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : "" ; }
--------------------------------------------------
private static void serialiseRequestUrl ( Connection . Request req ) throws IOException { URL in = req . url ( ) ; StringBuilder url = StringUtil . borrowBuilder ( ) ; boolean first = true ; url . append ( in . getProtocol ( ) ) . append ( "://" ) . append ( in . getAuthority ( ) ) . append ( in . getPath ( ) ) . append ( "?" ) ; if ( in . getQuery ( ) != null ) { url . append ( in . getQuery ( ) ) ; first = false ; } for ( Connection . KeyVal keyVal : req . data ( ) ) { Validate . isFalse ( keyVal . hasInputStream ( ) , "inputstream data not supported in url query string." ) ; if ( ! first ) url . append ( '&' ) ; else first = false ; url . append ( URLEncoder . encode ( keyVal . key ( ) , DataUtil . defaultCharset ) ) . append ( '=' ) . append ( URLEncoder . encode ( keyVal . value ( ) , DataUtil . defaultCharset ) ) ; } req . url ( new URL ( StringUtil . releaseBuilder ( url ) ) ) ; req . data ( ) . clear ( ) ; }
--------------------------------------------------
String consumeDigitSequence ( ) { bufferUp ( ) ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ; if ( c >= '0' && c <= '9' ) bufPos ++ ; else break ; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; }
--------------------------------------------------
public BufferedInputStream bodyStream ( ) { Validate . isTrue ( executed , "request must be executed (with .execute(), .get(), or .post() before getting response body" ) ; Validate . isFalse ( inputStreamRead , "request has already been read" ) ; inputStreamRead = true ; return ConstrainableInputStream . wrap ( bodyStream , DataUtil . bufferSize , req . maxBodySize ( ) ) ; }
--------------------------------------------------
