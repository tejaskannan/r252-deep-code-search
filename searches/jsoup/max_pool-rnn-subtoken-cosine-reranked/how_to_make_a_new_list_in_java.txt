private List < Element > childElementsList ( ) { List < Element > children ; if ( shadowChildrenRef == null || ( children = shadowChildrenRef . get ( ) ) == null ) { final int size = childNodes . size ( ) ; children = new ArrayList < > ( size ) ; for ( int i = 0 ; i < size ; i ++ ) { final Node node = childNodes . get ( i ) ; if ( node instanceof Element ) children . add ( ( Element ) node ) ; } shadowChildrenRef = new WeakReference < > ( children ) ; } return children ; }
--------------------------------------------------
void pushActiveFormattingElements ( Element in ) { int numSeen = 0 ; for ( int pos = formattingElements . size ( ) - 1 ; pos >= 0 ; pos -- ) { Element el = formattingElements . get ( pos ) ; if ( el == null ) break ; if ( isSameFormattingElement ( in , el ) ) numSeen ++ ; if ( numSeen == 3 ) { formattingElements . remove ( pos ) ; break ; } } formattingElements . add ( in ) ; }
--------------------------------------------------
void clearFormattingElementsToLastMarker ( ) { while ( ! formattingElements . isEmpty ( ) ) { Element el = removeLastFormattingElement ( ) ; if ( el == null ) break ; } }
--------------------------------------------------
public CharacterReader ( Reader input , int sz ) { Validate . notNull ( input ) ; Validate . isTrue ( input . markSupported ( ) ) ; reader = input ; charBuf = new char [ sz > maxBufferLen ? maxBufferLen : sz ] ; bufferUp ( ) ; }
--------------------------------------------------
static void crossStreams ( final InputStream in , final OutputStream out ) throws IOException { final byte [ ] buffer = new byte [ bufferSize ] ; int len ; while ( ( len = in . read ( buffer ) ) != - 1 ) { out . write ( buffer , 0 , len ) ; } }
--------------------------------------------------
public String wholeText ( ) { final StringBuilder accum = StringUtil . borrowBuilder ( ) ; NodeTraversor . traverse ( new NodeVisitor ( ) { public void head ( Node node , int depth ) { if ( node instanceof TextNode ) { TextNode textNode = ( TextNode ) node ; accum . append ( textNode . getWholeText ( ) ) ; } } public void tail ( Node node , int depth ) { } } , this ) ; return StringUtil . releaseBuilder ( accum ) ; }
--------------------------------------------------
static String mimeBoundary ( ) { final StringBuilder mime = StringUtil . borrowBuilder ( ) ; final Random rand = new Random ( ) ; for ( int i = 0 ; i < boundaryLength ; i ++ ) { mime . append ( mimeBoundaryChars [ rand . nextInt ( mimeBoundaryChars . length ) ] ) ; } return StringUtil . releaseBuilder ( mime ) ; }
--------------------------------------------------
boolean anyOtherEndTag ( Token t , HtmlTreeBuilder tb ) { String name = t . asEndTag ( ) . normalName ; ArrayList < Element > stack = tb . getStack ( ) ; for ( int pos = stack . size ( ) - 1 ; pos >= 0 ; pos -- ) { Element node = stack . get ( pos ) ; if ( node . normalName ( ) . equals ( name ) ) { tb . generateImpliedEndTags ( name ) ; if ( ! name . equals ( tb . currentElement ( ) . normalName ( ) ) ) tb . error ( this ) ; tb . popStackToClose ( name ) ; break ; } else { if ( tb . isSpecial ( node ) ) { tb . error ( this ) ; return false ; } } } return true ; }
--------------------------------------------------
private boolean inSpecificScope ( String [ ] targetNames , String [ ] baseTypes , String [ ] extraTypes ) { final int bottom = stack . size ( ) - 1 ; final int top = bottom > MaxScopeSearchDepth ? bottom - MaxScopeSearchDepth : 0 ; for ( int pos = bottom ; pos >= top ; pos -- ) { final String elName = stack . get ( pos ) . normalName ( ) ; if ( inSorted ( elName , targetNames ) ) return true ; if ( inSorted ( elName , baseTypes ) ) return false ; if ( extraTypes != null && inSorted ( elName , extraTypes ) ) return false ; } return false ; }
--------------------------------------------------
private boolean anythingElse ( Token t , HtmlTreeBuilder tb ) { tb . insertStartTag ( "html" ) ; tb . transition ( BeforeHead ) ; return tb . process ( t ) ; }
--------------------------------------------------
