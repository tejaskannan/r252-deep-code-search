public static void appendNormalisedWhitespace ( StringBuilder accum , String string , boolean stripLeading ) { boolean lastWasWhite = false ; boolean reachedNonWhite = false ; int len = string . length ( ) ; int c ; for ( int i = 0 ; i < len ; i += Character . charCount ( c ) ) { c = string . codePointAt ( i ) ; if ( isActuallyWhitespace ( c ) ) { if ( ( stripLeading && ! reachedNonWhite ) || lastWasWhite ) continue ; accum . append ( ' ' ) ; lastWasWhite = true ; } else if ( ! isInvisibleChar ( c ) ) { accum . appendCodePoint ( c ) ; lastWasWhite = false ; reachedNonWhite = true ; } } }
--------------------------------------------------
public String consumeToIgnoreCase ( String seq ) { int start = pos ; String first = seq . substring ( 0 , 1 ) ; boolean canScan = first . toLowerCase ( ) . equals ( first . toUpperCase ( ) ) ; while ( ! isEmpty ( ) ) { if ( matches ( seq ) ) break ; if ( canScan ) { int skip = queue . indexOf ( first , pos ) - pos ; if ( skip == 0 ) pos ++ ; else if ( skip < 0 ) pos = queue . length ( ) ; else pos += skip ; } else pos ++ ; } return queue . substring ( start , pos ) ; }
--------------------------------------------------
private void ownText ( StringBuilder accum ) { for ( Node child : childNodes ) { if ( child instanceof TextNode ) { TextNode textNode = ( TextNode ) child ; appendNormalisedText ( accum , textNode ) ; } else if ( child instanceof Element ) { appendWhitespaceIfBr ( ( Element ) child , accum ) ; } } }
--------------------------------------------------
static void escape ( Appendable accum , String string , Document . OutputSettings out , boolean inAttribute , boolean normaliseWhite , boolean stripLeadingWhite ) throws IOException { boolean lastWasWhite = false ; boolean reachedNonWhite = false ; final EscapeMode escapeMode = out . escapeMode ( ) ; final CharsetEncoder encoder = out . encoder ( ) ; final CoreCharset coreCharset = out . coreCharset ; final int length = string . length ( ) ; int codePoint ; for ( int offset = 0 ; offset < length ; offset += Character . charCount ( codePoint ) ) { codePoint = string . codePointAt ( offset ) ; if ( normaliseWhite ) { if ( StringUtil . isWhitespace ( codePoint ) ) { if ( ( stripLeadingWhite && ! reachedNonWhite ) || lastWasWhite ) continue ; accum . append ( ' ' ) ; lastWasWhite = true ; continue ; } else { lastWasWhite = false ; reachedNonWhite = true ; } } if ( codePoint < Character . MIN_SUPPLEMENTARY_CODE_POINT ) { final char c = ( char ) codePoint ; switch ( c ) { case '&' : accum . append ( "&amp;" ) ; break ; case a0 : if ( escapeMode != EscapeMode . xhtml ) accum . append ( "&nbsp;" ) ; else accum . append ( "&#xa0;" ) ; break ; case '<' : if ( ! inAttribute || escapeMode == EscapeMode . xhtml ) accum . append ( "&lt;" ) ; else accum . append ( c ) ; break ; case '>' : if ( ! inAttribute ) accum . append ( "&gt;" ) ; else accum . append ( c ) ; break ; case '"' : if ( inAttribute ) accum . append ( "&quot;" ) ; else accum . append ( c ) ; break ; default : if ( canEncode ( coreCharset , c , encoder ) ) accum . append ( c ) ; else appendEncoded ( accum , escapeMode , codePoint ) ; } } else { final String c = new String ( Character . toChars ( codePoint ) ) ; if ( encoder . canEncode ( c ) ) accum . append ( c ) ; else appendEncoded ( accum , escapeMode , codePoint ) ; } } }
--------------------------------------------------
public String consumeToAny ( String ... seq ) { int start = pos ; while ( ! isEmpty ( ) && ! matchesAny ( seq ) ) { pos ++ ; } return queue . substring ( start , pos ) ; }
--------------------------------------------------
boolean anythingElse ( Token t , HtmlTreeBuilder tb ) { tb . error ( this ) ; boolean processed ; if ( StringUtil . in ( tb . currentElement ( ) . normalName ( ) , "table" , "tbody" , "tfoot" , "thead" , "tr" ) ) { tb . setFosterInserts ( true ) ; processed = tb . process ( t , InBody ) ; tb . setFosterInserts ( false ) ; } else { processed = tb . process ( t , InBody ) ; } return processed ; }
--------------------------------------------------
public String text ( ) { StringBuilder sb = StringUtil . borrowBuilder ( ) ; for ( Element element : this ) { if ( sb . length ( ) != 0 ) sb . append ( " " ) ; sb . append ( element . text ( ) ) ; } return StringUtil . releaseBuilder ( sb ) ; }
--------------------------------------------------
public String getPlainText ( Element element ) { FormattingVisitor formatter = new FormattingVisitor ( ) ; NodeTraversor . traverse ( formatter , element ) ; return formatter . toString ( ) ; }
--------------------------------------------------
private String consumeSubQuery ( ) { StringBuilder sq = StringUtil . borrowBuilder ( ) ; while ( ! tq . isEmpty ( ) ) { if ( tq . matches ( "(" ) ) sq . append ( "(" ) . append ( tq . chompBalanced ( '(' , ')' ) ) . append ( ")" ) ; else if ( tq . matches ( "[" ) ) sq . append ( "[" ) . append ( tq . chompBalanced ( '[' , ']' ) ) . append ( "]" ) ; else if ( tq . matchesAny ( combinators ) ) break ; else sq . append ( tq . consume ( ) ) ; } return StringUtil . releaseBuilder ( sq ) ; }
--------------------------------------------------
String consumeHexSequence ( ) { bufferUp ( ) ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ; if ( ( c >= '0' && c <= '9' ) || ( c >= 'a' && c <= 'f' ) || ( c >= 'a' && c <= 'f' ) ) bufPos ++ ; else break ; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; }
--------------------------------------------------
