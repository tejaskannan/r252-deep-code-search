void outerHtmlHead ( Appendable accum , int depth , Document . OutputSettings out ) throws IOException { accum . append ( "<" ) . append ( isProcessingInstruction ? "!" : "?" ) . append ( coreValue ( ) ) ; getWholeDeclaration ( accum , out ) ; accum . append ( isProcessingInstruction ? "!" : "?" ) . append ( ">" ) ; }
--------------------------------------------------
void putIgnoreCase ( String key , String value ) { int i = indexOfKeyIgnoreCase ( key ) ; if ( i != NotFound ) { vals [ i ] = value ; if ( ! keys [ i ] . equals ( key ) ) keys [ i ] = key ; } else add ( key , value ) ; }
--------------------------------------------------
private String updateNamespaces ( org . jsoup . nodes . Element el ) { Attributes attributes = el . attributes ( ) ; for ( Attribute attr : attributes ) { String key = attr . getKey ( ) ; String prefix ; if ( key . equals ( xmlnsKey ) ) { prefix = "" ; } else if ( key . startsWith ( xmlnsPrefix ) ) { prefix = key . substring ( xmlnsPrefix . length ( ) ) ; } else { continue ; } namespacesStack . peek ( ) . put ( prefix , attr . getValue ( ) ) ; } int pos = el . tagName ( ) . indexOf ( ":" ) ; return pos > 0 ? el . tagName ( ) . substring ( 0 , pos ) : "" ; }
--------------------------------------------------
boolean process ( Token t , HtmlTreeBuilder tb ) { if ( t . isStartTag ( ) ) { Token . StartTag startTag = t . asStartTag ( ) ; String name = startTag . normalName ( ) ; if ( name . equals ( "template" ) ) { tb . insert ( startTag ) ; } else if ( StringUtil . in ( name , "th" , "td" ) ) { tb . clearStackToTableRowContext ( ) ; tb . insert ( startTag ) ; tb . transition ( InCell ) ; tb . insertMarkerToFormattingElements ( ) ; } else if ( StringUtil . in ( name , "caption" , "col" , "colgroup" , "tbody" , "tfoot" , "thead" , "tr" ) ) { return handleMissingTr ( t , tb ) ; } else { return anythingElse ( t , tb ) ; } } else if ( t . isEndTag ( ) ) { Token . EndTag endTag = t . asEndTag ( ) ; String name = endTag . normalName ( ) ; if ( name . equals ( "tr" ) ) { if ( ! tb . inTableScope ( name ) ) { tb . error ( this ) ; return false ; } tb . clearStackToTableRowContext ( ) ; tb . pop ( ) ; tb . transition ( InTableBody ) ; } else if ( name . equals ( "table" ) ) { return handleMissingTr ( t , tb ) ; } else if ( StringUtil . in ( name , "tbody" , "tfoot" , "thead" ) ) { if ( ! tb . inTableScope ( name ) ) { tb . error ( this ) ; return false ; } tb . processEndTag ( "tr" ) ; return tb . process ( t ) ; } else if ( StringUtil . in ( name , "body" , "caption" , "col" , "colgroup" , "html" , "td" , "th" ) ) { tb . error ( this ) ; return false ; } else { return anythingElse ( t , tb ) ; } } else { return anythingElse ( t , tb ) ; } return true ; }
--------------------------------------------------
boolean process ( Token t , HtmlTreeBuilder tb ) { if ( t . isStartTag ( ) && StringUtil . in ( t . asStartTag ( ) . normalName ( ) , "caption" , "table" , "tbody" , "tfoot" , "thead" , "tr" , "td" , "th" ) ) { tb . error ( this ) ; tb . processEndTag ( "select" ) ; return tb . process ( t ) ; } else if ( t . isEndTag ( ) && StringUtil . in ( t . asEndTag ( ) . normalName ( ) , "caption" , "table" , "tbody" , "tfoot" , "thead" , "tr" , "td" , "th" ) ) { tb . error ( this ) ; if ( tb . inTableScope ( t . asEndTag ( ) . normalName ( ) ) ) { tb . processEndTag ( "select" ) ; return ( tb . process ( t ) ) ; } else return false ; } else { return tb . process ( t , InSelect ) ; } }
--------------------------------------------------
boolean process ( Token t , HtmlTreeBuilder tb ) { if ( t . isEndTag ( ) ) { Token . EndTag endTag = t . asEndTag ( ) ; String name = endTag . normalName ( ) ; if ( StringUtil . inSorted ( name , Constants . InCellNames ) ) { if ( ! tb . inTableScope ( name ) ) { tb . error ( this ) ; tb . transition ( InRow ) ; return false ; } tb . generateImpliedEndTags ( ) ; if ( ! tb . currentElement ( ) . normalName ( ) . equals ( name ) ) tb . error ( this ) ; tb . popStackToClose ( name ) ; tb . clearFormattingElementsToLastMarker ( ) ; tb . transition ( InRow ) ; } else if ( StringUtil . inSorted ( name , Constants . InCellBody ) ) { tb . error ( this ) ; return false ; } else if ( StringUtil . inSorted ( name , Constants . InCellTable ) ) { if ( ! tb . inTableScope ( name ) ) { tb . error ( this ) ; return false ; } closeCell ( tb ) ; return tb . process ( t ) ; } else { return anythingElse ( t , tb ) ; } } else if ( t . isStartTag ( ) && StringUtil . inSorted ( t . asStartTag ( ) . normalName ( ) , Constants . InCellCol ) ) { if ( ! ( tb . inTableScope ( "td" ) || tb . inTableScope ( "th" ) ) ) { tb . error ( this ) ; return false ; } closeCell ( tb ) ; return tb . process ( t ) ; } else { return anythingElse ( t , tb ) ; } return true ; }
--------------------------------------------------
boolean process ( Token t , HtmlTreeBuilder tb ) { if ( t . isEndTag ( ) && t . asEndTag ( ) . normalName ( ) . equals ( "caption" ) ) { Token . EndTag endTag = t . asEndTag ( ) ; String name = endTag . normalName ( ) ; if ( ! tb . inTableScope ( name ) ) { tb . error ( this ) ; return false ; } else { tb . generateImpliedEndTags ( ) ; if ( ! tb . currentElement ( ) . normalName ( ) . equals ( "caption" ) ) tb . error ( this ) ; tb . popStackToClose ( "caption" ) ; tb . clearFormattingElementsToLastMarker ( ) ; tb . transition ( InTable ) ; } } else if ( ( t . isStartTag ( ) && StringUtil . in ( t . asStartTag ( ) . normalName ( ) , "caption" , "col" , "colgroup" , "tbody" , "td" , "tfoot" , "th" , "thead" , "tr" ) || t . isEndTag ( ) && t . asEndTag ( ) . normalName ( ) . equals ( "table" ) ) ) { tb . error ( this ) ; boolean processed = tb . processEndTag ( "caption" ) ; if ( processed ) return tb . process ( t ) ; } else if ( t . isEndTag ( ) && StringUtil . in ( t . asEndTag ( ) . normalName ( ) , "body" , "col" , "colgroup" , "html" , "tbody" , "td" , "tfoot" , "th" , "thead" , "tr" ) ) { tb . error ( this ) ; return false ; } else { return tb . process ( t , InBody ) ; } return true ; }
--------------------------------------------------
public String put ( String key , String value ) { String dataKey = dataKey ( key ) ; String oldValue = attributes . hasKey ( dataKey ) ? attributes . get ( dataKey ) : null ; attributes . put ( dataKey , value ) ; return oldValue ; }
--------------------------------------------------
public Node attr ( String attributeKey , String attributeValue ) { attributeKey = NodeUtils . parser ( this ) . settings ( ) . normalizeAttribute ( attributeKey ) ; attributes ( ) . putIgnoreCase ( attributeKey , attributeValue ) ; return this ; }
--------------------------------------------------
void mark ( ) { bufSplitPoint = 0 ; bufferUp ( ) ; bufMark = bufPos ; }
--------------------------------------------------
