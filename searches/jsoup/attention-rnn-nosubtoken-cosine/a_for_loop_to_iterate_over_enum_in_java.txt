void outerHtmlHead ( Appendable accum , int depth , Document . OutputSettings out ) throws IOException { accum . append ( "<" ) . append ( isProcessingInstruction ? "!" : "?" ) . append ( coreValue ( ) ) ; getWholeDeclaration ( accum , out ) ; accum . append ( isProcessingInstruction ? "!" : "?" ) . append ( ">" ) ; }
--------------------------------------------------
public Node traverse ( NodeVisitor nodeVisitor ) { Validate . notNull ( nodeVisitor ) ; NodeTraversor . traverse ( nodeVisitor , this ) ; return this ; }
--------------------------------------------------
public Elements traverse ( NodeVisitor nodeVisitor ) { NodeTraversor . traverse ( nodeVisitor , this ) ; return this ; }
--------------------------------------------------
void advanceTransition ( TokeniserState state ) { reader . advance ( ) ; this . state = state ; }
--------------------------------------------------
public static void traverse ( NodeVisitor visitor , Node root ) { Node node = root ; int depth = 0 ; while ( node != null ) { visitor . head ( node , depth ) ; if ( node . childNodeSize ( ) > 0 ) { node = node . childNode ( 0 ) ; depth ++ ; } else { while ( node . nextSibling ( ) == null && depth > 0 ) { visitor . tail ( node , depth ) ; node = node . parentNode ( ) ; depth -- ; } visitor . tail ( node , depth ) ; if ( node == root ) break ; node = node . nextSibling ( ) ; } } }
--------------------------------------------------
public static Elements collect ( Evaluator eval , Element root ) { Elements elements = new Elements ( ) ; NodeTraversor . traverse ( new Accumulator ( root , elements , eval ) , root ) ; return elements ; }
--------------------------------------------------
protected void setParentNode ( Node parentNode ) { Validate . notNull ( parentNode ) ; if ( this . parentNode != null ) this . parentNode . removeChild ( this ) ; this . parentNode = parentNode ; }
--------------------------------------------------
void outerHtmlHead ( Appendable accum , int depth , Document . OutputSettings out ) throws IOException { if ( out . prettyPrint ( ) && ( ( siblingIndex ( ) == 0 && parentNode instanceof Element && ( ( Element ) parentNode ) . tag ( ) . formatAsBlock ( ) && ! isBlank ( ) ) || ( out . outline ( ) && siblingNodes ( ) . size ( ) > 0 && ! isBlank ( ) ) ) ) indent ( accum , depth , out ) ; boolean normaliseWhite = out . prettyPrint ( ) && parent ( ) instanceof Element && ! Element . preserveWhitespace ( parent ( ) ) ; Entities . escape ( accum , coreValue ( ) , out , false , normaliseWhite , false ) ; }
--------------------------------------------------
public void head ( org . jsoup . nodes . Node source , int depth ) { namespacesStack . push ( new HashMap < > ( namespacesStack . peek ( ) ) ) ; if ( source instanceof org . jsoup . nodes . Element ) { org . jsoup . nodes . Element sourceEl = ( org . jsoup . nodes . Element ) source ; String prefix = updateNamespaces ( sourceEl ) ; String namespace = namespacesStack . peek ( ) . get ( prefix ) ; String tagName = sourceEl . tagName ( ) ; Element el = namespace == null && tagName . contains ( ":" ) ? doc . createElementNS ( "" , tagName ) : doc . createElementNS ( namespace , tagName ) ; copyAttributes ( sourceEl , el ) ; if ( dest == null ) { doc . appendChild ( el ) ; } else { dest . appendChild ( el ) ; } dest = el ; } else if ( source instanceof org . jsoup . nodes . TextNode ) { org . jsoup . nodes . TextNode sourceText = ( org . jsoup . nodes . TextNode ) source ; Text text = doc . createTextNode ( sourceText . getWholeText ( ) ) ; dest . appendChild ( text ) ; } else if ( source instanceof org . jsoup . nodes . Comment ) { org . jsoup . nodes . Comment sourceComment = ( org . jsoup . nodes . Comment ) source ; Comment comment = doc . createComment ( sourceComment . getData ( ) ) ; dest . appendChild ( comment ) ; } else if ( source instanceof org . jsoup . nodes . DataNode ) { org . jsoup . nodes . DataNode sourceData = ( org . jsoup . nodes . DataNode ) source ; Text node = doc . createTextNode ( sourceData . getWholeData ( ) ) ; dest . appendChild ( node ) ; } else { } }
--------------------------------------------------
public void head ( Node node , int depth ) { try { node . outerHtmlHead ( accum , depth , out ) ; } catch ( IOException exception ) { throw new SerializationException ( exception ) ; } }
--------------------------------------------------
