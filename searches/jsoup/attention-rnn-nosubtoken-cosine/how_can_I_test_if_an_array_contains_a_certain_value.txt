private boolean testValidProtocol ( Element el , Attribute attr , Set < Protocol > protocols ) { String value = el . absUrl ( attr . getKey ( ) ) ; if ( value . length ( ) == 0 ) value = attr . getValue ( ) ; if ( ! preserveRelativeLinks ) attr . setValue ( value ) ; for ( Protocol protocol : protocols ) { String prot = protocol . toString ( ) ; if ( prot . equals ( "#" ) ) { if ( isValidAnchor ( value ) ) { return true ; } else { continue ; } } prot += ":" ; if ( lowerCase ( value ) . startsWith ( prot ) ) { return true ; } } return false ; }
--------------------------------------------------
public Elements getElementsByAttributeValueMatching ( String key , Pattern pattern ) { return Collector . collect ( new Evaluator . AttributeWithValueMatching ( key , pattern ) , this ) ; }
--------------------------------------------------
public boolean hasSameValue ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; return this . outerHtml ( ) . equals ( ( ( Node ) o ) . outerHtml ( ) ) ; }
--------------------------------------------------
void putIgnoreCase ( String key , String value ) { int i = indexOfKeyIgnoreCase ( key ) ; if ( i != NotFound ) { vals [ i ] = value ; if ( ! keys [ i ] . equals ( key ) ) keys [ i ] = key ; } else add ( key , value ) ; }
--------------------------------------------------
public String setValue ( String val ) { String oldVal = this . val ; if ( parent != null ) { oldVal = parent . get ( this . key ) ; int i = parent . indexOfKey ( this . key ) ; if ( i != Attributes . NotFound ) parent . vals [ i ] = val ; } this . val = val ; return Attributes . checkNotNull ( oldVal ) ; }
--------------------------------------------------
public static void main ( String [ ] args ) throws IOException { Validate . isTrue ( args . length == 1 , "usage: supply url to fetch" ) ; String url = args [ 0 ] ; print ( "fetching %s..." , url ) ; Document doc = Jsoup . connect ( url ) . get ( ) ; Elements links = doc . select ( "a[href]" ) ; Elements media = doc . select ( "[src]" ) ; Elements imports = doc . select ( "link[href]" ) ; print ( "
media: (%d)" , media . size ( ) ) ; for ( Element src : media ) { if ( src . tagName ( ) . equals ( "img" ) ) print ( " * %s: <%s> %sx%s (%s)" , src . tagName ( ) , src . attr ( "abs:src" ) , src . attr ( "width" ) , src . attr ( "height" ) , trim ( src . attr ( "alt" ) , 20 ) ) ; else print ( " * %s: <%s>" , src . tagName ( ) , src . attr ( "abs:src" ) ) ; } print ( "
imports: (%d)" , imports . size ( ) ) ; for ( Element link : imports ) { print ( " * %s <%s> (%s)" , link . tagName ( ) , link . attr ( "abs:href" ) , link . attr ( "rel" ) ) ; } print ( "
links: (%d)" , links . size ( ) ) ; for ( Element link : links ) { print ( " * a: <%s>  (%s)" , link . attr ( "abs:href" ) , trim ( link . text ( ) , 35 ) ) ; } }
--------------------------------------------------
void outerHtmlHead ( Appendable accum , int depth , Document . OutputSettings out ) throws IOException { accum . append ( "<" ) . append ( isProcessingInstruction ? "!" : "?" ) . append ( coreValue ( ) ) ; getWholeDeclaration ( accum , out ) ; accum . append ( isProcessingInstruction ? "!" : "?" ) . append ( ">" ) ; }
--------------------------------------------------
public boolean matches ( Element root , Element element ) { final Element p = element . parent ( ) ; return p != null && ! ( p instanceof Document ) && element . siblingElements ( ) . size ( ) == 0 ; }
--------------------------------------------------
public boolean matches ( Element root , Element element ) { return element . hasAttr ( key ) && lowerCase ( element . attr ( key ) ) . contains ( value ) ; }
--------------------------------------------------
static Parser parser ( Node node ) { Document doc = node . ownerDocument ( ) ; return doc != null && doc . parser ( ) != null ? doc . parser ( ) : new Parser ( new HtmlTreeBuilder ( ) ) ; }
--------------------------------------------------
