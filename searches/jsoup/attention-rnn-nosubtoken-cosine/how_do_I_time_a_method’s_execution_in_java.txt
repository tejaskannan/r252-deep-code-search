void advanceTransition ( TokeniserState state ) { reader . advance ( ) ; this . state = state ; }
--------------------------------------------------
public OutputSettings prettyPrint ( boolean pretty ) { prettyPrint = pretty ; return this ; }
--------------------------------------------------
public Node unwrap ( ) { Validate . notNull ( parentNode ) ; final List < Node > childNodes = ensureChildNodes ( ) ; Node firstChild = childNodes . size ( ) > 0 ? childNodes . get ( 0 ) : null ; parentNode . addChildren ( siblingIndex , this . childNodesAsArray ( ) ) ; this . remove ( ) ; return firstChild ; }
--------------------------------------------------
public static Elements select ( String query , Element root ) { Validate . notEmpty ( query ) ; return select ( QueryParser . parse ( query ) , root ) ; }
--------------------------------------------------
protected int calculatePosition ( Element root , Element element ) { return element . parent ( ) . children ( ) . size ( ) - element . elementSiblingIndex ( ) ; }
--------------------------------------------------
void resetInsertionMode ( ) { boolean last = false ; for ( int pos = stack . size ( ) - 1 ; pos >= 0 ; pos -- ) { Element node = stack . get ( pos ) ; if ( pos == 0 ) { last = true ; node = contextElement ; } String name = node . normalName ( ) ; if ( "select" . equals ( name ) ) { transition ( HtmlTreeBuilderState . InSelect ) ; break ; } else if ( ( "td" . equals ( name ) || "th" . equals ( name ) && ! last ) ) { transition ( HtmlTreeBuilderState . InCell ) ; break ; } else if ( "tr" . equals ( name ) ) { transition ( HtmlTreeBuilderState . InRow ) ; break ; } else if ( "tbody" . equals ( name ) || "thead" . equals ( name ) || "tfoot" . equals ( name ) ) { transition ( HtmlTreeBuilderState . InTableBody ) ; break ; } else if ( "caption" . equals ( name ) ) { transition ( HtmlTreeBuilderState . InCaption ) ; break ; } else if ( "colgroup" . equals ( name ) ) { transition ( HtmlTreeBuilderState . InColumnGroup ) ; break ; } else if ( "table" . equals ( name ) ) { transition ( HtmlTreeBuilderState . InTable ) ; break ; } else if ( "head" . equals ( name ) ) { transition ( HtmlTreeBuilderState . InBody ) ; break ; } else if ( "body" . equals ( name ) ) { transition ( HtmlTreeBuilderState . InBody ) ; break ; } else if ( "frameset" . equals ( name ) ) { transition ( HtmlTreeBuilderState . InFrameset ) ; break ; } else if ( "html" . equals ( name ) ) { transition ( HtmlTreeBuilderState . BeforeHead ) ; break ; } else if ( last ) { transition ( HtmlTreeBuilderState . InBody ) ; break ; } } }
--------------------------------------------------
public Connection submit ( ) { String action = hasAttr ( "action" ) ? absUrl ( "action" ) : baseUri ( ) ; Validate . notEmpty ( action , "could not determine a form action url for submit. ensure you set a base uri when parsing." ) ; Connection . Method method = attr ( "method" ) . toUpperCase ( ) . equals ( "post" ) ? Connection . Method . POST : Connection . Method . GET ; return Jsoup . connect ( action ) . data ( formData ( ) ) . method ( method ) ; }
--------------------------------------------------
public static Elements select ( String query , Iterable < Element > roots ) { Validate . notEmpty ( query ) ; Validate . notNull ( roots ) ; Evaluator evaluator = QueryParser . parse ( query ) ; ArrayList < Element > elements = new ArrayList < > ( ) ; IdentityHashMap < Element , Boolean > seenElements = new IdentityHashMap < > ( ) ; for ( Element root : roots ) { final Elements found = select ( evaluator , root ) ; for ( Element el : found ) { if ( ! seenElements . containsKey ( el ) ) { elements . add ( el ) ; seenElements . put ( el , Boolean . TRUE ) ; } } } return new Elements ( elements ) ; }
--------------------------------------------------
private List < Element > childElementsList ( ) { List < Element > children ; if ( shadowChildrenRef == null || ( children = shadowChildrenRef . get ( ) ) == null ) { final int size = childNodes . size ( ) ; children = new ArrayList < > ( size ) ; for ( int i = 0 ; i < size ; i ++ ) { final Node node = childNodes . get ( i ) ; if ( node instanceof Element ) children . add ( ( Element ) node ) ; } shadowChildrenRef = new WeakReference < > ( children ) ; } return children ; }
--------------------------------------------------
private boolean expired ( ) { if ( timeout == 0 ) return false ; final long now = System . nanoTime ( ) ; final long dur = now - startTime ; return ( dur > timeout ) ; }
--------------------------------------------------
