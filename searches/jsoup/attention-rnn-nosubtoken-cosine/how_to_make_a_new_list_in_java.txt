public Elements clone ( ) { Elements clone = new Elements ( size ( ) ) ; for ( Element e : this ) clone . add ( e . clone ( ) ) ; return clone ; }
--------------------------------------------------
public void reset ( ) throws IOException { super . reset ( ) ; remaining = maxSize - markpos ; }
--------------------------------------------------
String consumeData ( ) { int pos = bufPos ; final int start = pos ; final int remaining = bufLength ; final char [ ] val = charBuf ; OUTER : while ( pos < remaining ) { switch ( val [ pos ] ) { case '&' : case '<' : case TokeniserState . nullChar : break OUTER ; default : pos ++ ; } } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : "" ; }
--------------------------------------------------
public boolean retainAll ( Collection < ? > c ) { onContentsChanged ( ) ; return super . retainAll ( c ) ; }
--------------------------------------------------
public List < String > eachAttr ( String attributeKey ) { List < String > attrs = new ArrayList < > ( size ( ) ) ; for ( Element element : this ) { if ( element . hasAttr ( attributeKey ) ) attrs . add ( element . attr ( attributeKey ) ) ; } return attrs ; }
--------------------------------------------------
public String data ( ) { StringBuilder sb = StringUtil . borrowBuilder ( ) ; for ( Node childNode : childNodes ) { if ( childNode instanceof DataNode ) { DataNode data = ( DataNode ) childNode ; sb . append ( data . getWholeData ( ) ) ; } else if ( childNode instanceof Comment ) { Comment comment = ( Comment ) childNode ; sb . append ( comment . getData ( ) ) ; } else if ( childNode instanceof Element ) { Element element = ( Element ) childNode ; String elementData = element . data ( ) ; sb . append ( elementData ) ; } else if ( childNode instanceof CDataNode ) { CDataNode cDataNode = ( CDataNode ) childNode ; sb . append ( cDataNode . getWholeText ( ) ) ; } } return StringUtil . releaseBuilder ( sb ) ; }
--------------------------------------------------
void emit ( final String str ) { if ( charsString == null ) { charsString = str ; } else { if ( charsBuilder . length ( ) == 0 ) { charsBuilder . append ( charsString ) ; } charsBuilder . append ( str ) ; } }
--------------------------------------------------
public Element firstElementSibling ( ) { List < Element > siblings = parent ( ) . childElementsList ( ) ; return siblings . size ( ) > 1 ? siblings . get ( 0 ) : null ; }
--------------------------------------------------
protected int calculatePosition ( Element root , Element element ) { int pos = 0 ; Elements family = element . parent ( ) . children ( ) ; for ( int i = element . elementSiblingIndex ( ) ; i < family . size ( ) ; i ++ ) { if ( family . get ( i ) . tag ( ) . equals ( element . tag ( ) ) ) pos ++ ; } return pos ; }
--------------------------------------------------
public Node unwrap ( ) { Validate . notNull ( parentNode ) ; final List < Node > childNodes = ensureChildNodes ( ) ; Node firstChild = childNodes . size ( ) > 0 ? childNodes . get ( 0 ) : null ; parentNode . addChildren ( siblingIndex , this . childNodesAsArray ( ) ) ; this . remove ( ) ; return firstChild ; }
--------------------------------------------------
