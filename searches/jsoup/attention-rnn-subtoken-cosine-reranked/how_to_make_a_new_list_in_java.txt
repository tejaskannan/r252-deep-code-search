FormElement insertForm ( Token . StartTag startTag , boolean onStack ) { Tag tag = Tag . valueOf ( startTag . name ( ) , settings ) ; FormElement el = new FormElement ( tag , baseUri , startTag . attributes ) ; setFormElement ( el ) ; insertNode ( el ) ; if ( onStack ) stack . add ( el ) ; return el ; }
--------------------------------------------------
public Document fromJsoup ( org . jsoup . nodes . Document in ) { Validate . notNull ( in ) ; DocumentBuilder builder ; try { factory . setNamespaceAware ( true ) ; builder = factory . newDocumentBuilder ( ) ; Document out = builder . newDocument ( ) ; convert ( in , out ) ; return out ; } catch ( ParserConfigurationException e ) { throw new IllegalStateException ( e ) ; } }
--------------------------------------------------
public List < TextNode > textNodes ( ) { List < TextNode > textNodes = new ArrayList < > ( ) ; for ( Node node : childNodes ) { if ( node instanceof TextNode ) textNodes . add ( ( TextNode ) node ) ; } return Collections . unmodifiableList ( textNodes ) ; }
--------------------------------------------------
Element insertStartTag ( String startTagName ) { Element el = new Element ( Tag . valueOf ( startTagName , settings ) , baseUri ) ; insert ( el ) ; return el ; }
--------------------------------------------------
protected void initialiseParse ( Reader input , String baseUri , Parser parser ) { super . initialiseParse ( input , baseUri , parser ) ; state = HtmlTreeBuilderState . Initial ; originalState = null ; baseUriSetFromDoc = false ; headElement = null ; formElement = null ; contextElement = null ; formattingElements = new ArrayList < > ( ) ; pendingTableCharacters = new ArrayList < > ( ) ; emptyEnd = new Token . EndTag ( ) ; framesetOk = true ; fosterInserts = false ; fragmentParsing = false ; }
--------------------------------------------------
void reconstructFormattingElements ( ) { Element last = lastFormattingElement ( ) ; if ( last == null || onStack ( last ) ) return ; Element entry = last ; int size = formattingElements . size ( ) ; int pos = size - 1 ; boolean skip = false ; while ( true ) { if ( pos == 0 ) { skip = true ; break ; } entry = formattingElements . get ( -- pos ) ; if ( entry == null || onStack ( entry ) ) break ; } while ( true ) { if ( ! skip ) entry = formattingElements . get ( ++ pos ) ; Validate . notNull ( entry ) ; skip = false ; Element newEl = insertStartTag ( entry . normalName ( ) ) ; newEl . attributes ( ) . addAll ( entry . attributes ( ) ) ; formattingElements . set ( pos , newEl ) ; if ( pos == size - 1 ) break ; } }
--------------------------------------------------
public List < String > eachText ( ) { ArrayList < String > texts = new ArrayList < > ( size ( ) ) ; for ( Element el : this ) { if ( el . hasText ( ) ) texts . add ( el . text ( ) ) ; } return texts ; }
--------------------------------------------------
public XmlDeclaration ( String name , boolean isProcessingInstruction ) { Validate . notNull ( name ) ; value = name ; this . isProcessingInstruction = isProcessingInstruction ; }
--------------------------------------------------
public Element prependElement ( String tagName ) { Element child = new Element ( Tag . valueOf ( tagName , NodeUtils . parser ( this ) . settings ( ) ) , baseUri ( ) ) ; prependChild ( child ) ; return child ; }
--------------------------------------------------
public static Attribute createFromEncoded ( String unencodedKey , String encodedValue ) { String value = Entities . unescape ( encodedValue , true ) ; return new Attribute ( unencodedKey , value , null ) ; }
--------------------------------------------------
