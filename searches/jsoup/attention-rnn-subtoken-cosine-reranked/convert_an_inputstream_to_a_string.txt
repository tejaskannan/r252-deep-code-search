public Document fromJsoup ( org . jsoup . nodes . Document in ) { Validate . notNull ( in ) ; DocumentBuilder builder ; try { factory . setNamespaceAware ( true ) ; builder = factory . newDocumentBuilder ( ) ; Document out = builder . newDocument ( ) ; convert ( in , out ) ; return out ; } catch ( ParserConfigurationException e ) { throw new IllegalStateException ( e ) ; } }
--------------------------------------------------
> parseFragment ( String inputFragment , String baseUri , Parser parser ) { initialiseParse ( new StringReader ( inputFragment ) , baseUri , parser ) ; runParser ( ) ; return doc . childNodes ( ) ; }
--------------------------------------------------
public String cssSelector ( ) { if ( id ( ) . length ( ) > 0 ) return "#" + id ( ) ; String tagName = tagName ( ) . replace ( ':' , '|' ) ; StringBuilder selector = new StringBuilder ( tagName ) ; String classes = StringUtil . join ( classNames ( ) , "." ) ; if ( classes . length ( ) > 0 ) selector . append ( '.' ) . append ( classes ) ; if ( parent ( ) == null || parent ( ) instanceof Document ) return selector . toString ( ) ; selector . insert ( 0 , " > " ) ; if ( parent ( ) . select ( selector . toString ( ) ) . size ( ) > 1 ) selector . append ( String . format ( ":nth-child(%d)" , elementSiblingIndex ( ) + 1 ) ) ; return parent ( ) . cssSelector ( ) + selector . toString ( ) ; }
--------------------------------------------------
public String text ( ) { StringBuilder sb = StringUtil . borrowBuilder ( ) ; for ( Element element : this ) { if ( sb . length ( ) != 0 ) sb . append ( " " ) ; sb . append ( element . text ( ) ) ; } return StringUtil . releaseBuilder ( sb ) ; }
--------------------------------------------------
Element insertStartTag ( String startTagName ) { Element el = new Element ( Tag . valueOf ( startTagName , settings ) , baseUri ) ; insert ( el ) ; return el ; }
--------------------------------------------------
public String toString ( ) { return super . toString ( ) + ". mimetype=" + mimeType + ", url=" + url ; }
--------------------------------------------------
> parseFragment ( String inputFragment , Element context , String baseUri , Parser parser ) { state = HtmlTreeBuilderState . Initial ; initialiseParse ( new StringReader ( inputFragment ) , baseUri , parser ) ; contextElement = context ; fragmentParsing = true ; Element root = null ; if ( context != null ) { if ( context . ownerDocument ( ) != null ) doc . quirksMode ( context . ownerDocument ( ) . quirksMode ( ) ) ; String contextTag = context . tagName ( ) ; if ( StringUtil . in ( contextTag , "title" , "textarea" ) ) tokeniser . transition ( TokeniserState . Rcdata ) ; else if ( StringUtil . in ( contextTag , "iframe" , "noembed" , "noframes" , "style" , "xmp" ) ) tokeniser . transition ( TokeniserState . Rawtext ) ; else if ( contextTag . equals ( "script" ) ) tokeniser . transition ( TokeniserState . ScriptData ) ; else if ( contextTag . equals ( ( "noscript" ) ) ) tokeniser . transition ( TokeniserState . Data ) ; else if ( contextTag . equals ( "plaintext" ) ) tokeniser . transition ( TokeniserState . Data ) ; else tokeniser . transition ( TokeniserState . Data ) ; root = new Element ( Tag . valueOf ( "html" , settings ) , baseUri ) ; doc . appendChild ( root ) ; stack . add ( root ) ; resetInsertionMode ( ) ; Elements contextChain = context . parents ( ) ; contextChain . add ( 0 , context ) ; for ( Element parent : contextChain ) { if ( parent instanceof FormElement ) { formElement = ( FormElement ) parent ; break ; } } } runParser ( ) ; if ( context != null ) return root . childNodes ( ) ; else return doc . childNodes ( ) ; }
--------------------------------------------------
void read ( Tokeniser t , CharacterReader r ) { if ( r . matchConsume ( "--" ) ) { t . createCommentPending ( ) ; t . transition ( CommentStart ) ; } else if ( r . matchConsumeIgnoreCase ( "doctype" ) ) { t . transition ( Doctype ) ; } else if ( r . matchConsume ( "[cdata[" ) ) { t . createTempBuffer ( ) ; t . transition ( CdataSection ) ; } else { t . error ( this ) ; t . advanceTransition ( BogusComment ) ; } }
--------------------------------------------------
void read ( Tokeniser t , CharacterReader r ) { String value = r . consumeToAny ( attributeDoubleValueCharsSorted ) ; if ( value . length ( ) > 0 ) t . tagPending . appendAttributeValue ( value ) ; else t . tagPending . setEmptyAttributeValue ( ) ; char c = r . consume ( ) ; switch ( c ) { case '"' : t . transition ( AfterAttributeValue_quoted ) ; break ; case '&' : int [ ] ref = t . consumeCharacterReference ( '"' , true ) ; if ( ref != null ) t . tagPending . appendAttributeValue ( ref ) ; else t . tagPending . appendAttributeValue ( '&' ) ; break ; case nullChar : t . error ( this ) ; t . tagPending . appendAttributeValue ( replacementChar ) ; break ; case eof : t . eofError ( this ) ; t . transition ( Data ) ; break ; default : t . tagPending . appendAttributeValue ( c ) ; } }
--------------------------------------------------
void read ( Tokeniser t , CharacterReader r ) { String value = r . consumeToAny ( attributeSingleValueCharsSorted ) ; if ( value . length ( ) > 0 ) t . tagPending . appendAttributeValue ( value ) ; else t . tagPending . setEmptyAttributeValue ( ) ; char c = r . consume ( ) ; switch ( c ) { case ''' : t . transition ( AfterAttributeValue_quoted ) ; break ; case '&' : int [ ] ref = t . consumeCharacterReference ( ''' , true ) ; if ( ref != null ) t . tagPending . appendAttributeValue ( ref ) ; else t . tagPending . appendAttributeValue ( '&' ) ; break ; case nullChar : t . error ( this ) ; t . tagPending . appendAttributeValue ( replacementChar ) ; break ; case eof : t . eofError ( this ) ; t . transition ( Data ) ; break ; default : t . tagPending . appendAttributeValue ( c ) ; } }
--------------------------------------------------
