public Connection cookies ( Map < String , String > cookies ) { Validate . notNull ( cookies , "cookie map must not be null" ) ; for ( Map . Entry < String , String > entry : cookies . entrySet ( ) ) { req . cookie ( entry . getKey ( ) , entry . getValue ( ) ) ; } return this ; }
--------------------------------------------------
public Whitelist removeProtocols ( String tag , String attribute , String ... removeProtocols ) { Validate . notEmpty ( tag ) ; Validate . notEmpty ( attribute ) ; Validate . notNull ( removeProtocols ) ; TagName tagName = TagName . valueOf ( tag ) ; AttributeKey attr = AttributeKey . valueOf ( attribute ) ; Validate . isTrue ( protocols . containsKey ( tagName ) , "cannot remove a protocol that is not set." ) ; Map < AttributeKey , Set < Protocol >> tagProtocols = protocols . get ( tagName ) ; Validate . isTrue ( tagProtocols . containsKey ( attr ) , "cannot remove a protocol that is not set." ) ; Set < Protocol > attrProtocols = tagProtocols . get ( attr ) ; for ( String protocol : removeProtocols ) { Validate . notEmpty ( protocol ) ; attrProtocols . remove ( Protocol . valueOf ( protocol ) ) ; } if ( attrProtocols . isEmpty ( ) ) { tagProtocols . remove ( attr ) ; if ( tagProtocols . isEmpty ( ) ) protocols . remove ( tagName ) ; } return this ; }
--------------------------------------------------
public List < Attribute > asList ( ) { ArrayList < Attribute > list = new ArrayList < > ( size ) ; for ( int i = 0 ; i < size ; i ++ ) { Attribute attr = vals [ i ] == null ? new BooleanAttribute ( keys [ i ] ) : new Attribute ( keys [ i ] , vals [ i ] , Attributes . this ) ; list . add ( attr ) ; } return Collections . unmodifiableList ( list ) ; }
--------------------------------------------------
Element getFromStack ( String elName ) { for ( int pos = stack . size ( ) - 1 ; pos >= 0 ; pos -- ) { Element next = stack . get ( pos ) ; if ( next . normalName ( ) . equals ( elName ) ) { return next ; } } return null ; }
--------------------------------------------------
Attributes getEnforcedAttributes ( String tagName ) { Attributes attrs = new Attributes ( ) ; TagName tag = TagName . valueOf ( tagName ) ; if ( enforcedAttributes . containsKey ( tag ) ) { Map < AttributeKey , AttributeValue > keyVals = enforcedAttributes . get ( tag ) ; for ( Map . Entry < AttributeKey , AttributeValue > entry : keyVals . entrySet ( ) ) { attrs . put ( entry . getKey ( ) . toString ( ) , entry . getValue ( ) . toString ( ) ) ; } } return attrs ; }
--------------------------------------------------
private void clearStackToContext ( String ... nodeNames ) { for ( int pos = stack . size ( ) - 1 ; pos >= 0 ; pos -- ) { Element next = stack . get ( pos ) ; if ( StringUtil . in ( next . normalName ( ) , nodeNames ) || next . normalName ( ) . equals ( "html" ) ) break ; else stack . remove ( pos ) ; } }
--------------------------------------------------
FormElement insertForm ( Token . StartTag startTag , boolean onStack ) { Tag tag = Tag . valueOf ( startTag . name ( ) , settings ) ; FormElement el = new FormElement ( tag , baseUri , startTag . attributes ) ; setFormElement ( el ) ; insertNode ( el ) ; if ( onStack ) stack . add ( el ) ; return el ; }
--------------------------------------------------
void reconstructFormattingElements ( ) { Element last = lastFormattingElement ( ) ; if ( last == null || onStack ( last ) ) return ; Element entry = last ; int size = formattingElements . size ( ) ; int pos = size - 1 ; boolean skip = false ; while ( true ) { if ( pos == 0 ) { skip = true ; break ; } entry = formattingElements . get ( -- pos ) ; if ( entry == null || onStack ( entry ) ) break ; } while ( true ) { if ( ! skip ) entry = formattingElements . get ( ++ pos ) ; Validate . notNull ( entry ) ; skip = false ; Element newEl = insertStartTag ( entry . normalName ( ) ) ; newEl . attributes ( ) . addAll ( entry . attributes ( ) ) ; formattingElements . set ( pos , newEl ) ; if ( pos == size - 1 ) break ; } }
--------------------------------------------------
@ Override Tag reset ( ) { tagName = null ; normalName = null ; pendingAttributeName = null ; reset ( pendingAttributeValue ) ; pendingAttributeValueS = null ; hasEmptyAttributeValue = false ; hasPendingAttributeValue = false ; selfClosing = false ; attributes = null ; return this ; }
--------------------------------------------------
private List < String > getHeadersCaseInsensitive ( String name ) { Validate . notNull ( name ) ; for ( Map . Entry < String , List < String >> entry : headers . entrySet ( ) ) { if ( name . equalsIgnoreCase ( entry . getKey ( ) ) ) return entry . getValue ( ) ; } return Collections . emptyList ( ) ; }
--------------------------------------------------
