private static void appendNormalisedText ( StringBuilder accum , TextNode textNode ) { String text = textNode . getWholeText ( ) ; if ( preserveWhitespace ( textNode . parentNode ) || textNode instanceof CDataNode ) accum . append ( text ) ; else StringUtil . appendNormalisedWhitespace ( accum , text , TextNode . lastCharIsWhitespace ( accum ) ) ; }
--------------------------------------------------
private void append ( String text ) { if ( text . startsWith ( "\n" ) ) width = 0 ; if ( text . equals ( " " ) && ( accum . length ( ) == 0 || StringUtil . in ( accum . substring ( accum . length ( ) - 1 ) , " " , "\n" ) ) ) return ; if ( text . length ( ) + width > maxWidth ) { String words [ ] = text . split ( "\s+" ) ; for ( int i = 0 ; i < words . length ; i ++ ) { String word = words [ i ] ; boolean last = i == words . length - 1 ; if ( ! last ) word = word + " " ; if ( word . length ( ) + width > maxWidth ) { accum . append ( "\n" ) . append ( word ) ; width = word . length ( ) ; } else { accum . append ( word ) ; width += word . length ( ) ; } } } else { accum . append ( text ) ; width += text . length ( ) ; } }
--------------------------------------------------
public static URL resolve ( URL base , String relUrl ) throws MalformedURLException { if ( relUrl . startsWith ( "?" ) ) relUrl = base . getPath ( ) + relUrl ; if ( relUrl . indexOf ( '.' ) == 0 && base . getFile ( ) . indexOf ( '/' ) != 0 ) { base = new URL ( base . getProtocol ( ) , base . getHost ( ) , base . getPort ( ) , "/" + base . getFile ( ) ) ; } return new URL ( base , relUrl ) ; }
--------------------------------------------------
private static void appendWhitespaceIfBr ( Element element , StringBuilder accum ) { if ( element . tag . getName ( ) . equals ( "br" ) && ! TextNode . lastCharIsWhitespace ( accum ) ) accum . append ( " " ) ; }
--------------------------------------------------
public Element appendElement ( String tagName ) { Element child = new Element ( Tag . valueOf ( tagName , NodeUtils . parser ( this ) . settings ( ) ) , baseUri ( ) ) ; appendChild ( child ) ; return child ; }
--------------------------------------------------
public Element appendChild ( Node child ) { Validate . notNull ( child ) ; reparentChild ( child ) ; ensureChildNodes ( ) ; childNodes . add ( child ) ; child . setSiblingIndex ( childNodes . size ( ) - 1 ) ; return this ; }
--------------------------------------------------
final void appendAttributeValue ( String append ) { ensureAttributeValue ( ) ; if ( pendingAttributeValue . length ( ) == 0 ) { pendingAttributeValueS = append ; } else { pendingAttributeValue . append ( append ) ; } }
--------------------------------------------------
void rewindToMark ( ) { if ( bufMark == - 1 ) throw new UncheckedIOException ( new IOException ( "mark invalid" ) ) ; bufPos = bufMark ; }
--------------------------------------------------
private void clearStackToContext ( String ... nodeNames ) { for ( int pos = stack . size ( ) - 1 ; pos >= 0 ; pos -- ) { Element next = stack . get ( pos ) ; if ( StringUtil . in ( next . normalName ( ) , nodeNames ) || next . normalName ( ) . equals ( "html" ) ) break ; else stack . remove ( pos ) ; } }
--------------------------------------------------
String consumeToEnd ( ) { bufferUp ( ) ; String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; return data ; }
--------------------------------------------------
