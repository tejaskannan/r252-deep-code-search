public void tail ( Node node , int depth ) { if ( ! node . nodeName ( ) . equals ( "#text" ) ) { try { node . outerHtmlTail ( accum , depth , out ) ; } catch ( IOException exception ) { throw new SerializationException ( exception ) ; } } }
--------------------------------------------------
public Element prependElement ( String tagName ) { Element child = new Element ( Tag . valueOf ( tagName , NodeUtils . parser ( this ) . settings ( ) ) , baseUri ( ) ) ; prependChild ( child ) ; return child ; }
--------------------------------------------------
final String name ( ) { Validate . isFalse ( tagName == null || tagName . length ( ) == 0 ) ; return tagName ; }
--------------------------------------------------
void outerHtmlTail ( Appendable accum , int depth , Document . OutputSettings out ) throws IOException { if ( ! ( childNodes . isEmpty ( ) && tag . isSelfClosing ( ) ) ) { if ( out . prettyPrint ( ) && ( ! childNodes . isEmpty ( ) && ( tag . formatAsBlock ( ) || ( out . outline ( ) && ( childNodes . size ( ) > 1 || ( childNodes . size ( ) == 1 && ! ( childNodes . get ( 0 ) instanceof TextNode ) ) ) ) ) ) ) indent ( accum , depth , out ) ; accum . append ( "</" ) . append ( tagName ( ) ) . append ( '>' ) ; } }
--------------------------------------------------
void outerHtmlHead ( Appendable accum , int depth , Document . OutputSettings out ) throws IOException { accum . append ( "<" ) . append ( isProcessingInstruction ? "!" : "?" ) . append ( coreValue ( ) ) ; getWholeDeclaration ( accum , out ) ; accum . append ( isProcessingInstruction ? "!" : "?" ) . append ( ">" ) ; }
--------------------------------------------------
private void clearStackToContext ( String ... nodeNames ) { for ( int pos = stack . size ( ) - 1 ; pos >= 0 ; pos -- ) { Element next = stack . get ( pos ) ; if ( StringUtil . in ( next . normalName ( ) , nodeNames ) || next . normalName ( ) . equals ( "html" ) ) break ; else stack . remove ( pos ) ; } }
--------------------------------------------------
public boolean hasHeader ( String name ) { Validate . notEmpty ( name , "header name must not be empty" ) ; return getHeadersCaseInsensitive ( name ) . size ( ) != 0 ; }
--------------------------------------------------
void generateImpliedEndTags ( String excludeTag ) { while ( ( excludeTag != null && ! currentElement ( ) . normalName ( ) . equals ( excludeTag ) ) && inSorted ( currentElement ( ) . normalName ( ) , TagSearchEndTags ) ) pop ( ) ; }
--------------------------------------------------
StartTag nameAttr ( String name , Attributes attributes ) { this . tagName = name ; this . attributes = attributes ; normalName = lowerCase ( tagName ) ; return this ; }
--------------------------------------------------
public String nodeName ( ) { return tag . getName ( ) ; }
--------------------------------------------------
