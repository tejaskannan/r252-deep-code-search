private List < Element > childElementsList ( ) { List < Element > children ; if ( shadowChildrenRef == null || ( children = shadowChildrenRef . get ( ) ) == null ) { final int size = childNodes . size ( ) ; children = new ArrayList < > ( size ) ; for ( int i = 0 ; i < size ; i ++ ) { final Node node = childNodes . get ( i ) ; if ( node instanceof Element ) children . add ( ( Element ) node ) ; } shadowChildrenRef = new WeakReference < > ( children ) ; } return children ; }
--------------------------------------------------
void clearFormattingElementsToLastMarker ( ) { while ( ! formattingElements . isEmpty ( ) ) { Element el = removeLastFormattingElement ( ) ; if ( el == null ) break ; } }
--------------------------------------------------
public static Elements select ( String query , Iterable < Element > roots ) { Validate . notEmpty ( query ) ; Validate . notNull ( roots ) ; Evaluator evaluator = QueryParser . parse ( query ) ; ArrayList < Element > elements = new ArrayList < > ( ) ; IdentityHashMap < Element , Boolean > seenElements = new IdentityHashMap < > ( ) ; for ( Element root : roots ) { final Elements found = select ( evaluator , root ) ; for ( Element el : found ) { if ( ! seenElements . containsKey ( el ) ) { elements . add ( el ) ; seenElements . put ( el , Boolean . TRUE ) ; } } } return new Elements ( elements ) ; }
--------------------------------------------------
private void clearStackToContext ( String ... nodeNames ) { for ( int pos = stack . size ( ) - 1 ; pos >= 0 ; pos -- ) { Element next = stack . get ( pos ) ; if ( StringUtil . in ( next . normalName ( ) , nodeNames ) || next . normalName ( ) . equals ( "html" ) ) break ; else stack . remove ( pos ) ; } }
--------------------------------------------------
public Elements getElementsByAttributeValueMatching ( String key , Pattern pattern ) { return Collector . collect ( new Evaluator . AttributeWithValueMatching ( key , pattern ) , this ) ; }
--------------------------------------------------
public void reset ( ) throws IOException { super . reset ( ) ; remaining = maxSize - markpos ; }
--------------------------------------------------
private String updateNamespaces ( org . jsoup . nodes . Element el ) { Attributes attributes = el . attributes ( ) ; for ( Attribute attr : attributes ) { String key = attr . getKey ( ) ; String prefix ; if ( key . equals ( xmlnsKey ) ) { prefix = "" ; } else if ( key . startsWith ( xmlnsPrefix ) ) { prefix = key . substring ( xmlnsPrefix . length ( ) ) ; } else { continue ; } namespacesStack . peek ( ) . put ( prefix , attr . getValue ( ) ) ; } int pos = el . tagName ( ) . indexOf ( ":" ) ; return pos > 0 ? el . tagName ( ) . substring ( 0 , pos ) : "" ; }
--------------------------------------------------
private static String [ ] copyOf ( String [ ] orig , int size ) { final String [ ] copy = new String [ size ] ; System . arraycopy ( orig , 0 , copy , 0 , Math . min ( orig . length , size ) ) ; return copy ; }
--------------------------------------------------
public boolean hasNext ( ) { return i < size ; }
--------------------------------------------------
public Elements clone ( ) { Elements clone = new Elements ( size ( ) ) ; for ( Element e : this ) clone . add ( e . clone ( ) ) ; return clone ; }
--------------------------------------------------
