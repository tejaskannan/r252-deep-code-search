void advanceTransition ( TokeniserState state ) { reader . advance ( ) ; this . state = state ; }
--------------------------------------------------
void resetInsertionMode ( ) { boolean last = false ; for ( int pos = stack . size ( ) - 1 ; pos >= 0 ; pos -- ) { Element node = stack . get ( pos ) ; if ( pos == 0 ) { last = true ; node = contextElement ; } String name = node . normalName ( ) ; if ( "select" . equals ( name ) ) { transition ( HtmlTreeBuilderState . InSelect ) ; break ; } else if ( ( "td" . equals ( name ) || "th" . equals ( name ) && ! last ) ) { transition ( HtmlTreeBuilderState . InCell ) ; break ; } else if ( "tr" . equals ( name ) ) { transition ( HtmlTreeBuilderState . InRow ) ; break ; } else if ( "tbody" . equals ( name ) || "thead" . equals ( name ) || "tfoot" . equals ( name ) ) { transition ( HtmlTreeBuilderState . InTableBody ) ; break ; } else if ( "caption" . equals ( name ) ) { transition ( HtmlTreeBuilderState . InCaption ) ; break ; } else if ( "colgroup" . equals ( name ) ) { transition ( HtmlTreeBuilderState . InColumnGroup ) ; break ; } else if ( "table" . equals ( name ) ) { transition ( HtmlTreeBuilderState . InTable ) ; break ; } else if ( "head" . equals ( name ) ) { transition ( HtmlTreeBuilderState . InBody ) ; break ; } else if ( "body" . equals ( name ) ) { transition ( HtmlTreeBuilderState . InBody ) ; break ; } else if ( "frameset" . equals ( name ) ) { transition ( HtmlTreeBuilderState . InFrameset ) ; break ; } else if ( "html" . equals ( name ) ) { transition ( HtmlTreeBuilderState . BeforeHead ) ; break ; } else if ( last ) { transition ( HtmlTreeBuilderState . InBody ) ; break ; } } }
--------------------------------------------------
static void reset ( StringBuilder sb ) { if ( sb != null ) { sb . delete ( 0 , sb . length ( ) ) ; } }
--------------------------------------------------
public Document post ( ) throws IOException { req . method ( Method . POST ) ; execute ( ) ; return res . parse ( ) ; }
--------------------------------------------------
void clearFormattingElementsToLastMarker ( ) { while ( ! formattingElements . isEmpty ( ) ) { Element el = removeLastFormattingElement ( ) ; if ( el == null ) break ; } }
--------------------------------------------------
public void reset ( ) throws IOException { super . reset ( ) ; remaining = maxSize - markpos ; }
--------------------------------------------------
private void containsData ( ) { tq . consume ( ":containsdata" ) ; String searchText = TokenQueue . unescape ( tq . chompBalanced ( '(' , ')' ) ) ; Validate . notEmpty ( searchText , ":containsdata(text) query must not be empty" ) ; evals . add ( new Evaluator . ContainsData ( searchText ) ) ; }
--------------------------------------------------
public static Whitelist basic ( ) { return new Whitelist ( ) . addTags ( "a" , "b" , "blockquote" , "br" , "cite" , "code" , "dd" , "dl" , "dt" , "em" , "i" , "li" , "ol" , "p" , "pre" , "q" , "small" , "span" , "strike" , "strong" , "sub" , "sup" , "u" , "ul" ) . addAttributes ( "a" , "href" ) . addAttributes ( "blockquote" , "cite" ) . addAttributes ( "q" , "cite" ) . addProtocols ( "a" , "href" , "ftp" , "http" , "https" , "mailto" ) . addProtocols ( "blockquote" , "cite" , "http" , "https" ) . addProtocols ( "cite" , "cite" , "http" , "https" ) . addEnforcedAttribute ( "a" , "rel" , "nofollow" ) ; }
--------------------------------------------------
public Elements clone ( ) { Elements clone = new Elements ( size ( ) ) ; for ( Element e : this ) clone . add ( e . clone ( ) ) ; return clone ; }
--------------------------------------------------
void eofError ( TokeniserState state ) { if ( errors . canAddError ( ) ) errors . add ( new ParseError ( reader . pos ( ) , "unexpectedly reached end of file (eof) in input state [%s]" , state ) ) ; }
--------------------------------------------------
