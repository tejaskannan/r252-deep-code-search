public Elements clone ( ) { Elements clone = new Elements ( size ( ) ) ; for ( Element e : this ) clone . add ( e . clone ( ) ) ; return clone ; }
--------------------------------------------------
private static < E extends Element > int indexInList ( Element search , List < E > elements ) { final int size = elements . size ( ) ; for ( int i = 0 ; i < size ; i ++ ) { if ( elements . get ( i ) == search ) return i ; } return 0 ; }
--------------------------------------------------
public List < String > eachAttr ( String attributeKey ) { List < String > attrs = new ArrayList < > ( size ( ) ) ; for ( Element element : this ) { if ( element . hasAttr ( attributeKey ) ) attrs . add ( element . attr ( attributeKey ) ) ; } return attrs ; }
--------------------------------------------------
public Element firstElementSibling ( ) { List < Element > siblings = parent ( ) . childElementsList ( ) ; return siblings . size ( ) > 1 ? siblings . get ( 0 ) : null ; }
--------------------------------------------------
public void reset ( ) throws IOException { super . reset ( ) ; remaining = maxSize - markpos ; }
--------------------------------------------------
public Node unwrap ( ) { Validate . notNull ( parentNode ) ; final List < Node > childNodes = ensureChildNodes ( ) ; Node firstChild = childNodes . size ( ) > 0 ? childNodes . get ( 0 ) : null ; parentNode . addChildren ( siblingIndex , this . childNodesAsArray ( ) ) ; this . remove ( ) ; return firstChild ; }
--------------------------------------------------
public List < Node > childNodesCopy ( ) { final List < Node > nodes = ensureChildNodes ( ) ; final ArrayList < Node > children = new ArrayList < > ( nodes . size ( ) ) ; for ( Node node : nodes ) { children . add ( node . clone ( ) ) ; } return children ; }
--------------------------------------------------
String consumeData ( ) { int pos = bufPos ; final int start = pos ; final int remaining = bufLength ; final char [ ] val = charBuf ; OUTER : while ( pos < remaining ) { switch ( val [ pos ] ) { case '&' : case '<' : case TokeniserState . nullChar : break OUTER ; default : pos ++ ; } } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : "" ; }
--------------------------------------------------
public boolean retainAll ( Collection < ? > c ) { onContentsChanged ( ) ; return super . retainAll ( c ) ; }
--------------------------------------------------
private void reindexChildren ( int start ) { final List < Node > childNodes = ensureChildNodes ( ) ; for ( int i = start ; i < childNodes . size ( ) ; i ++ ) { childNodes . get ( i ) . setSiblingIndex ( i ) ; } }
--------------------------------------------------
