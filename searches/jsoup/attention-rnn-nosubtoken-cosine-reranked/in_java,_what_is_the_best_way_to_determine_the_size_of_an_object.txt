protected void runParser ( ) { while ( true ) { Token token = tokeniser . read ( ) ; process ( token ) ; token . reset ( ) ; if ( token . type == Token . TokenType . EOF ) break ; } }
--------------------------------------------------
public boolean hasNext ( ) { return i < size ; }
--------------------------------------------------
final void html ( final Appendable accum , final Document . OutputSettings out ) throws IOException { final int sz = size ; for ( int i = 0 ; i < sz ; i ++ ) { final String key = keys [ i ] ; final String val = vals [ i ] ; accum . append ( ' ' ) . append ( key ) ; if ( ! Attribute . shouldCollapseAttribute ( key , val , out ) ) { accum . append ( "="" ) ; Entities . escape ( accum , val == null ? EmptyString : val , out , true , false , false ) ; accum . append ( '"' ) ; } } }
--------------------------------------------------
static void crossStreams ( final InputStream in , final OutputStream out ) throws IOException { final byte [ ] buffer = new byte [ bufferSize ] ; int len ; while ( ( len = in . read ( buffer ) ) != - 1 ) { out . write ( buffer , 0 , len ) ; } }
--------------------------------------------------
public void normalize ( ) { for ( int i = 0 ; i < size ; i ++ ) { keys [ i ] = lowerCase ( keys [ i ] ) ; } }
--------------------------------------------------
Element pop ( ) { int size = stack . size ( ) ; return stack . remove ( size - 1 ) ; }
--------------------------------------------------
void popStackToBefore ( String elName ) { for ( int pos = stack . size ( ) - 1 ; pos >= 0 ; pos -- ) { Element next = stack . get ( pos ) ; if ( next . normalName ( ) . equals ( elName ) ) { break ; } else { stack . remove ( pos ) ; } } }
--------------------------------------------------
public Node attr ( String attributeKey , String attributeValue ) { attributeKey = NodeUtils . parser ( this ) . settings ( ) . normalizeAttribute ( attributeKey ) ; attributes ( ) . putIgnoreCase ( attributeKey , attributeValue ) ; return this ; }
--------------------------------------------------
private static boolean needsMultipart ( Connection . Request req ) { for ( Connection . KeyVal keyVal : req . data ( ) ) { if ( keyVal . hasInputStream ( ) ) return true ; } return false ; }
--------------------------------------------------
public static void traverse ( NodeVisitor visitor , Node root ) { Node node = root ; int depth = 0 ; while ( node != null ) { visitor . head ( node , depth ) ; if ( node . childNodeSize ( ) > 0 ) { node = node . childNode ( 0 ) ; depth ++ ; } else { while ( node . nextSibling ( ) == null && depth > 0 ) { visitor . tail ( node , depth ) ; node = node . parentNode ( ) ; depth -- ; } visitor . tail ( node , depth ) ; if ( node == root ) break ; node = node . nextSibling ( ) ; } } }
--------------------------------------------------
