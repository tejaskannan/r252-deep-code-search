public static void filter ( NodeFilter filter , Elements elements ) { Validate . notNull ( filter ) ; Validate . notNull ( elements ) ; for ( Element el : elements ) if ( filter ( filter , el ) == FilterResult . STOP ) break ; }
--------------------------------------------------
public static FilterResult filter ( NodeFilter filter , Node root ) { Node node = root ; int depth = 0 ; while ( node != null ) { FilterResult result = filter . head ( node , depth ) ; if ( result == FilterResult . STOP ) return result ; if ( result == FilterResult . CONTINUE && node . childNodeSize ( ) > 0 ) { node = node . childNode ( 0 ) ; ++ depth ; continue ; } while ( node . nextSibling ( ) == null && depth > 0 ) { if ( result == FilterResult . CONTINUE || result == FilterResult . SKIP_CHILDREN ) { result = filter . tail ( node , depth ) ; if ( result == FilterResult . STOP ) return result ; } Node prev = node ; node = node . parentNode ( ) ; depth -- ; if ( result == FilterResult . REMOVE ) prev . remove ( ) ; result = FilterResult . CONTINUE ; } if ( result == FilterResult . CONTINUE || result == FilterResult . SKIP_CHILDREN ) { result = filter . tail ( node , depth ) ; if ( result == FilterResult . STOP ) return result ; } if ( node == root ) return result ; Node prev = node ; node = node . nextSibling ( ) ; if ( result == FilterResult . REMOVE ) prev . remove ( ) ; } return FilterResult . CONTINUE ; }
--------------------------------------------------
static Elements filterOut ( Collection < Element > elements , Collection < Element > outs ) { Elements output = new Elements ( ) ; for ( Element el : elements ) { boolean found = false ; for ( Element out : outs ) { if ( el . equals ( out ) ) { found = true ; break ; } } if ( ! found ) output . add ( el ) ; } return output ; }
--------------------------------------------------
void putIgnoreCase ( String key , String value ) { int i = indexOfKeyIgnoreCase ( key ) ; if ( i != NotFound ) { vals [ i ] = value ; if ( ! keys [ i ] . equals ( key ) ) keys [ i ] = key ; } else add ( key , value ) ; }
--------------------------------------------------
protected void runParser ( ) { while ( true ) { Token token = tokeniser . read ( ) ; process ( token ) ; token . reset ( ) ; if ( token . type == Token . TokenType . EOF ) break ; } }
--------------------------------------------------
public void normalize ( ) { for ( int i = 0 ; i < size ; i ++ ) { keys [ i ] = lowerCase ( keys [ i ] ) ; } }
--------------------------------------------------
private Elements siblings ( String query , boolean next , boolean all ) { Elements els = new Elements ( ) ; Evaluator eval = query != null ? QueryParser . parse ( query ) : null ; for ( Element e : this ) { do { Element sib = next ? e . nextElementSibling ( ) : e . previousElementSibling ( ) ; if ( sib == null ) break ; if ( eval == null ) els . add ( sib ) ; else if ( sib . is ( eval ) ) els . add ( sib ) ; e = sib ; } while ( all ) ; } return els ; }
--------------------------------------------------
public Elements clone ( ) { Elements clone = new Elements ( size ( ) ) ; for ( Element e : this ) clone . add ( e . clone ( ) ) ; return clone ; }
--------------------------------------------------
private String updateNamespaces ( org . jsoup . nodes . Element el ) { Attributes attributes = el . attributes ( ) ; for ( Attribute attr : attributes ) { String key = attr . getKey ( ) ; String prefix ; if ( key . equals ( xmlnsKey ) ) { prefix = "" ; } else if ( key . startsWith ( xmlnsPrefix ) ) { prefix = key . substring ( xmlnsPrefix . length ( ) ) ; } else { continue ; } namespacesStack . peek ( ) . put ( prefix , attr . getValue ( ) ) ; } int pos = el . tagName ( ) . indexOf ( ":" ) ; return pos > 0 ? el . tagName ( ) . substring ( 0 , pos ) : "" ; }
--------------------------------------------------
protected int calculatePosition ( Element root , Element element ) { int pos = 0 ; Elements family = element . parent ( ) . children ( ) ; for ( int i = element . elementSiblingIndex ( ) ; i < family . size ( ) ; i ++ ) { if ( family . get ( i ) . tag ( ) . equals ( element . tag ( ) ) ) pos ++ ; } return pos ; }
--------------------------------------------------
