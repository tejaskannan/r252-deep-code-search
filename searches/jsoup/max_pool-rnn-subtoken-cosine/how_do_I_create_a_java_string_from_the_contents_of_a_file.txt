static String mimeBoundary ( ) { final StringBuilder mime = StringUtil . borrowBuilder ( ) ; final Random rand = new Random ( ) ; for ( int i = 0 ; i < boundaryLength ; i ++ ) { mime . append ( mimeBoundaryChars [ rand . nextInt ( mimeBoundaryChars . length ) ] ) ; } return StringUtil . releaseBuilder ( mime ) ; }
--------------------------------------------------
int [ ] consumeCharacterReference ( Character additionalAllowedCharacter , boolean inAttribute ) { if ( reader . isEmpty ( ) ) return null ; if ( additionalAllowedCharacter != null && additionalAllowedCharacter == reader . current ( ) ) return null ; if ( reader . matchesAnySorted ( notCharRefCharsSorted ) ) return null ; final int [ ] codeRef = codepointHolder ; reader . mark ( ) ; if ( reader . matchConsume ( "#" ) ) { boolean isHexMode = reader . matchConsumeIgnoreCase ( "x" ) ; String numRef = isHexMode ? reader . consumeHexSequence ( ) : reader . consumeDigitSequence ( ) ; if ( numRef . length ( ) == 0 ) { characterReferenceError ( "numeric reference with no numerals" ) ; reader . rewindToMark ( ) ; return null ; } if ( ! reader . matchConsume ( ";" ) ) characterReferenceError ( "missing semicolon" ) ; int charval = - 1 ; try { int base = isHexMode ? 16 : 10 ; charval = Integer . valueOf ( numRef , base ) ; } catch ( NumberFormatException ignored ) { } if ( charval == - 1 || ( charval >= d800 && charval <= dfff ) || charval > 10ffff ) { characterReferenceError ( "character outside of valid range" ) ; codeRef [ 0 ] = replacementChar ; return codeRef ; } else { if ( charval >= win1252ExtensionsStart && charval < win1252ExtensionsStart + win1252Extensions . length ) { characterReferenceError ( "character is not a valid unicode code point" ) ; charval = win1252Extensions [ charval - win1252ExtensionsStart ] ; } codeRef [ 0 ] = charval ; return codeRef ; } } else { String nameRef = reader . consumeLetterThenDigitSequence ( ) ; boolean looksLegit = reader . matches ( ';' ) ; boolean found = ( Entities . isBaseNamedEntity ( nameRef ) || ( Entities . isNamedEntity ( nameRef ) && looksLegit ) ) ; if ( ! found ) { reader . rewindToMark ( ) ; if ( looksLegit ) characterReferenceError ( String . format ( "invalid named reference '%s'" , nameRef ) ) ; return null ; } if ( inAttribute && ( reader . matchesLetter ( ) || reader . matchesDigit ( ) || reader . matchesAny ( '=' , '-' , '_' ) ) ) { reader . rewindToMark ( ) ; return null ; } if ( ! reader . matchConsume ( ";" ) ) characterReferenceError ( "missing semicolon" ) ; int numChars = Entities . codepointsForName ( nameRef , multipointHolder ) ; if ( numChars == 1 ) { codeRef [ 0 ] = multipointHolder [ 0 ] ; return codeRef ; } else if ( numChars == 2 ) { return multipointHolder ; } else { Validate . fail ( "unexpected characters returned for " + nameRef ) ; return multipointHolder ; } } }
--------------------------------------------------
public CharacterReader ( Reader input , int sz ) { Validate . notNull ( input ) ; Validate . isTrue ( input . markSupported ( ) ) ; reader = input ; charBuf = new char [ sz > maxBufferLen ? maxBufferLen : sz ] ; bufferUp ( ) ; }
--------------------------------------------------
private static String [ ] copyOf ( String [ ] orig , int size ) { final String [ ] copy = new String [ size ] ; System . arraycopy ( orig , 0 , copy , 0 , Math . min ( orig . length , size ) ) ; return copy ; }
--------------------------------------------------
public static String releaseBuilder ( StringBuilder sb ) { Validate . notNull ( sb ) ; String string = sb . toString ( ) ; if ( sb . length ( ) > MaxCachedBuilderSize ) sb = new StringBuilder ( MaxCachedBuilderSize ) ; else sb . delete ( 0 , sb . length ( ) ) ; synchronized ( builders ) { builders . push ( sb ) ; while ( builders . size ( ) > MaxIdleBuilders ) { builders . pop ( ) ; } } return string ; }
--------------------------------------------------
private static String fixHeaderEncoding ( String val ) { try { byte [ ] bytes = val . getBytes ( "iso-8859-1" ) ; if ( ! looksLikeUtf8 ( bytes ) ) return val ; return new String ( bytes , "utf-8" ) ; } catch ( UnsupportedEncodingException e ) { return val ; } }
--------------------------------------------------
static void escape ( Appendable accum , String string , Document . OutputSettings out , boolean inAttribute , boolean normaliseWhite , boolean stripLeadingWhite ) throws IOException { boolean lastWasWhite = false ; boolean reachedNonWhite = false ; final EscapeMode escapeMode = out . escapeMode ( ) ; final CharsetEncoder encoder = out . encoder ( ) ; final CoreCharset coreCharset = out . coreCharset ; final int length = string . length ( ) ; int codePoint ; for ( int offset = 0 ; offset < length ; offset += Character . charCount ( codePoint ) ) { codePoint = string . codePointAt ( offset ) ; if ( normaliseWhite ) { if ( StringUtil . isWhitespace ( codePoint ) ) { if ( ( stripLeadingWhite && ! reachedNonWhite ) || lastWasWhite ) continue ; accum . append ( ' ' ) ; lastWasWhite = true ; continue ; } else { lastWasWhite = false ; reachedNonWhite = true ; } } if ( codePoint < Character . MIN_SUPPLEMENTARY_CODE_POINT ) { final char c = ( char ) codePoint ; switch ( c ) { case '&' : accum . append ( "&amp;" ) ; break ; case a0 : if ( escapeMode != EscapeMode . xhtml ) accum . append ( "&nbsp;" ) ; else accum . append ( "&#xa0;" ) ; break ; case '<' : if ( ! inAttribute || escapeMode == EscapeMode . xhtml ) accum . append ( "&lt;" ) ; else accum . append ( c ) ; break ; case '>' : if ( ! inAttribute ) accum . append ( "&gt;" ) ; else accum . append ( c ) ; break ; case '"' : if ( inAttribute ) accum . append ( "&quot;" ) ; else accum . append ( c ) ; break ; default : if ( canEncode ( coreCharset , c , encoder ) ) accum . append ( c ) ; else appendEncoded ( accum , escapeMode , codePoint ) ; } } else { final String c = new String ( Character . toChars ( codePoint ) ) ; if ( encoder . canEncode ( c ) ) accum . append ( c ) ; else appendEncoded ( accum , escapeMode , codePoint ) ; } } }
--------------------------------------------------
int nextIndexOf ( CharSequence seq ) { bufferUp ( ) ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { if ( startChar != charBuf [ offset ] ) while ( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length ( ) - 1 ; if ( offset < bufLength && last <= bufLength ) { for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) return offset - bufPos ; } } return - 1 ; }
--------------------------------------------------
private boolean anythingElse ( Token t , HtmlTreeBuilder tb ) { tb . error ( this ) ; tb . insert ( new Token . Character ( ) . data ( t . toString ( ) ) ) ; return true ; }
--------------------------------------------------
boolean anythingElse ( Token t , HtmlTreeBuilder tb ) { tb . error ( this ) ; boolean processed ; if ( StringUtil . in ( tb . currentElement ( ) . normalName ( ) , "table" , "tbody" , "tfoot" , "thead" , "tr" ) ) { tb . setFosterInserts ( true ) ; processed = tb . process ( t , InBody ) ; tb . setFosterInserts ( false ) ; } else { processed = tb . process ( t , InBody ) ; } return processed ; }
--------------------------------------------------
