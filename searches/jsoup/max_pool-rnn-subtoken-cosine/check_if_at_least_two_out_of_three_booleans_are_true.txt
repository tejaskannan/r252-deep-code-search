boolean anyOtherEndTag ( Token t , HtmlTreeBuilder tb ) { String name = t . asEndTag ( ) . normalName ; ArrayList < Element > stack = tb . getStack ( ) ; for ( int pos = stack . size ( ) - 1 ; pos >= 0 ; pos -- ) { Element node = stack . get ( pos ) ; if ( node . normalName ( ) . equals ( name ) ) { tb . generateImpliedEndTags ( name ) ; if ( ! name . equals ( tb . currentElement ( ) . normalName ( ) ) ) tb . error ( this ) ; tb . popStackToClose ( name ) ; break ; } else { if ( tb . isSpecial ( node ) ) { tb . error ( this ) ; return false ; } } } return true ; }
--------------------------------------------------
private static void handleDataEndTag ( Tokeniser t , CharacterReader r , TokeniserState elseTransition ) { if ( r . matchesLetter ( ) ) { String name = r . consumeLetterSequence ( ) ; t . tagPending . appendTagName ( name ) ; t . dataBuffer . append ( name ) ; return ; } boolean needsExitTransition = false ; if ( t . isAppropriateEndTagToken ( ) && ! r . isEmpty ( ) ) { char c = r . consume ( ) ; switch ( c ) { case '\t' : case '\n' : case '\r' : case '\f' : case ' ' : t . transition ( BeforeAttributeName ) ; break ; case '/' : t . transition ( SelfClosingStartTag ) ; break ; case '>' : t . emitTagPending ( ) ; t . transition ( Data ) ; break ; default : t . dataBuffer . append ( c ) ; needsExitTransition = true ; } } else { needsExitTransition = true ; } if ( needsExitTransition ) { t . emit ( "</" + t . dataBuffer . toString ( ) ) ; t . transition ( elseTransition ) ; } }
--------------------------------------------------
Element insertEmpty ( Token . StartTag startTag ) { Tag tag = Tag . valueOf ( startTag . name ( ) , settings ) ; Element el = new Element ( tag , baseUri , startTag . attributes ) ; insertNode ( el ) ; if ( startTag . isSelfClosing ( ) ) { if ( tag . isKnownTag ( ) ) { if ( ! tag . isEmpty ( ) ) tokeniser . error ( "tag cannot be self closing; not a void tag" ) ; } else tag . setSelfClosing ( ) ; } return el ; }
--------------------------------------------------
int nextIndexOf ( CharSequence seq ) { bufferUp ( ) ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { if ( startChar != charBuf [ offset ] ) while ( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length ( ) - 1 ; if ( offset < bufLength && last <= bufLength ) { for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) return offset - bufPos ; } } return - 1 ; }
--------------------------------------------------
private static void handleDataDoubleEscapeTag ( Tokeniser t , CharacterReader r , TokeniserState primary , TokeniserState fallback ) { if ( r . matchesLetter ( ) ) { String name = r . consumeLetterSequence ( ) ; t . dataBuffer . append ( name ) ; t . emit ( name ) ; return ; } char c = r . consume ( ) ; switch ( c ) { case '\t' : case '\n' : case '\r' : case '\f' : case ' ' : case '/' : case '>' : if ( t . dataBuffer . toString ( ) . equals ( "script" ) ) t . transition ( primary ) ; else t . transition ( fallback ) ; t . emit ( c ) ; break ; default : r . unconsume ( ) ; t . transition ( fallback ) ; } }
--------------------------------------------------
public boolean hasNext ( ) { while ( attrIter . hasNext ( ) ) { attr = attrIter . next ( ) ; if ( attr . isDataAttribute ( ) ) return true ; } return false ; }
--------------------------------------------------
private boolean anythingElse ( Token t , TreeBuilder tb ) { boolean processed = tb . processEndTag ( "colgroup" ) ; if ( processed ) return tb . process ( t ) ; return true ; }
--------------------------------------------------
void clearFormattingElementsToLastMarker ( ) { while ( ! formattingElements . isEmpty ( ) ) { Element el = removeLastFormattingElement ( ) ; if ( el == null ) break ; } }
--------------------------------------------------
static Response execute ( Connection . Request req , Response previousResponse ) throws IOException { Validate . notNull ( req , "request must not be null" ) ; Validate . notNull ( req . url ( ) , "url must be specified to connect" ) ; String protocol = req . url ( ) . getProtocol ( ) ; if ( ! protocol . equals ( "http" ) && ! protocol . equals ( "https" ) ) throw new MalformedURLException ( "only http & https protocols supported" ) ; final boolean methodHasBody = req . method ( ) . hasBody ( ) ; final boolean hasRequestBody = req . requestBody ( ) != null ; if ( ! methodHasBody ) Validate . isFalse ( hasRequestBody , "cannot set a request body for http method " + req . method ( ) ) ; String mimeBoundary = null ; if ( req . data ( ) . size ( ) > 0 && ( ! methodHasBody || hasRequestBody ) ) serialiseRequestUrl ( req ) ; else if ( methodHasBody ) mimeBoundary = setOutputContentType ( req ) ; long startTime = System . nanoTime ( ) ; HttpURLConnection conn = createConnection ( req ) ; Response res ; try { conn . connect ( ) ; if ( conn . getDoOutput ( ) ) writePost ( req , conn . getOutputStream ( ) , mimeBoundary ) ; int status = conn . getResponseCode ( ) ; res = new Response ( previousResponse ) ; res . setupFromConnection ( conn , previousResponse ) ; res . req = req ; if ( res . hasHeader ( LOCATION ) && req . followRedirects ( ) ) { if ( status != HTTP_TEMP_REDIR ) { req . method ( Method . GET ) ; req . data ( ) . clear ( ) ; req . requestBody ( null ) ; req . removeHeader ( CONTENT_TYPE ) ; } String location = res . header ( LOCATION ) ; if ( location . startsWith ( "http:/" ) && location . charAt ( 6 ) != '/' ) location = location . substring ( 6 ) ; URL redir = StringUtil . resolve ( req . url ( ) , location ) ; req . url ( encodeUrl ( redir ) ) ; for ( Map . Entry < String , String > cookie : res . cookies . entrySet ( ) ) { req . cookie ( cookie . getKey ( ) , cookie . getValue ( ) ) ; } return execute ( req , res ) ; } if ( ( status < 200 || status >= 400 ) && ! req . ignoreHttpErrors ( ) ) throw new HttpStatusException ( "http error fetching url" , status , req . url ( ) . toString ( ) ) ; String contentType = res . contentType ( ) ; if ( contentType != null && ! req . ignoreContentType ( ) && ! contentType . startsWith ( "text/" ) && ! xmlContentTypeRxp . matcher ( contentType ) . matches ( ) ) throw new UnsupportedMimeTypeException ( "unhandled content type. must be text/*, application/xml, or application/xhtml+xml" , contentType , req . url ( ) . toString ( ) ) ; if ( contentType != null && xmlContentTypeRxp . matcher ( contentType ) . matches ( ) ) { if ( req instanceof HttpConnection . Request && ! ( ( Request ) req ) . parserDefined ) { req . parser ( Parser . xmlParser ( ) ) ; } } res . charset = DataUtil . getCharsetFromContentType ( res . contentType ) ; if ( conn . getContentLength ( ) != 0 && req . method ( ) != HEAD ) { res . bodyStream = null ; res . bodyStream = conn . getErrorStream ( ) != null ? conn . getErrorStream ( ) : conn . getInputStream ( ) ; if ( res . hasHeaderWithValue ( CONTENT_ENCODING , "gzip" ) ) { res . bodyStream = new GZIPInputStream ( res . bodyStream ) ; } else if ( res . hasHeaderWithValue ( CONTENT_ENCODING , "deflate" ) ) { res . bodyStream = new InflaterInputStream ( res . bodyStream , new Inflater ( true ) ) ; } res . bodyStream = ConstrainableInputStream . wrap ( res . bodyStream , DataUtil . bufferSize , req . maxBodySize ( ) ) . timeout ( startTime , req . timeout ( ) ) ; } else { res . byteData = DataUtil . emptyByteBuffer ( ) ; } } catch ( IOException e ) { conn . disconnect ( ) ; throw e ; } res . executed = true ; return res ; }
--------------------------------------------------
public boolean isValidBodyHtml ( String bodyHtml ) { Document clean = Document . createShell ( "" ) ; Document dirty = Document . createShell ( "" ) ; ParseErrorList errorList = ParseErrorList . tracking ( 1 ) ; List < Node > nodes = Parser . parseFragment ( bodyHtml , dirty . body ( ) , "" , errorList ) ; dirty . body ( ) . insertChildren ( 0 , nodes ) ; int numDiscarded = copySafeNodes ( dirty . body ( ) , clean . body ( ) ) ; return numDiscarded == 0 && errorList . size ( ) == 0 ; }
--------------------------------------------------
