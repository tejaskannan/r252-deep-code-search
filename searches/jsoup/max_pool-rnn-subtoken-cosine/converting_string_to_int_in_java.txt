static void escape ( Appendable accum , String string , Document . OutputSettings out , boolean inAttribute , boolean normaliseWhite , boolean stripLeadingWhite ) throws IOException { boolean lastWasWhite = false ; boolean reachedNonWhite = false ; final EscapeMode escapeMode = out . escapeMode ( ) ; final CharsetEncoder encoder = out . encoder ( ) ; final CoreCharset coreCharset = out . coreCharset ; final int length = string . length ( ) ; int codePoint ; for ( int offset = 0 ; offset < length ; offset += Character . charCount ( codePoint ) ) { codePoint = string . codePointAt ( offset ) ; if ( normaliseWhite ) { if ( StringUtil . isWhitespace ( codePoint ) ) { if ( ( stripLeadingWhite && ! reachedNonWhite ) || lastWasWhite ) continue ; accum . append ( ' ' ) ; lastWasWhite = true ; continue ; } else { lastWasWhite = false ; reachedNonWhite = true ; } } if ( codePoint < Character . MIN_SUPPLEMENTARY_CODE_POINT ) { final char c = ( char ) codePoint ; switch ( c ) { case '&' : accum . append ( "&amp;" ) ; break ; case a0 : if ( escapeMode != EscapeMode . xhtml ) accum . append ( "&nbsp;" ) ; else accum . append ( "&#xa0;" ) ; break ; case '<' : if ( ! inAttribute || escapeMode == EscapeMode . xhtml ) accum . append ( "&lt;" ) ; else accum . append ( c ) ; break ; case '>' : if ( ! inAttribute ) accum . append ( "&gt;" ) ; else accum . append ( c ) ; break ; case '"' : if ( inAttribute ) accum . append ( "&quot;" ) ; else accum . append ( c ) ; break ; default : if ( canEncode ( coreCharset , c , encoder ) ) accum . append ( c ) ; else appendEncoded ( accum , escapeMode , codePoint ) ; } } else { final String c = new String ( Character . toChars ( codePoint ) ) ; if ( encoder . canEncode ( c ) ) accum . append ( c ) ; else appendEncoded ( accum , escapeMode , codePoint ) ; } } }
--------------------------------------------------
private void ownText ( StringBuilder accum ) { for ( Node child : childNodes ) { if ( child instanceof TextNode ) { TextNode textNode = ( TextNode ) child ; appendNormalisedText ( accum , textNode ) ; } else if ( child instanceof Element ) { appendWhitespaceIfBr ( ( Element ) child , accum ) ; } } }
--------------------------------------------------
String consumeLetterSequence ( ) { bufferUp ( ) ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ; if ( ( c >= 'a' && c <= 'z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; else break ; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; }
--------------------------------------------------
boolean anythingElse ( Token t , HtmlTreeBuilder tb ) { tb . error ( this ) ; boolean processed ; if ( StringUtil . in ( tb . currentElement ( ) . normalName ( ) , "table" , "tbody" , "tfoot" , "thead" , "tr" ) ) { tb . setFosterInserts ( true ) ; processed = tb . process ( t , InBody ) ; tb . setFosterInserts ( false ) ; } else { processed = tb . process ( t , InBody ) ; } return processed ; }
--------------------------------------------------
String consumeLetterThenDigitSequence ( ) { bufferUp ( ) ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ; if ( ( c >= 'a' && c <= 'z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; else break ; } while ( ! isEmptyNoBufferUp ( ) ) { char c = charBuf [ bufPos ] ; if ( c >= '0' && c <= '9' ) bufPos ++ ; else break ; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; }
--------------------------------------------------
public String getPlainText ( Element element ) { FormattingVisitor formatter = new FormattingVisitor ( ) ; NodeTraversor . traverse ( formatter , element ) ; return formatter . toString ( ) ; }
--------------------------------------------------
public String ownText ( ) { StringBuilder sb = StringUtil . borrowBuilder ( ) ; ownText ( sb ) ; return StringUtil . releaseBuilder ( sb ) . trim ( ) ; }
--------------------------------------------------
String unescapeEntities ( boolean inAttribute ) { StringBuilder builder = StringUtil . borrowBuilder ( ) ; while ( ! reader . isEmpty ( ) ) { builder . append ( reader . consumeTo ( '&' ) ) ; if ( reader . matches ( '&' ) ) { reader . consume ( ) ; int [ ] c = consumeCharacterReference ( null , inAttribute ) ; if ( c == null || c . length == 0 ) builder . append ( '&' ) ; else { builder . appendCodePoint ( c [ 0 ] ) ; if ( c . length == 2 ) builder . appendCodePoint ( c [ 1 ] ) ; } } } return StringUtil . releaseBuilder ( builder ) ; }
--------------------------------------------------
String consumeHexSequence ( ) { bufferUp ( ) ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ; if ( ( c >= '0' && c <= '9' ) || ( c >= 'a' && c <= 'f' ) || ( c >= 'a' && c <= 'f' ) ) bufPos ++ ; else break ; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; }
--------------------------------------------------
private static BomCharset detectCharsetFromBom ( final ByteBuffer byteData ) { final Buffer buffer = byteData ; buffer . mark ( ) ; byte [ ] bom = new byte [ 4 ] ; if ( byteData . remaining ( ) >= bom . length ) { byteData . get ( bom ) ; buffer . rewind ( ) ; } if ( bom [ 0 ] == 00 && bom [ 1 ] == 00 && bom [ 2 ] == ( byte ) fe && bom [ 3 ] == ( byte ) ff || bom [ 0 ] == ( byte ) ff && bom [ 1 ] == ( byte ) fe && bom [ 2 ] == 00 && bom [ 3 ] == 00 ) { return new BomCharset ( "utf-32" , false ) ; } else if ( bom [ 0 ] == ( byte ) fe && bom [ 1 ] == ( byte ) ff || bom [ 0 ] == ( byte ) ff && bom [ 1 ] == ( byte ) fe ) { return new BomCharset ( "utf-16" , false ) ; } else if ( bom [ 0 ] == ( byte ) ef && bom [ 1 ] == ( byte ) bb && bom [ 2 ] == ( byte ) bf ) { return new BomCharset ( "utf-8" , true ) ; } return null ; }
--------------------------------------------------
